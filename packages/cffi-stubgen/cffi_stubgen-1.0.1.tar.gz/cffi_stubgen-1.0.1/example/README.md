# `cffi-stubgen` example

This is a simple example of how to generate stubs with `cffi-stubgen`.

In this directory we have an `example_module` that builds some native functions from the `csrc` directory, containing the `C` files and headers.

`cffi-stubgen` particularly wants to generate stubs for the module generated by `cffi`. It will NOT look at your python sources. Whether you want to type-hint them (or generate stubs with regular `stubgen`), that is entirely up to you :)

Consequently, you should pass to `cffi-stubgen` the `cffi`-generated object. What do I mean by that? Simple!
Let us take the `example_module` in this directory. During setup, the `cffi` extension is built in `_build.py`, which contains the line

``` python
ffi_builder.set_source(
    module_name="_example", # <- This is the module name that cffi-stubgen needs
    ...
)
```

This means that the `cffi` object will be at `example_module._example`!

Let us try to install the package and then generate the stubs for it.

> You probably want to run this in a virtual environment. My `example_module` is not particularly exciting :)

First let's install the package with 

``` sh
cd example_module/example_module
pip install .
```

or the equivalent command in your shell of choice.

> Other package installers are available if you are not a `pip` enjoyer ;)

Assuming that `cffi-stubgen` is installed, now it is simply a matter of typing 

``` sh
cffi-stubgen example_module._example
```

and the stubs will be generated wherever your package is installed, so that your type checker can easily find them!

> Want to just have a look at the stubs? Or have them next to your source so you can check them into your version control? The `-o` option of `cffi-stubgen` is there to help!

## A look at the stubs

Just for fun, let us have a look at the actual stubs. 
The `example_module` defines a wonderful function 

``` C
int add(int a, int b);
```

However, type checkers have absolutely no idea what to make of it. Let's try

``` python
from example_module._example import lib

reveal_type(lib.add)
```

`mypy` gives back

``` text
note: Revealed type is "Any"
```

Let us generate the stubs and try again! Now if we `reveal_type`, `mypy` knows about our function!

``` text
note: Revealed type is "def (arg0: _cffi_backend._CDataBase, arg1: _cffi_backend._CDataBase) -> _cffi_backend._CDataBase"
```

This means that it can, for example, statically type-check that the correct number of arguments have been passed, and that they are the right type (how many times have we forgot to `ffi.cast` our inputs?)

But if gets even better! `cffi-stubgen` actually parses the `C` declaration and knows the _actual_ types of the arguments. Therefore, in the stub file is defines `TypeAliases` to reflect the `C` declaration. That means that in your IDE, if you hover on the function, you get all the information you need without having to have the `.h` file open in another tab

![Function types revealed on hover](./assets/vscode.png)

Pretty neat, uh! ;)
