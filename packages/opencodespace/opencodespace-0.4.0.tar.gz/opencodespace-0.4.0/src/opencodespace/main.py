#!/usr/bin/env python3
"""
OpenCodeSpace - Launch disposable VS Code development environments.

This module provides a CLI tool for quickly spinning up development containers
with AI tooling support, either locally using Docker or remotely on various
cloud platforms.
"""

import subprocess
import sys
import os
import secrets
import string
import logging
import platform
import json
from pathlib import Path
from typing import Any, Dict, List, Optional

import click
import toml
import questionary

from .providers import FlyProvider, LocalProvider, ProviderRegistry

__version__ = "0.1.0"
__author__ = "Devadutta Ghat"

# Configure logger for OpenCodeSpace output
def setup_logger() -> logging.Logger:
    """Set up a logger with clear OpenCodeSpace formatting."""
    logger = logging.getLogger('opencodespace')
    
    # Clear any existing handlers
    logger.handlers.clear()
    
    # Create console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    # Create formatter with OpenCodeSpace prefix
    formatter = logging.Formatter('[OpenCodeSpace] %(message)s')
    console_handler.setFormatter(formatter)
    
    # Add handler to logger
    logger.addHandler(console_handler)
    logger.setLevel(logging.INFO)
    logger.propagate = False  # Prevent duplicate output
    
    return logger

# Initialize the logger
logger = setup_logger()


class OpenCodeSpace:
    """
    Main OpenCodeSpace class that handles configuration, setup, and deployment operations.
    """
    
    CONFIG_DIR = ".opencodespace"
    CONFIG_FILENAME = "config.toml"
    
    # Default configuration values
    DEFAULT_CONFIG = {
        "name": "",  # Will be auto-generated by provider if needed
        "platform": "local",
        "upload_folder": True,
        "git_branching": True,
        "api_keys": [],
        "env": {},
        "dockerfile": "Dockerfile",
        "vscode_password": "",  # Will be auto-generated during setup
        "ai_api_keys": {
            "ANTHROPIC_API_KEY": "",
            "GEMINI_API_KEY": "", 
            "OPENAI_API_KEY": ""
        },
        "vscode_config": {
            "copy_settings": False,
            "copy_extensions": False,
            "detected_editors": [],  # List of detected editors: ["vscode", "cursor"]
            "vscode_settings_path": None,
            "cursor_settings_path": None,
            "vscode_extensions_list": [],
            "cursor_extensions_list": []
        }
    }
    
    def __init__(self):
        """Initialize OpenCodeSpace with provider registry."""
        self.provider_registry = ProviderRegistry()
        self.provider_registry.register(FlyProvider)
        self.provider_registry.register(LocalProvider)
    
    def load_default_config(self) -> Dict[str, Any]:
        """
        Return default configuration values.
        
        Returns:
            Default configuration dictionary
        """
        return self.DEFAULT_CONFIG.copy()
    
    def load_or_init_config(self, path: Path, non_interactive: bool = False) -> Dict[str, Any]:
        """
        Load configuration from the project directory or initialize a new one.
        
        If no configuration exists, runs setup wizard (interactive or non-interactive).
        
        Args:
            path: Project directory path
            non_interactive: If True, skip interactive prompts and use defaults
            
        Returns:
            Configuration dictionary
        """
        config_dir = path / self.CONFIG_DIR
        config_path = config_dir / self.CONFIG_FILENAME
        
        if config_path.exists():
            logger.info(f"✅ Found .opencodespace/config.toml")
            try:
                return toml.load(config_path)
            except Exception as e:
                logger.error("❌ Error loading config: {e}")
                sys.exit(1)
        
        if non_interactive:
            logger.info(f"⚙️  No config found. Creating with defaults...")
            config = self.create_default_config(path)
        else:
            logger.info(f"⚙️  No config found. Running first-time setup...")
            config = self.load_default_config()
            config = self.run_interactive_setup(path, config)
        
        # Create .opencodespace directory if it doesn't exist
        config_dir.mkdir(exist_ok=True)
        
        # Save configuration
        try:
            with open(config_path, "w") as f:
                toml.dump(config, f)
            logger.info(f"✅ Saved config to {self.CONFIG_DIR}/{self.CONFIG_FILENAME}")
        except Exception as e:
            logger.info(f"❌ Error saving config: {e}")
            sys.exit(1)
        
        return config
    
    def create_default_config(self, path: Path) -> Dict[str, Any]:
        """
        Create a default configuration without user interaction.
        
        Args:
            path: Project directory path
            
        Returns:
            Default configuration dictionary
        """
        config = self.load_default_config()
        
        # Auto-detect git repository if it exists
        if (path / ".git").exists():
            try:
                result = subprocess.run(
                    ["git", "remote", "get-url", "origin"],
                    cwd=path,
                    capture_output=True,
                    text=True,
                    check=True
                )
                config["git_repo_url"] = result.stdout.strip()
                logger.info(f"✅ Found Git remote: {config['git_repo_url']}")
            except subprocess.CalledProcessError:
                logger.info(f"ℹ️  No Git remote found")
        
        # Generate VS Code/Coder access password
        password = self.generate_password()
        config["vscode_password"] = password
        
        logger.info(f"✅ Using platform: {config['platform']}")
        logger.info(f"✅ Upload folder: {'Yes' if config['upload_folder'] else 'No'}")
        logger.info(f"✅ Generated VS Code password: {password}")
        
        return config
    
    def load_config(self, path: Path) -> Dict[str, Any]:
        """
        Load configuration from the project directory.
        
        Args:
            path: Project directory path
            
        Returns:
            Configuration dictionary
            
        Raises:
            SystemExit: If config doesn't exist
        """
        config_path = path / self.CONFIG_DIR / self.CONFIG_FILENAME
        
        if not config_path.exists():
            logger.info(f"❌ No {self.CONFIG_DIR}/{self.CONFIG_FILENAME} found. Run 'opencodespace' first to set up.")
            sys.exit(1)
        
        try:
            return toml.load(config_path)
        except Exception as e:
            logger.info(f"❌ Error loading config: {e}")
            sys.exit(1)
    
    def save_config(self, path: Path, config: Dict[str, Any]) -> None:
        """
        Save configuration to the project directory.
        
        Args:
            path: Project directory path
            config: Configuration dictionary
        """
        config_path = path / self.CONFIG_DIR / self.CONFIG_FILENAME
        
        try:
            # Create the config directory if it doesn't exist
            config_path.parent.mkdir(parents=True, exist_ok=True)
            with open(config_path, "w") as f:
                toml.dump(config, f)
        except Exception as e:
            logger.info(f"❌ Error saving config: {e}")
            sys.exit(1)
        
    def generate_password(self, length: int = 12) -> str:
        """Generate a secure random password."""
        alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
        return ''.join(secrets.choice(alphabet) for _ in range(length))
    
    def detect_git_repo(self, path: Path) -> Optional[str]:
        """
        Detect if the current directory is a git repository and get the remote URL.
        
        Args:
            path: Project directory path
            
        Returns:
            Git remote URL if found, None otherwise
        """
        if not (path / ".git").exists():
            return None
            
        try:
            result = subprocess.run(
                ["git", "remote", "get-url", "origin"],
                cwd=path,
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            return None
    
    def select_ssh_key_for_git(self) -> Optional[Path]:
        """
        Let user select an SSH key for GitHub access.
        
        Returns:
            Path to selected SSH key or None if skipped
        """
        ssh_dir = Path.home() / ".ssh"
        if not ssh_dir.exists():
            logger.info(f"⚠️  No SSH directory found at ~/.ssh")
            return None
        
        # Find SSH private keys
        key_files = []
        for file in ssh_dir.iterdir():
            if file.is_file() and file.name.startswith("id_") and not file.name.endswith(".pub"):
                key_files.append(file)
        
        if not key_files:
            logger.info(f"⚠️  No SSH keys found in ~/.ssh")
            return None
        
        choices = [key.name for key in key_files] + ["Skip"]
        
        choice = questionary.select(f"Select SSH key for Github access or skip",
            choices=choices,
            default=choices[0],
            qmark="[OpenCodeSpace]"
        ).ask()
        
        if choice == "Skip":
            return None
        
        for key in key_files:
            if key.name == choice:
                return key
        
        return None
    
    def detect_vscode_installation(self) -> Dict[str, bool]:
        """
        Detect if VS Code and/or Cursor are installed locally.
        
        Returns:
            Dictionary with detection results: {"vscode": bool, "cursor": bool}
        """
        results = {"vscode": False, "cursor": False}
        system = platform.system().lower()
        
        # Try to run commands for both editors
        editors_to_check = [
            ("vscode", "code"),
            ("cursor", "cursor")
        ]
        
        for editor_name, command in editors_to_check:
            try:
                result = subprocess.run(
                    [command, "--version"],
                    capture_output=True,
                    text=True,
                    check=True,
                    timeout=5
                )
                results[editor_name] = True
                continue
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
                pass
        
        # Check common installation paths by platform
        if system == "darwin":  # macOS
            paths_to_check = [
                ("vscode", [
                    "/Applications/Visual Studio Code.app",
                    Path.home() / "Applications" / "Visual Studio Code.app"
                ]),
                ("cursor", [
                    "/Applications/Cursor.app",
                    Path.home() / "Applications" / "Cursor.app"
                ])
            ]
        elif system == "windows":
            paths_to_check = [
                ("vscode", [
                    Path(os.environ.get("PROGRAMFILES", "")) / "Microsoft VS Code" / "Code.exe",
                    Path(os.environ.get("PROGRAMFILES(X86)", "")) / "Microsoft VS Code" / "Code.exe",
                    Path(os.environ.get("LOCALAPPDATA", "")) / "Programs" / "Microsoft VS Code" / "Code.exe"
                ]),
                ("cursor", [
                    Path(os.environ.get("PROGRAMFILES", "")) / "Cursor" / "Cursor.exe",
                    Path(os.environ.get("PROGRAMFILES(X86)", "")) / "Cursor" / "Cursor.exe",
                    Path(os.environ.get("LOCALAPPDATA", "")) / "Programs" / "Cursor" / "Cursor.exe"
                ])
            ]
        elif system == "linux":
            paths_to_check = [
                ("vscode", [
                    Path("/usr/bin/code"),
                    Path("/usr/local/bin/code"),
                    Path("/snap/bin/code"),
                    Path("/opt/visual-studio-code/code")
                ]),
                ("cursor", [
                    Path("/usr/bin/cursor"),
                    Path("/usr/local/bin/cursor"),
                    Path("/snap/bin/cursor"),
                    Path("/opt/cursor/cursor")
                ])
            ]
        else:
            paths_to_check = []
        
        # Check if any of the paths exist for each editor
        for editor_name, paths in paths_to_check:
            if not results[editor_name]:  # Only check if not already detected
                for path in paths:
                    if Path(path).exists():
                        results[editor_name] = True
                        break
        
        return results
    
    def get_editor_settings_paths(self) -> Dict[str, Optional[Path]]:
        """
        Get the paths to VS Code and Cursor user settings.
        
        Returns:
            Dictionary with settings paths: {"vscode": Path or None, "cursor": Path or None}
        """
        system = platform.system().lower()
        results = {"vscode": None, "cursor": None}
        
        if system == "darwin":  # macOS
            settings_paths = {
                "vscode": Path.home() / "Library" / "Application Support" / "Code" / "User" / "settings.json",
                "cursor": Path.home() / "Library" / "Application Support" / "Cursor" / "User" / "settings.json"
            }
        elif system == "windows":
            settings_paths = {
                "vscode": Path(os.environ.get("APPDATA", "")) / "Code" / "User" / "settings.json",
                "cursor": Path(os.environ.get("APPDATA", "")) / "Cursor" / "User" / "settings.json"
            }
        elif system == "linux":
            settings_paths = {
                "vscode": Path.home() / ".config" / "Code" / "User" / "settings.json",
                "cursor": Path.home() / ".config" / "Cursor" / "User" / "settings.json"
            }
        else:
            return results
        
        # Check which settings files exist
        for editor, path in settings_paths.items():
            if path.exists():
                results[editor] = path
        
        return results
    
    def get_editor_extensions(self) -> Dict[str, List[str]]:
        """
        Get list of installed extensions for VS Code and Cursor.
        
        Returns:
            Dictionary with extension lists: {"vscode": [extensions], "cursor": [extensions]}
        """
        results = {"vscode": [], "cursor": []}
        
        # Try to get extensions for each editor
        editors_to_check = [
            ("vscode", "code"),
            ("cursor", "cursor")
        ]
        
        for editor_name, command in editors_to_check:
            try:
                result = subprocess.run(
                    [command, "--list-extensions"],
                    capture_output=True,
                    text=True,
                    check=True,
                    timeout=10
                )
                extensions = result.stdout.strip().split('\n')
                results[editor_name] = [ext.strip() for ext in extensions if ext.strip()]
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
                results[editor_name] = []
        
        return results
    
    def setup_vscode_config_copy(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Setup VS Code and Cursor configuration copying during interactive setup.
        
        Args:
            config: Current configuration dictionary
            
        Returns:
            Updated configuration with editor settings
        """
        logger.info(f"💻 Editor Configuration Detection")
        
        # Detect which editors are installed
        detected_editors = self.detect_vscode_installation()
        detected_names = [name for name, installed in detected_editors.items() if installed]
        
        if not detected_names:
            logger.info(f"⚠️  No VS Code or Cursor installations detected.")
            logger.info(f"You can still access VS Code in your remote environment.")
            return config
        
        editor_display_names = {"vscode": "VS Code", "cursor": "Cursor"}
        detected_display = [editor_display_names[name] for name in detected_names]
        logger.info(f"✅ Detected editors: {', '.join(detected_display)}")
        
        if not questionary.confirm(
            "Would you like to copy your local editor settings and extensions to the remote environment?",
            default=True,
            auto_enter=False,
            qmark="[OpenCodeSpace]"
        ).ask():
            logger.info(f"⏭️  Skipping editor configuration copy.")
            return config
        
        if "vscode_config" not in config:
            config["vscode_config"] = {
                "copy_settings": False,
                "copy_extensions": False,
                "detected_editors": [],
                "vscode_settings_path": None,
                "cursor_settings_path": None,
                "vscode_extensions_list": [],
                "cursor_extensions_list": []
            }
        
        # Store which editors were detected
        config["vscode_config"]["detected_editors"] = detected_names
        
        # Check for settings files
        settings_paths = self.get_editor_settings_paths()
        settings_to_copy = []
        
        for editor_name in detected_names:
            path = settings_paths.get(editor_name)
            if path:
                editor_display = editor_display_names[editor_name]
                logger.info(f"📄 {editor_display} settings found: {path}")
                if questionary.confirm(f"Copy {editor_display} settings?", default=True, auto_enter=False, qmark="[OpenCodeSpace]").ask():
                    config["vscode_config"]["copy_settings"] = True
                    config["vscode_config"][f"{editor_name}_settings_path"] = str(path)
                    settings_to_copy.append(editor_display)
                    logger.info(f"✅ {editor_display} settings will be copied.")
                else:
                    logger.info(f"⏭️  Skipping {editor_display} settings copy.")
            else:
                logger.info(f"⚠️  No {editor_display_names[editor_name]} settings file found.")
        
        # Check for extensions
        extensions_data = self.get_editor_extensions()
        extensions_to_copy = []
        
        for editor_name in detected_names:
            ext_list = extensions_data.get(editor_name, [])
            editor_display = editor_display_names[editor_name]
            
            if ext_list:
                logger.info(f"🧩 Found {len(ext_list)} installed {editor_display} extensions")
                
                if len(ext_list) <= 5:
                    logger.info(f"{editor_display} extensions:")
                    for ext in ext_list:
                        logger.info(f"     • {ext}")
                else:
                    logger.info(f"{editor_display} extensions (showing first 5):")
                    for ext in ext_list[:5]:
                        logger.info(f"     • {ext}")
                    logger.info(f"     ... and {len(ext_list) - 5} more")
                
                if questionary.confirm(f"Copy all {editor_display} extensions?", default=True, auto_enter=False, qmark="[OpenCodeSpace]").ask():
                    config["vscode_config"]["copy_extensions"] = True
                    config["vscode_config"][f"{editor_name}_extensions_list"] = ext_list
                    extensions_to_copy.append(f"{len(ext_list)} {editor_display}")
                    logger.info(f"✅ {len(ext_list)} {editor_display} extensions will be installed.")
                else:
                    logger.info(f"⏭️  Skipping {editor_display} extensions copy.")
            else:
                logger.info(f"⚠️  No {editor_display} extensions found.")
        
        # Summary
        items_to_copy = []
        if settings_to_copy:
            items_to_copy.extend([f"{editor} settings" for editor in settings_to_copy])
        if extensions_to_copy:
            items_to_copy.extend([f"{ext} extensions" for ext in extensions_to_copy])
        
        if items_to_copy:
            logger.info(f"🎉 Editor configuration ready: {', '.join(items_to_copy)} will be copied!")
        else:
            logger.info(f"📂 Remote environment will start with default editor configuration.")
        
        return config
    
    def setup_ai_api_keys(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Setup AI API keys during interactive configuration.
        
        Args:
            config: Current configuration dictionary
            
        Returns:
            Updated configuration with AI API keys
        """
        logger.info(f"🤖 AI API Keys Configuration")
        
        # Ask if user wants to configure AI API keys
        if not questionary.confirm(
            "Would you like to configure AI API keys for your development environment?",
            default=False,
            auto_enter=False,
            qmark="[OpenCodeSpace]"
        ).ask():
            logger.info(f"⏭️  Skipping AI API keys configuration.")
            return config
        
        logger.info(f"Configure your AI API keys (leave empty to skip individual keys):")
        
        # List of AI providers to configure
        ai_providers = [
            ("ANTHROPIC_API_KEY", "Anthropic (Claude)", "Enter your Anthropic API key:"),
            ("GEMINI_API_KEY", "Google Gemini", "Enter your Google Gemini API key:"),
            ("OPENAI_API_KEY", "OpenAI (ChatGPT)", "Enter your OpenAI API key:")
        ]
        
        for key_name, provider_name, prompt in ai_providers:
            logger.info(f"🔑 {provider_name}")
            
            # Use questionary.password to hide the API key input
            api_key = questionary.password(
                prompt,
                qmark="[OpenCodeSpace]"
            ).ask()
            
            if api_key and api_key.strip():
                config["ai_api_keys"][key_name] = api_key.strip()
                logger.info(f"✅ {provider_name} API key configured")
            else:
                logger.info(f"⏭️  Skipped {provider_name} API key")
        
        # Summary
        configured_keys = [key for key, value in config["ai_api_keys"].items() if value]
        if configured_keys:
            logger.info(f"🎉 Configured {len(configured_keys)} AI API key(s): {', '.join(configured_keys)}")
            logger.info(f"These will be available as environment variables in your development environment.")
        else:
            logger.info(f"📂 No AI API keys configured. You can add them later by editing your config.toml")
        
        return config
    
    def run_interactive_setup(self, path: Path, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run interactive configuration setup with a clean, natural flow.
        
        Flow:
        1. Welcome message with version info
        2. Platform selection
        3. Git repository detection and setup
        4. SSH key or folder upload options
        5. VS Code/Coder password generation
        6. Platform-specific notes
        7. Editor configuration copying (VS Code and Cursor settings/extensions)
        8. AI API keys configuration (Anthropic, Gemini, OpenAI)
        
        Args:
            path: Project directory path
            config: Default configuration to start with
            
        Returns:
            Updated configuration dictionary
        """
        # Step 1: Welcome message
        logger.info(f"🧙 Welcome to OpenCodeSpace v{__version__}")
        logger.info(f"🧙 Interactive setup wizard")
        logger.info(f"📁 Project: {path}")
        
        # Step 2: Platform selection
        available_providers = self.provider_registry.list_providers()
        
        # Use consistent default platform - first available provider if current platform not available
        default_platform = config.get("platform", available_providers[0] if available_providers else "local")
        
        platform = questionary.select(
            "\nSelect platform:",
            choices=available_providers,
            default=default_platform if default_platform in available_providers else available_providers[0],
            qmark="[OpenCodeSpace]"
        ).ask()
        
        config["platform"] = platform
        logger.info(f"✅ Selected platform: {platform}")
        
        # Step 3: Git repository detection and setup
        git_remote_url = self.detect_git_repo(path)
        
        if git_remote_url:
            logger.info(f"🎯 Git repository detected in current directory")
            logger.info(f"Repository: {git_remote_url}")
            
            if questionary.confirm("📥 Would you like to clone this repository in your container?", default=True, auto_enter=False, qmark="[OpenCodeSpace]").ask():
                config["git_repo_url"] = git_remote_url
                config["upload_folder"] = False  # We'll clone, not upload
                
                # Step 4a: SSH key setup for git access
                logger.info(f"🔐 To clone private repositories, you'll need an SSH key with GitHub access.")
                ssh_key = self.select_ssh_key_for_git()
                
                if ssh_key:
                    config["ssh_key_path"] = str(ssh_key)
                    logger.info(f"✅ SSH key selected: {ssh_key.name}")
                    logger.info(f"Your repository will be cloned using this SSH key.")
                else:
                    logger.info(f"⚠️  No SSH key selected.")
                    if git_remote_url.startswith("git@") or "private" in git_remote_url.lower():
                        logger.info(f"⚠️  This may be a private repository - cloning might fail without SSH key.")
                    
                    # Fallback to folder upload
                    if questionary.confirm("📁 Would you like to upload your current folder instead?", default=True, auto_enter=False, qmark="[OpenCodeSpace]").ask():
                        config["upload_folder"] = True
                        config.pop("git_repo_url", None)  # Remove git repo since we're uploading
                        logger.info(f"✅ Current folder will be uploaded to the container.")
                    else:
                        config["upload_folder"] = False
                        config.pop("git_repo_url", None)
                        logger.info(f"📂 Container will start with an empty workspace.")
                        logger.info(f"You can clone repositories or create new projects once inside.")
            else:
                # User doesn't want to clone the repo
                if questionary.confirm("📁 Would you like to upload your current folder instead?", default=True, auto_enter=False, qmark="[OpenCodeSpace]").ask():
                    config["upload_folder"] = True
                    logger.info(f"✅ Current folder will be uploaded to the container.")
                else:
                    config["upload_folder"] = False
                    logger.info(f"📂 Container will start with an empty workspace.")
                    logger.info(f"You can clone repositories or create new projects once inside.")
        else:
            # No git repository detected
            logger.info(f"📁 No git repository detected in this directory.")
            
            if questionary.confirm("Would you like to upload the current folder to your container?", default=True, auto_enter=False, qmark="[OpenCodeSpace]").ask():
                config["upload_folder"] = True
                logger.info(f"✅ Current folder will be uploaded to the container.")
            else:
                config["upload_folder"] = False
                logger.info(f"📂 Container will start with an empty workspace.")
                logger.info(f"You can clone repositories or create new projects once inside.")
        
        # Step 5: Generate VS Code/Coder access password
        logger.info(f"\n🔐 Setting up VS Code/Coder authentication...")
        password = self.generate_password()
        config["vscode_password"] = password
        
        logger.info(f"🔑 VS CODE ACCESS DETAILS")
        logger.info(f" Password: {password:<30}")
        logger.info(f"⚠️  Save this password!")
        logger.info(f"You'll need it to access VS Code/Coder in your browser environment.")
        
        # Step 6: Platform-specific notes
        try:
            provider = self.provider_registry.get(config["platform"])
            
            # Use provider-specific icons for known platforms, generic for others
            platform_icons = {
                "fly": "☁️",
                "local": "🏠",
                "aws": "☁️",
                "gcp": "☁️",
                "azure": "☁️"
            }
            icon = platform_icons.get(config["platform"], "🚀")
            
            logger.info(f"{icon} {config['platform'].title()} platform selected.")
            logger.info(f"📋 {provider.description}")
            logger.info(f"🔑 Use the password above for authentication")
            logger.info(f"🌐 VS Code will be accessible via web browser")
            
        except ValueError as e:
            logger.warning(f"⚠️  Unknown platform '{config['platform']}': {e}")
            logger.info(f"🔑 Use the password above for authentication")
        
        # Initialize empty API keys (can be added later)
        config["api_keys"] = []
        config["env"] = {}
        
        # Step 7: Setup editor configuration copy (VS Code and Cursor)
        config = self.setup_vscode_config_copy(config)
        
        # Step 8: Collect AI API keys
        config = self.setup_ai_api_keys(config)
        
        # Final friendly password reminder
        logger.info(f"🎉 Setup complete! Your {config['platform']} environment is ready to deploy.")
        logger.info(f"🔐 DON'T FORGET YOUR ACCESS PASSWORD!")
        logger.info(f"Password: {config['vscode_password']}")
        logger.info(f"(This has been saved to your .opencodespace/config.toml)")
        logger.info(f"Copy this password - you'll need it to log into VS Code/Coder in your browser! 🚀")
        
        return config
    
    def validate_project_path(self, path: Path) -> None:
        """
        Validate that the project path exists and is a directory.
        
        Args:
            path: Path to validate
            
        Raises:
            SystemExit: If path is invalid
        """
        if not path.exists():
            logger.info(f"❌ Directory does not exist: {path}")
            sys.exit(1)
        
        if not path.is_dir():
            logger.info(f"❌ Path is not a directory: {path}")
            sys.exit(1)
    
    def deploy(self, folder: Path, non_interactive: bool = False, platform: str = None) -> None:
        """
        Handle the deploy command.
        
        Args:
            folder: Project directory path
            non_interactive: Whether to skip interactive prompts
            platform: Optional platform override
        """
        logger.info(f"🚀 OpenCodeSpace v{__version__}")
        logger.info(f"📁 Project: {folder}")
        
        # Load or initialize configuration
        config = self.load_or_init_config(folder, non_interactive)
        
        # Override platform if specified via command line
        if platform:
            # Validate platform exists before overriding config
            available_providers = self.provider_registry.list_providers()
            if platform not in available_providers:
                logger.error(f"❌ Unknown platform '{platform}'. Available platforms: {', '.join(available_providers)}")
                sys.exit(1)
            
            config["platform"] = platform
            logger.info(f"🔄 Platform overridden to: {platform}")
        
        # Get and run the appropriate provider
        provider = self.provider_registry.get(config["platform"])
        logger.info(f"🔧 Using {provider.name} provider")
        
        # Deploy
        provider.deploy(folder, config)
        
        # Save config with generated name if it was created
        self.save_config(folder, config)

        logger.info(f"**************************************************")
        logger.info(f"🔑 Code-server password: {config['vscode_password']}")
        logger.info(f"**************************************************")
        
    
    def stop(self, folder: Path) -> None:
        """
        Handle the stop command.
        
        Args:
            folder: Project directory path
        """
        config = self.load_config(folder)
        provider = self.provider_registry.get(config["platform"])
        provider.stop(config)
    
    def remove(self, folder: Path) -> None:
        """
        Handle the remove command.
        
        Args:
            folder: Project directory path
        """
        config = self.load_config(folder)
        provider = self.provider_registry.get(config["platform"])
        provider.remove(config)
    
    def list_providers(self) -> List[str]:
        """
        Get list of available providers.
        
        Returns:
            List of provider names
        """
        return self.provider_registry.list_providers()
    
    def get_provider_info(self) -> Dict[str, str]:
        """
        Get provider information.
        
        Returns:
            Dictionary mapping provider names to descriptions
        """
        return self.provider_registry.get_provider_info()


# CLI Interface - maintains the same external interface
@click.group(invoke_without_command=True)
@click.option('--version', '-v', is_flag=True, help='Show version and exit')
@click.option('--yes', '-y', is_flag=True, help='Skip interactive prompts and use defaults')
@click.option('--list-providers', is_flag=True, help='List available deployment providers')
@click.pass_context
def cli(ctx, version, yes, list_providers):
    """Deploy disposable VS Code development environments.
    
    For more information, visit: https://github.com/devadutta/opencodespace
    """
    # Ensure that ctx.obj exists and is a dict
    ctx.ensure_object(dict)
    ctx.obj['yes'] = yes
    ctx.obj['opencodespace'] = OpenCodeSpace()
    
    if version:
        click.echo(f"OpenCodeSpace {__version__}")
        ctx.exit()
    
    if list_providers:
        ocs = ctx.obj['opencodespace']
        info = ocs.get_provider_info()
        click.echo("Available providers:")
        for name, description in info.items():
            click.echo(f"  {name}: {description}")
        ctx.exit()
    
    # If no command was provided, default to deploy with current directory
    if ctx.invoked_subcommand is None:
        ctx.invoke(deploy, path='.')


@cli.command()
@click.argument('path', default='.', type=click.Path(exists=True, file_okay=False))
@click.option('--platform', help='Deployment platform to use (overrides config)')
@click.pass_context
def deploy(ctx, path, platform):
    """Deploy a new environment (default command)."""
    try:
        folder = Path(path).resolve()
        ocs = ctx.obj['opencodespace']
        ocs.validate_project_path(folder)
        ocs.deploy(folder, ctx.obj.get('yes', False), platform)
    except RuntimeError as e:
        click.echo(f"\n❌ Error: {e}")
        ctx.exit(1)
    except KeyboardInterrupt:
        click.echo("\n\n⚠️  Operation cancelled by user.")
        ctx.exit(130)
    except Exception as e:
        click.echo(f"\n❌ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        ctx.exit(1)


@cli.command()
@click.argument('path', default='.', type=click.Path(exists=True, file_okay=False))
@click.pass_context
def stop(ctx, path):
    """Stop the environment."""
    try:
        folder = Path(path).resolve()
        ocs = ctx.obj['opencodespace']
        ocs.validate_project_path(folder)
        ocs.stop(folder)
    except RuntimeError as e:
        click.echo(f"\n❌ Error: {e}")
        sys.exit(1)
    except Exception as e:
        click.echo(f"\n❌ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


@cli.command()
@click.argument('path', default='.', type=click.Path(exists=True, file_okay=False))
@click.pass_context
def remove(ctx, path):
    """Remove the environment."""
    try:
        folder = Path(path).resolve()
        ocs = ctx.obj['opencodespace']
        ocs.validate_project_path(folder)
        ocs.remove(folder)
    except RuntimeError as e:
        click.echo(f"\n❌ Error: {e}")
        sys.exit(1)
    except Exception as e:
        click.echo(f"\n❌ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def main():
    """Main entry point for the OpenCodeSpace CLI."""
    cli()


if __name__ == "__main__":
    main() 