Metadata-Version: 2.3
Name: sincpro-log
Version: 1.0.1
Summary: A logging module for sincpro applications
License: LICENSE.md
Author: Andres Gutierrez
Author-email: andru1236@gmail.com
Requires-Python: >=3.12,<4.0
Classifier: License :: Other/Proprietary License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Requires-Dist: structlog (>=25.4.0,<26.0.0)
Description-Content-Type: text/markdown

# SincPro Logger

Biblioteca de logging estructurado para aplicaciones SincPro, construida sobre `structlog` con capacidades avanzadas de registro.

## CaracterÃ­sticas principales

- **Logging estructurado**: formatos JSON (producciÃ³n) y consola con colores (desarrollo)
- **IntegraciÃ³n con Grafana Loki**: envÃ­o de logs para centralizaciÃ³n y alertas
- **Contexto enriquecido**: bind/unbind de datos contextuales
- **Tipado seguro**: interfaces completamente tipadas para Python 3.12+

## ðŸš€ Optimizado para Kubernetes y Observabilidad

**Sincpro Logger** estÃ¡ especialmente diseÃ±ado para aplicaciones containerizadas y sistemas de observabilidad modernos:

### IntegraciÃ³n con Kubernetes
- **Formato JSON nativo**: Compatible directamente con FluentD, FluentBit y otros log aggregators
- **Metadatos estructurados**: Facilita la correlaciÃ³n de logs entre pods y servicios
- **Context propagation**: Soporte nativo para trace_id y request_id en microservicios
- **Resource labeling**: Etiquetas automÃ¡ticas para namespace, pod, container

### Sistemas de Observabilidad
- **Grafana Loki**: IntegraciÃ³n directa con push automÃ¡tico y etiquetas dinÃ¡micas
- **OpenTelemetry ready**: Compatible con estÃ¡ndares de trazabilidad distribuida
- **Structured queries**: Logs optimizados para consultas en Grafana, Kibana y DataDog
- **Alerting support**: Campos estructurados para configuraciÃ³n de alertas automÃ¡ticas

### Beneficios en Contenedores
```python
# ConfiguraciÃ³n tÃ­pica para Kubernetes
logger = create_logger(
    "payment-service",
    namespace="production",
    pod_name=os.getenv("HOSTNAME"),
    version=os.getenv("APP_VERSION", "unknown")
)

# Context tracing automÃ¡tico para microservicios
with logger.tracing() as traced_logger:
    traced_logger.info("Processing payment", amount=100.50)
    # trace_id y request_id se propagan automÃ¡ticamente
```

## InstalaciÃ³n rÃ¡pida

```bash
pip install sincpro-logger
# o con Poetry
poetry add sincpro-logger
```

## ðŸ“‹ ConfiguraciÃ³n inicial

**âš ï¸ IMPORTANTE**: La configuraciÃ³n del logger debe ser lo **primero** que se haga en tu aplicaciÃ³n, antes de cualquier import o uso de logging.

### 1. ConfiguraciÃ³n global del sistema de logging

```python
from sincpro_log import configure_global_logging

# Para desarrollo (formato legible con colores)
configure_global_logging(level="DEBUG")

# Para producciÃ³n (formato JSON estructurado)
configure_global_logging(level="INFO")
```

### 2. ConfiguraciÃ³n tÃ­pica en main.py o app.py

```python
# main.py
import os
from sincpro_log import configure_global_logging, create_logger


def setup_logging():
    """Configurar logging segÃºn el entorno."""
    # Detectar entorno
    environment = os.getenv("ENVIRONMENT", "development")

    if environment == "production":
        configure_global_logging(level="INFO")  # JSON estructurado
    else:
        configure_global_logging(level="DEBUG")  # Formato legible

    return environment


def main():
    # PASO 1: Configurar logging ANTES que todo
    env = setup_logging()

    # PASO 2: Crear logger de la aplicaciÃ³n
    logger = create_logger(
        "mi-aplicacion",
        environment=env,
        version=os.getenv("APP_VERSION", "unknown")
    )

    logger.info("AplicaciÃ³n iniciada", environment=env)

    # Resto de la aplicaciÃ³n...


if __name__ == "__main__":
    main()
```

## ðŸ—ï¸ CreaciÃ³n y uso de loggers

### CreaciÃ³n bÃ¡sica

```python
from sincpro_log import create_logger

# Logger bÃ¡sico
logger = create_logger("mi-app")

# Logger con contexto inicial
logger = create_logger(
    "payment-service",
    environment="production",
    version="1.2.3",
    component="api"
)
```

### AÃ±adir y remover contexto persistente

```python
# AÃ±adir campos que persisten en todos los logs
logger.bind(user_id="12345", session_id="abc-def")
logger.info("Usuario autenticado")  # IncluirÃ¡ user_id y session_id

# Remover campos especÃ­ficos
logger.unbind("session_id")
logger.info("SesiÃ³n terminada")  # Solo incluirÃ¡ user_id

# Contexto temporal (solo dentro del bloque)
with logger.context(operation="payment", amount=100.50) as temp_logger:
    temp_logger.info("Iniciando pago")  # Incluye operation y amount
    temp_logger.error("Error en pago")  # Incluye operation y amount

logger.info("Pago finalizado")  # NO incluye operation ni amount
```

### Niveles de logging disponibles

```python
logger.debug("InformaciÃ³n de depuraciÃ³n")
logger.info("InformaciÃ³n general")
logger.warning("Advertencia")
logger.error("Error controlado")
logger.critical("Error crÃ­tico")
logger.exception("Error con stack trace")  # Usar dentro de except
```

## ðŸ” Trazabilidad: trace_id y request_id

### Â¿QuÃ© son y cuÃ¡ndo usarlos?

- **`trace_id`**: Identificador Ãºnico que sigue una operaciÃ³n completa a travÃ©s de mÃºltiples servicios
- **`request_id`**: Identificador Ãºnico para una peticiÃ³n HTTP especÃ­fica

**Casos de uso tÃ­picos:**
- **Microservicios**: Rastrear una operaciÃ³n que pasa por varios servicios
- **APIs REST**: Asociar todos los logs de una peticiÃ³n HTTP
- **Procesamiento asÃ­ncrono**: Seguir trabajos en background
- **Debugging**: Correlacionar logs relacionados en sistemas distribuidos

### Uso con IDs existentes (recibidos)

```python
# Escenario: Recibir trace_id de otro servicio
incoming_trace_id = request.headers.get("X-Trace-ID")
incoming_request_id = request.headers.get("X-Request-ID")

# Usar IDs existentes
with logger.tracing(trace_id=incoming_trace_id, request_id=incoming_request_id) as traced_logger:
    traced_logger.info("Procesando peticiÃ³n de otro servicio")
    # Todos los logs tendrÃ¡n estos IDs especÃ­ficos
```

### Uso con IDs auto-generados (cuando no existen)

```python
# Generar automÃ¡ticamente si no se proporcionan
with logger.tracing() as traced_logger:
    traced_logger.info("Nueva operaciÃ³n iniciada")
    # Se generan automÃ¡ticamente trace_id y request_id Ãºnicos
    
    # Obtener los IDs generados para enviar a otros servicios
    current_trace = traced_logger.get_current_trace_id()
    current_request = traced_logger.get_current_request_id()
    
    # Propagar a servicios downstream
    headers = traced_logger.get_traceability_headers()
    # headers = {"X-Trace-ID": "...", "X-Request-ID": "..."}
```

### Context managers individuales

```python
# Solo trace_id
with logger.trace_id("existing-trace-123") as traced_logger:
    traced_logger.info("OperaciÃ³n con trace especÃ­fico")

# Solo request_id
with logger.request_id() as request_logger:  # Auto-genera si no se especifica
    request_logger.info("PeticiÃ³n con ID Ãºnico")

# Combinados
with logger.trace_id("trace-abc") as tl:
    with tl.request_id("request-xyz") as full_logger:
        full_logger.info("Con ambos IDs especÃ­ficos")
```

### IntegraciÃ³n con frameworks web

```python
# Flask
from flask import request

@app.before_request
def setup_request_logging():
    trace_id = request.headers.get("X-Trace-ID")
    request_id = request.headers.get("X-Request-ID")
    
    g.logger = logger.tracing(trace_id=trace_id, request_id=request_id).__enter__()

# FastAPI
from fastapi import Request

@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    trace_id = request.headers.get("X-Trace-ID")
    request_id = request.headers.get("X-Request-ID")
    
    with logger.tracing(trace_id=trace_id, request_id=request_id) as request_logger:
        request.state.logger = request_logger
        response = await call_next(request)
        return response
```

### Propagar metadatos entre servicios

```python
# Servicio A: Enviar peticiÃ³n a Servicio B
with logger.tracing() as traced_logger:
    traced_logger.info("Llamando al servicio de pagos")
    
    # Obtener headers para propagaciÃ³n
    headers = traced_logger.get_traceability_headers()
    
    # Hacer peticiÃ³n HTTP con headers de trazabilidad
    response = requests.post(
        "https://payment-service/process",
        json={"amount": 100.50},
        headers=headers  # {"X-Trace-ID": "...", "X-Request-ID": "..."}
    )
    
    traced_logger.info("Respuesta del servicio de pagos", status=response.status_code)

# Servicio B: Recibir y usar los IDs
def process_payment(request):
    # Extraer IDs del request
    trace_id = request.headers.get("X-Trace-ID")
    request_id = request.headers.get("X-Request-ID")
    
    # Usar los IDs recibidos
    with logger.tracing(trace_id=trace_id, request_id=request_id) as payment_logger:
        payment_logger.info("Procesando pago recibido")
        # Todos los logs mantendrÃ¡n la trazabilidad original
```

### Ejemplo completo: E-commerce checkout

```python
def checkout_process(user_id: str, cart_items: list):
    """Proceso completo de checkout con trazabilidad."""
    
    # Iniciar nueva transacciÃ³n
    with logger.tracing() as checkout_logger:
        checkout_logger.info(
            "Iniciando checkout",
            user_id=user_id,
            items_count=len(cart_items)
        )
        
        try:
            # Validar inventario
            with checkout_logger.context(step="inventory_check") as step_logger:
                step_logger.info("Verificando inventario")
                # validate_inventory(cart_items)
                step_logger.info("Inventario validado")
            
            # Procesar pago (enviar a servicio externo)
            payment_headers = checkout_logger.get_traceability_headers()
            with checkout_logger.context(step="payment") as payment_logger:
                payment_logger.info("Procesando pago")
                # payment_response = call_payment_service(headers=payment_headers)
                payment_logger.info("Pago procesado exitosamente")
            
            # Actualizar inventario
            with checkout_logger.context(step="inventory_update") as inv_logger:
                inv_logger.info("Actualizando inventario")
                # update_inventory(cart_items)
                inv_logger.info("Inventario actualizado")
            
            checkout_logger.info("Checkout completado exitosamente")
            
        except Exception as e:
            checkout_logger.exception("Error en checkout", error_step="unknown")
            raise
```

## Arquitectura

DiseÃ±ado con Clean Architecture (Domain-Driven Design):
- **Dominio**: Modelos y entidades centrales
- **Casos de uso**: LÃ³gica de negocio para logs
- **Infraestructura**: IntegraciÃ³n con servicios externos

## Licencia

Copyright Â© 2024 Sincpro S.R.L. Todos los derechos reservados.

