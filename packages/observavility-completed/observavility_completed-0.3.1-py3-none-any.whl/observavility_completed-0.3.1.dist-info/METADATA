Metadata-Version: 2.4
Name: observavility-completed
Version: 0.3.1
Summary: Librer칤a compartida de logger y tracing para microservicios con async
Author-email: daniveloper <elmerhackxcrack@gmail.com>
License: MIT
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: structlog<26.0.0,>=23.0.0
Requires-Dist: opentelemetry-distro
Requires-Dist: opentelemetry-exporter-otlp
Requires-Dist: opentelemetry-instrumentation-fastapi
Requires-Dist: opentelemetry-instrumentation-sqlalchemy
Requires-Dist: opentelemetry-instrumentation-requests
Requires-Dist: opentelemetry-instrumentation-httpx

Trazabilidad Distribuida
Prop칩sito: Configura OpenTelemetry para rastrear requests a trav칠s de m칰ltiples servicios.
Funcionalidades:

- Instrumentaci칩n autom치tica de FastAPI, SQLAlchemy, requests HTTP y httpx
  Exportaci칩n de trazas a un sistema de observabilidad (Tempo por defecto)
  Configuraci칩n centralizada que solo se ejecuta una vez por proceso (usando @lru_cache)
  Identificaci칩n de servicios mediante variables de entorno o par치metros

游땺 Dormir bien sabiendo que:

Si algo se rompe, lo encontrar치s r치pido
Tus decisiones est치n basadas en datos, no en intuici칩n
Tu c칩digo es profesional y mantenible
Tu equipo te ve como el/la ninja de debugging

Qu칠 rastrea:

Requests HTTP entrantes y salientes
Consultas a base de datos
Operaciones entre microservicios

logger.py - Logging Estructurado
Prop칩sito: Proporciona logs estructurados en formato JSON con correlaci칩n de trazas.
Funcionalidades:

- Logs en JSON para facilitar an치lisis y b칰squedas
  Correlaci칩n autom치tica con trazas OpenTelemetry (agrega trace_id y span_id)
  Configuraci칩n est치ndar con timestamps ISO, niveles de log y manejo de excepciones
  Cache de loggers para evitar reconfiguraci칩n

- Caso de Uso T칤pico:
  En tu aplicaci칩n FastAPI

from common_utils.tracing import setup_tracing
from common_utils.logger import get_logger

# Configuraci칩n inicial (una sola vez) 游游游游游

setup_tracing(app=app, engine=db_engine)
logger = get_logger()

# En tus endpoints

@app.get("/users/{user_id}")
async def get_user(user_id: int):
logger.info("Fetching user", user_id=user_id) # Las consultas SQL y requests HTTP se rastrean autom치ticamente
user = await get_user_from_db(user_id)
return user

- Beneficios

Trazabilidad completa: Puedes seguir una request desde el frontend hasta todas las bases de datos y servicios externos
Logs correlacionados: Cada log tiene el trace_id para encontrar todos los logs relacionados con una operaci칩n
Configuraci칩n centralizada: Un solo lugar para configurar observabilidad en todos tus microservicios
An치lisis f치cil: Logs en JSON permiten queries complejas en sistemas como ELK Stack

Es especialmente 칰til para arquitecturas de microservicios donde necesitas entender el flujo completo de las operaciones distribuidas.

Ejemplo en la vida real:
Cliente: "El checkout fall칩 a las 3:47 PM"
T칰: _revisa 47 logs de 12 servicios diferentes_
"쮼ra el user-service? 쯣ayments-service? 쯜nventory-service?"
3 horas despu칠s...\_

con observavility-completed:

Cliente: "El checkout fall칩 a las 3:47 PM"
T칰: busca por trace_id
"Ah, veo que el inventory-service tard칩 30 segundos en responder porque la DB estaba bloqueada"
5 minutos despu칠s: problema resuelto\_
