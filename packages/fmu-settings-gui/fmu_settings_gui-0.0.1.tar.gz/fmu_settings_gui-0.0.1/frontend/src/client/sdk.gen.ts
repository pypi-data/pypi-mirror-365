// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-axios';
import type { V1DeleteProjectSessionData, V1DeleteProjectSessionResponse, V1DeleteProjectSessionError, V1GetProjectData, V1GetProjectResponse, V1GetProjectError, V1PostProjectData, V1PostProjectResponse, V1PostProjectError, V1InitProjectData, V1InitProjectResponse, V1InitProjectError, V1GetUserData, V1GetUserResponse, V1GetUserError, V1PatchApiKeyData, V1PatchApiKeyResponse, V1PatchApiKeyError, V1CreateSessionData, V1CreateSessionResponse, V1CreateSessionError, V1PatchAccessTokenData, V1PatchAccessTokenResponse, V1PatchAccessTokenError, V1GetCheckData, V1GetCheckResponse, V1GetCheckError, V1V1HealthCheckData, V1V1HealthCheckResponse, V1V1HealthCheckError, AppHealthCheckData, AppHealthCheckResponse } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Removes a project .fmu directory from a session
 * This route simply removes an opened project .fmu directory from a session. It does not affect the user other aside from that.
 */
export const v1DeleteProjectSession = <ThrowOnError extends boolean = false>(options?: Options<V1DeleteProjectSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<V1DeleteProjectSessionResponse, V1DeleteProjectSessionError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the paths and configuration of the nearest project .fmu directory
 * If a project is not already attached to the session id it will be attached after a call to this route. If one is already attached this route will return data for the project .fmu directory again.
 */
export const v1GetProject = <ThrowOnError extends boolean = false>(options?: Options<V1GetProjectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<V1GetProjectResponse, V1GetProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options
    });
};

/**
 * Returns the path and configuration of the project .fmu directory at 'path'
 * Used for when a user selects a project .fmu directory in a directory not found above the user's current working directory. Will overwrite the project .fmu directory attached to a session if one exists. If not, it is added to the session.
 */
export const v1PostProject = <ThrowOnError extends boolean = false>(options: Options<V1PostProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<V1PostProjectResponse, V1PostProjectError, ThrowOnError>({
        url: '/api/v1/project/',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Initializes a project .fmu directory at 'path' and returns its paths and configuration
 * If a project .fmu directory is already attached to the session, this will switch to use the newly created .fmu directory.
 */
export const v1InitProject = <ThrowOnError extends boolean = false>(options: Options<V1InitProjectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<V1InitProjectResponse, V1InitProjectError, ThrowOnError>({
        url: '/api/v1/project/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Returns the user .fmu configuration
 * The user configuration can store API subscription keys or tokens. These are obfuscated as '**********' when returned.
 */
export const v1GetUser = <ThrowOnError extends boolean = false>(options?: Options<V1GetUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<V1GetUserResponse, V1GetUserError, ThrowOnError>({
        url: '/api/v1/user/',
        ...options
    });
};

/**
 * Saves an API key/token to the user .fmu configuration
 * Currently only known API's can be saved to the user .fmu configuration. Arbitrary API key-value pairs cannot be saved. The currently known APIs are:
 *
 * smda_subscription
 */
export const v1PatchApiKey = <ThrowOnError extends boolean = false>(options: Options<V1PatchApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<V1PatchApiKeyResponse, V1PatchApiKeyError, ThrowOnError>({
        url: '/api/v1/user/api_key',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Creates a session for the user
 * When creating a session the application will ensure that the user .fmu directory exists by creating it if it does not. It will also check for the nearest project .fmu directory above the current working directory, and if one exists, add it to the session. If it does not exist its value will be `null`.
 * If a session already exists when POSTing to this route, the existing session will be silently destroyed. This will remove any state for a project .fmu that may be opened.
 * The session cookie set by this route is required for all other routes. Sessions are not persisted when the API is shut down.
 */
export const v1CreateSession = <ThrowOnError extends boolean = false>(options?: Options<V1CreateSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<V1CreateSessionResponse, V1CreateSessionError, ThrowOnError>({
        security: [
            {
                name: 'x-fmu-settings-api',
                type: 'apiKey'
            }
        ],
        url: '/api/v1/session/',
        ...options
    });
};

/**
 * Adds a known access token to the session
 * This route should be used to add a scoped access token to the current session. The token applied via this route is typically a depndency for other routes.
 */
export const v1PatchAccessToken = <ThrowOnError extends boolean = false>(options: Options<V1PatchAccessTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<V1PatchAccessTokenResponse, V1PatchAccessTokenError, ThrowOnError>({
        url: '/api/v1/session/access_token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Checks whether or not the current session is capable of querying SMDA
 * A route to check whether the client is capable of querying SMDA APIs
 * with their current session. The requirements for querying the SMDA API via
 * this API are:
 *
 * 1. A valid session
 * 2. An SMDA subscription key in the user's .fmu API key configuration
 * 3. A valid SMDA access token scoped to SMDA's user_impersonation scope
 *
 * A successful response from this route indicates that all other routes on the
 * SMDA router can be used.
 */
export const v1GetCheck = <ThrowOnError extends boolean = false>(options?: Options<V1GetCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<V1GetCheckResponse, V1GetCheckError, ThrowOnError>({
        url: '/api/v1/smda/check',
        ...options
    });
};

/**
 * A health check on the /v1 routes.
 * This route requires a valid session to return 200 OK. it can used to check if the user has a valid session.
 */
export const v1V1HealthCheck = <ThrowOnError extends boolean = false>(options?: Options<V1V1HealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<V1V1HealthCheckResponse, V1V1HealthCheckError, ThrowOnError>({
        url: '/api/v1/health',
        ...options
    });
};

/**
 * A health check on the application
 * This route requires no form of authentication or authorization. It can be used to check if the application is running and responsive.
 */
export const appHealthCheck = <ThrowOnError extends boolean = false>(options?: Options<AppHealthCheckData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<AppHealthCheckResponse, unknown, ThrowOnError>({
        url: '/health',
        ...options
    });
};