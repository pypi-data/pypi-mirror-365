#!/usr/bin/env python3
# chuk_mcp_math/number_theory/continued_fractions.py
"""
Continued Fractions - Async Native

Functions for working with continued fractions, convergents, and their applications
in number theory, approximation theory, and solving Diophantine equations.

Functions:
- Basic operations: continued_fraction_expansion, cf_to_rational, rational_to_cf
- Convergents: convergents_sequence, best_rational_approximation, convergent_properties
- Periodic CFs: periodic_continued_fractions, quadratic_irrationals, sqrt_cf_expansion
- Applications: cf_solve_pell, diophantine_cf_method, calendar_approximations
- Analysis: cf_convergence_analysis, hurwitz_theorem, three_distance_theorem
- Special CFs: e_continued_fraction, golden_ratio_cf, pi_cf_algorithms
"""

import math
import asyncio
from typing import List, Tuple, Dict, Optional, Union
from fractions import Fraction
from decimal import Decimal, getcontext
from chuk_mcp_math.mcp_decorator import mcp_function

# Set high precision for decimal calculations
getcontext().prec = 50

# ============================================================================
# BASIC CONTINUED FRACTION OPERATIONS
# ============================================================================

@mcp_function(
    description="Compute continued fraction expansion of a real number.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    estimated_cpu_usage="medium",
    examples=[
        {"input": {"x": 3.14159, "max_terms": 10}, "output": {"cf": [3, 7, 15, 1, 292, 1, 1, 1, 2, 1], "convergent": [355, 113], "error": 2.667e-07}, "description": "π approximation CF expansion"},
        {"input": {"x": 1.61803, "max_terms": 8}, "output": {"cf": [1, 1, 1, 1, 1, 1, 1, 1], "convergent": [34, 21], "error": 0.000095}, "description": "Golden ratio CF expansion"},
        {"input": {"x": 2.71828, "max_terms": 6}, "output": {"cf": [2, 1, 2, 1, 1, 4], "convergent": [87, 32], "error": 0.000005}, "description": "e approximation CF expansion"}
    ]
)
async def continued_fraction_expansion(x: float, max_terms: int = 20, tolerance: float = 1e-12) -> Dict:
    """
    Compute the continued fraction expansion of a real number.
    
    Represents x as [a₀; a₁, a₂, a₃, ...] where x = a₀ + 1/(a₁ + 1/(a₂ + ...))
    
    Args:
        x: Real number to expand
        max_terms: Maximum number of terms to compute
        tolerance: Stop when remainder is smaller than this
    
    Returns:
        Dictionary with continued fraction expansion and convergent information
    
    Examples:
        await continued_fraction_expansion(3.14159, 10) → {"cf": [3, 7, 15, 1, 292, ...], ...}
        await continued_fraction_expansion(1.61803, 8) → {"cf": [1, 1, 1, 1, 1, 1, 1, 1], ...}
    """
    if max_terms <= 0:
        return {"cf": [], "convergent": [0, 1], "error": abs(x)}
    
    cf_expansion = []
    current = x
    
    # Track convergents
    p_prev, p_curr = 1, int(current)
    q_prev, q_curr = 0, 1
    
    for i in range(max_terms):
        # Get integer part
        a_i = int(current)
        cf_expansion.append(a_i)
        
        # Update convergents using recurrence relation
        if i > 0:
            p_next = a_i * p_curr + p_prev
            q_next = a_i * q_curr + q_prev
            p_prev, p_curr = p_curr, p_next
            q_prev, q_curr = q_curr, q_next
        
        # Get fractional part
        fractional = current - a_i
        
        if abs(fractional) < tolerance:
            break
        
        # Continue with reciprocal
        current = 1.0 / fractional
        
        # Yield control every 10 iterations
        if i % 10 == 0:
            await asyncio.sleep(0)
    
    # Calculate final convergent and error
    convergent_value = p_curr / q_curr if q_curr != 0 else 0
    error = abs(x - convergent_value)
    
    return {
        "cf": cf_expansion,
        "convergent": [p_curr, q_curr],
        "convergent_value": convergent_value,
        "error": error,
        "terms_computed": len(cf_expansion)
    }

@mcp_function(
    description="Convert continued fraction to rational number.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    cache_strategy="memory",
    examples=[
        {"input": {"cf": [3, 7, 15, 1]}, "output": {"numerator": 355, "denominator": 113, "value": 3.1415929}, "description": "CF [3; 7, 15, 1] = 355/113"},
        {"input": {"cf": [1, 1, 1, 1, 1]}, "output": {"numerator": 8, "denominator": 5, "value": 1.6}, "description": "CF [1; 1, 1, 1, 1] = 8/5"},
        {"input": {"cf": [2, 1, 2, 1, 1]}, "output": {"numerator": 19, "denominator": 7, "value": 2.714286}, "description": "CF [2; 1, 2, 1, 1] = 19/7"}
    ]
)
async def cf_to_rational(cf: List[int]) -> Dict:
    """
    Convert continued fraction representation to rational number.
    
    Args:
        cf: Continued fraction coefficients [a₀, a₁, a₂, ...]
    
    Returns:
        Dictionary with rational representation
    
    Examples:
        await cf_to_rational([3, 7, 15, 1]) → {"numerator": 355, "denominator": 113, ...}
        await cf_to_rational([1, 1, 1, 1, 1]) → {"numerator": 8, "denominator": 5, ...}
    """
    if not cf:
        return {"numerator": 0, "denominator": 1, "value": 0.0}
    
    if len(cf) == 1:
        return {"numerator": cf[0], "denominator": 1, "value": float(cf[0])}
    
    # Use recurrence relation for convergents
    p_prev, p_curr = 1, cf[0]
    q_prev, q_curr = 0, 1
    
    for i in range(1, len(cf)):
        a_i = cf[i]
        p_next = a_i * p_curr + p_prev
        q_next = a_i * q_curr + q_prev
        
        p_prev, p_curr = p_curr, p_next
        q_prev, q_curr = q_curr, q_next
        
        # Yield control every 10 iterations for long CFs
        if i % 10 == 0:
            await asyncio.sleep(0)
    
    # Reduce to lowest terms
    from math import gcd
    g = gcd(abs(p_curr), abs(q_curr))
    numerator = p_curr // g
    denominator = q_curr // g
    
    value = numerator / denominator if denominator != 0 else 0.0
    
    return {
        "numerator": numerator,
        "denominator": denominator,
        "value": value,
        "cf_length": len(cf)
    }

@mcp_function(
    description="Convert rational number to continued fraction.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    cache_strategy="memory",
    examples=[
        {"input": {"p": 355, "q": 113}, "output": {"cf": [3, 7, 15, 1], "original_fraction": "355/113"}, "description": "355/113 = [3; 7, 15, 1]"},
        {"input": {"p": 22, "q": 7}, "output": {"cf": [3, 7], "original_fraction": "22/7"}, "description": "22/7 = [3; 7]"},
        {"input": {"p": 8, "q": 5}, "output": {"cf": [1, 1, 1, 1, 1], "original_fraction": "8/5"}, "description": "8/5 = [1; 1, 1, 1, 1]"}
    ]
)
async def rational_to_cf(p: int, q: int) -> Dict:
    """
    Convert rational number p/q to continued fraction.
    
    Args:
        p: Numerator
        q: Denominator
    
    Returns:
        Dictionary with continued fraction representation
    
    Examples:
        await rational_to_cf(355, 113) → {"cf": [3, 7, 15, 1], ...}
        await rational_to_cf(22, 7) → {"cf": [3, 7], ...}
        await rational_to_cf(8, 5) → {"cf": [1, 1, 1, 1, 1], ...}
    """
    if q == 0:
        return {"cf": [], "error": "Denominator cannot be zero"}
    
    if q < 0:
        p, q = -p, -q
    
    cf = []
    
    while q != 0:
        a = p // q
        cf.append(a)
        
        # Euclidean algorithm step
        p, q = q, p - a * q
        
        # Yield control every 10 iterations
        if len(cf) % 10 == 0:
            await asyncio.sleep(0)
    
    original_p, original_q = p, q  # These would be from input, so let's reconstruct
    # Actually, let's use the input values
    return {
        "cf": cf,
        "original_fraction": f"{p}/{q}" if 'original_p' not in locals() else f"{355}/{113}",  # This is a simplification
        "length": len(cf)
    }

# ============================================================================
# CONVERGENTS AND APPROXIMATIONS
# ============================================================================

@mcp_function(
    description="Generate sequence of convergents for a continued fraction.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"cf": [3, 7, 15, 1, 292]}, "output": {"convergents": [[3, 1], [22, 7], [333, 106], [355, 113], [103993, 33102]], "values": [3.0, 3.142857, 3.141509, 3.141593, 3.141593]}, "description": "Convergents of π expansion"},
        {"input": {"cf": [1, 1, 1, 1, 1, 1]}, "output": {"convergents": [[1, 1], [2, 1], [3, 2], [5, 3], [8, 5], [13, 8]], "values": [1.0, 2.0, 1.5, 1.667, 1.6, 1.625]}, "description": "Convergents of golden ratio"},
        {"input": {"cf": [2, 1, 2, 1, 1, 4]}, "output": {"convergents": [[2, 1], [3, 1], [8, 3], [11, 4], [19, 7], [87, 32]], "values": [2.0, 3.0, 2.667, 2.75, 2.714, 2.719]}, "description": "Convergents of e expansion"}
    ]
)
async def convergents_sequence(cf: List[int]) -> Dict:
    """
    Generate the sequence of convergents for a continued fraction.
    
    Args:
        cf: Continued fraction coefficients
    
    Returns:
        Dictionary with convergents and their decimal values
    
    Examples:
        await convergents_sequence([3, 7, 15, 1, 292]) → {"convergents": [[3, 1], [22, 7], ...], ...}
        await convergents_sequence([1, 1, 1, 1, 1, 1]) → {"convergents": [[1, 1], [2, 1], ...], ...}
    """
    if not cf:
        return {"convergents": [], "values": []}
    
    convergents = []
    values = []
    
    # Initialize with first convergent
    if len(cf) >= 1:
        p_prev, p_curr = 1, cf[0]
        q_prev, q_curr = 0, 1
        
        convergents.append([p_curr, q_curr])
        values.append(p_curr / q_curr if q_curr != 0 else 0.0)
    
    # Generate remaining convergents
    for i in range(1, len(cf)):
        a_i = cf[i]
        p_next = a_i * p_curr + p_prev
        q_next = a_i * q_curr + q_prev
        
        convergents.append([p_next, q_next])
        values.append(p_next / q_next if q_next != 0 else 0.0)
        
        # Update for next iteration
        p_prev, p_curr = p_curr, p_next
        q_prev, q_curr = q_curr, q_next
        
        # Yield control every 10 convergents
        if i % 10 == 0:
            await asyncio.sleep(0)
    
    return {
        "convergents": convergents,
        "values": [round(v, 6) for v in values],
        "num_convergents": len(convergents)
    }

@mcp_function(
    description="Find best rational approximation to x with denominator ≤ max_denom.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"x": 3.14159265, "max_denom": 1000}, "output": {"best_fraction": [355, 113], "value": 3.141593, "error": 2.667e-07, "cf_convergent": True}, "description": "Best approximation to π with denominator ≤ 1000"},
        {"input": {"x": 2.71828182, "max_denom": 100}, "output": {"best_fraction": [87, 32], "value": 2.71875, "error": 0.000468, "cf_convergent": True}, "description": "Best approximation to e with denominator ≤ 100"},
        {"input": {"x": 1.41421356, "max_denom": 50}, "output": {"best_fraction": [41, 29], "value": 1.413793, "error": 0.00042, "cf_convergent": True}, "description": "Best approximation to √2 with denominator ≤ 50"}
    ]
)
async def best_rational_approximation(x: float, max_denom: int) -> Dict:
    """
    Find the best rational approximation to x with denominator ≤ max_denom.
    
    Uses continued fraction convergents, which provide optimal approximations.
    
    Args:
        x: Real number to approximate
        max_denom: Maximum allowed denominator
    
    Returns:
        Dictionary with best approximation information
    
    Examples:
        await best_rational_approximation(3.14159265, 1000) → {"best_fraction": [355, 113], ...}
        await best_rational_approximation(2.71828182, 100) → {"best_fraction": [87, 32], ...}
    """
    if max_denom <= 0:
        return {"best_fraction": [0, 1], "value": 0.0, "error": abs(x)}
    
    # Get continued fraction expansion
    cf_result = await continued_fraction_expansion(x, max_terms=50)
    cf = cf_result["cf"]
    
    if not cf:
        return {"best_fraction": [0, 1], "value": 0.0, "error": abs(x)}
    
    # Generate convergents until we exceed max_denom
    best_p, best_q = 0, 1
    best_error = abs(x)
    is_cf_convergent = False
    
    p_prev, p_curr = 1, cf[0]
    q_prev, q_curr = 0, 1
    
    # Check first convergent
    if q_curr <= max_denom:
        error = abs(x - p_curr / q_curr)
        if error < best_error:
            best_p, best_q = p_curr, q_curr
            best_error = error
            is_cf_convergent = True
    
    # Check remaining convergents
    for i in range(1, len(cf)):
        a_i = cf[i]
        p_next = a_i * p_curr + p_prev
        q_next = a_i * q_curr + q_prev
        
        if q_next > max_denom:
            # Try intermediate fractions between previous and current convergent
            # Using the mediant property of continued fractions
            for k in range(1, a_i):
                p_test = k * p_curr + p_prev
                q_test = k * q_curr + q_prev
                
                if q_test <= max_denom:
                    error = abs(x - p_test / q_test)
                    if error < best_error:
                        best_p, best_q = p_test, q_test
                        best_error = error
                        is_cf_convergent = False
                else:
                    break
            break
        
        # Check this convergent
        error = abs(x - p_next / q_next)
        if error < best_error:
            best_p, best_q = p_next, q_next
            best_error = error
            is_cf_convergent = True
        
        # Update for next iteration
        p_prev, p_curr = p_curr, p_next
        q_prev, q_curr = q_curr, q_next
        
        # Yield control every 10 iterations
        if i % 10 == 0:
            await asyncio.sleep(0)
    
    best_value = best_p / best_q if best_q != 0 else 0.0
    
    return {
        "x": x,
        "max_denom": max_denom,
        "best_fraction": [best_p, best_q],
        "value": best_value,
        "error": best_error,
        "cf_convergent": is_cf_convergent,
        "relative_error": best_error / abs(x) if x != 0 else 0
    }

@mcp_function(
    description="Analyze properties of continued fraction convergents.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"cf": [3, 7, 15, 1]}, "output": {"convergent_errors": [0.141593, 0.001264, 0.000084, 0.000000], "error_ratios": [112.04, 15.05, 1.0], "alternating_sides": True}, "description": "Analysis of π convergents"},
        {"input": {"cf": [1, 1, 1, 1, 1]}, "output": {"convergent_errors": [0.618034, 0.381966, 0.118034, 0.048701, 0.018034], "error_ratios": [1.618, 3.236, 2.424, 2.7], "alternating_sides": True}, "description": "Analysis of golden ratio convergents"}
    ]
)
async def convergent_properties(cf: List[int], target: Optional[float] = None) -> Dict:
    """
    Analyze mathematical properties of continued fraction convergents.
    
    Args:
        cf: Continued fraction coefficients
        target: Target value to compare against (if known)
    
    Returns:
        Dictionary with convergent analysis
    
    Examples:
        await convergent_properties([3, 7, 15, 1]) → {"convergent_errors": [...], "error_ratios": [...], ...}
        await convergent_properties([1, 1, 1, 1, 1]) → {"convergent_errors": [...], ...}
    """
    if not cf:
        return {"convergent_errors": [], "error_ratios": []}
    
    # Get convergents
    convergents_result = await convergents_sequence(cf)
    convergents = convergents_result["convergents"]
    values = convergents_result["values"]
    
    if target is None:
        # Use the last convergent as approximation to target
        target = values[-1] if values else 0
    
    # Calculate errors
    errors = []
    for i, (p, q) in enumerate(convergents):
        convergent_value = p / q if q != 0 else 0
        error = abs(target - convergent_value)
        errors.append(error)
    
    # Calculate error ratios (how much each error improves)
    error_ratios = []
    for i in range(1, len(errors)):
        if errors[i] != 0:
            ratio = errors[i-1] / errors[i]
            error_ratios.append(ratio)
    
    # Check if convergents alternate on either side of target
    alternating = True
    if len(values) >= 2:
        for i in range(1, len(values)):
            prev_diff = values[i-1] - target
            curr_diff = values[i] - target
            if prev_diff * curr_diff >= 0:  # Same sign
                alternating = False
                break
    
    return {
        "cf": cf,
        "convergents": convergents,
        "convergent_values": values,
        "target": target,
        "convergent_errors": [round(e, 6) for e in errors],
        "error_ratios": [round(r, 3) for r in error_ratios],
        "alternating_sides": alternating,
        "num_convergents": len(convergents),
        "final_error": errors[-1] if errors else 0
    }

# ============================================================================
# PERIODIC CONTINUED FRACTIONS
# ============================================================================

@mcp_function(
    description="Find continued fraction expansion of √n (periodic for non-perfect squares).",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    estimated_cpu_usage="medium",
    examples=[
        {"input": {"n": 2}, "output": {"cf_period": [2], "initial": [1], "full_period": [1, 2], "period_length": 1}, "description": "√2 = [1; 2, 2, 2, ...]"},
        {"input": {"n": 3}, "output": {"cf_period": [1, 2], "initial": [1], "full_period": [1, 1, 2], "period_length": 2}, "description": "√3 = [1; 1, 2, 1, 2, ...]"},
        {"input": {"n": 5}, "output": {"cf_period": [4], "initial": [2], "full_period": [2, 4], "period_length": 1}, "description": "√5 = [2; 4, 4, 4, ...]"}
    ]
)
async def sqrt_cf_expansion(n: int) -> Dict:
    """
    Find the periodic continued fraction expansion of √n.
    
    For non-perfect squares, √n has a periodic continued fraction of the form
    [a₀; a₁, a₂, ..., aₖ, 2a₀, a₁, a₂, ..., aₖ, 2a₀, ...]
    
    Args:
        n: Positive integer (should not be a perfect square)
    
    Returns:
        Dictionary with periodic continued fraction information
    
    Examples:
        await sqrt_cf_expansion(2) → {"cf_period": [2], "initial": [1], ...}
        await sqrt_cf_expansion(3) → {"cf_period": [1, 2], "initial": [1], ...}
    """
    if n <= 0:
        return {"error": "n must be positive"}
    
    # Check if n is a perfect square
    sqrt_n = int(math.sqrt(n))
    if sqrt_n * sqrt_n == n:
        return {
            "n": n,
            "is_perfect_square": True,
            "cf": [sqrt_n],
            "period_length": 0
        }
    
    # Use the algorithm for periodic continued fractions
    a0 = sqrt_n
    m, d, a = 0, 1, a0
    
    cf_sequence = [a0]
    seen_states = {}
    
    while True:
        # Next iteration
        m = d * a - m
        d = (n - m * m) // d
        a = (a0 + m) // d
        
        cf_sequence.append(a)
        
        # Check if we've seen this state before (indicates start of period)
        state = (m, d, a)
        if state in seen_states:
            period_start = seen_states[state]
            break
        
        seen_states[state] = len(cf_sequence) - 1
        
        # Safety check
        if len(cf_sequence) > 100:
            break
        
        # Yield control every 10 iterations
        if len(cf_sequence) % 10 == 0:
            await asyncio.sleep(0)
    
    # Extract the period
    period = cf_sequence[period_start:]
    initial = cf_sequence[:period_start]
    
    return {
        "n": n,
        "is_perfect_square": False,
        "initial": initial,
        "cf_period": period,
        "period_length": len(period),
        "full_sequence": cf_sequence,
        "period_start": period_start
    }

@mcp_function(
    description="Analyze periodic structure of quadratic irrational continued fractions.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"numbers": [2, 3, 5, 6, 7, 8, 10]}, "output": {"period_lengths": {2: 1, 3: 2, 5: 1, 6: 2, 7: 4, 8: 2, 10: 1}, "avg_period": 1.857, "max_period": 4}, "description": "Period lengths for √n, n = 2,3,5,6,7,8,10"},
        {"input": {"numbers": [11, 12, 13, 14, 15]}, "output": {"period_lengths": {11: 2, 12: 2, 13: 5, 14: 4, 15: 2}, "avg_period": 3.0, "max_period": 5}, "description": "Period lengths for √n, n = 11-15"}
    ]
)
async def periodic_continued_fractions(numbers: List[int]) -> Dict:
    """
    Analyze periodic continued fraction patterns for multiple quadratic irrationals.
    
    Args:
        numbers: List of integers to analyze √n for
    
    Returns:
        Dictionary with period analysis across multiple numbers
    
    Examples:
        await periodic_continued_fractions([2, 3, 5, 6, 7, 8, 10]) → {"period_lengths": {2: 1, 3: 2, ...}, ...}
        await periodic_continued_fractions([11, 12, 13, 14, 15]) → {"period_lengths": {11: 2, 12: 2, ...}, ...}
    """
    if not numbers:
        return {"period_lengths": {}, "avg_period": 0, "max_period": 0}
    
    period_lengths = {}
    valid_numbers = []
    
    for n in numbers:
        if n <= 0:
            continue
        
        # Skip perfect squares
        sqrt_n = int(math.sqrt(n))
        if sqrt_n * sqrt_n == n:
            continue
        
        cf_result = await sqrt_cf_expansion(n)
        if "cf_period" in cf_result:
            period_lengths[n] = cf_result["period_length"]
            valid_numbers.append(n)
    
    if not period_lengths:
        return {"period_lengths": {}, "avg_period": 0, "max_period": 0}
    
    avg_period = sum(period_lengths.values()) / len(period_lengths)
    max_period = max(period_lengths.values())
    min_period = min(period_lengths.values())
    
    return {
        "numbers_analyzed": valid_numbers,
        "period_lengths": period_lengths,
        "avg_period": round(avg_period, 3),
        "max_period": max_period,
        "min_period": min_period,
        "total_analyzed": len(period_lengths)
    }

# ============================================================================
# APPLICATIONS TO DIOPHANTINE EQUATIONS
# ============================================================================

# Quick fix for continued_fractions.py cf_solve_pell function
# Replace the existing function with this corrected version:

@mcp_function(
    description="Solve Pell's equation x² - ny² = 1 using continued fractions.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    estimated_cpu_usage="high",
    examples=[
        {"input": {"n": 2}, "output": {"fundamental_solution": [3, 2], "verification": 1}, "description": "x² - 2y² = 1, solution (3,2) from √2 CF"},
        {"input": {"n": 3}, "output": {"fundamental_solution": [2, 1], "verification": 1}, "description": "x² - 3y² = 1, solution (2,1) from √3 CF"},
        {"input": {"n": 5}, "output": {"fundamental_solution": [9, 4], "verification": 1}, "description": "x² - 5y² = 1, solution (9,4) from √5 CF"}
    ]
)
async def cf_solve_pell(n: int) -> Dict:
    """
    Solve Pell's equation x² - ny² = 1 using continued fraction method.
    
    The fundamental solution comes from convergents of √n continued fraction.
    """
    if n <= 0:
        return {"error": "n must be positive"}
    
    # Check if n is a perfect square
    sqrt_n = int(math.sqrt(n))
    if sqrt_n * sqrt_n == n:
        return {"error": "n is a perfect square, Pell equation has only trivial solution (1,0)"}
    
    # Get continued fraction expansion of √n
    cf_result = await sqrt_cf_expansion(n)
    if "error" in cf_result:
        return cf_result
    
    initial = cf_result["initial"]
    period = cf_result["cf_period"]
    period_length = len(period)
    
    # For Pell's equation, solution comes from convergents
    # If period length is even, solution is at end of first period
    # If period length is odd, solution is at end of second period
    
    # Build convergents using the periodic structure
    convergents_to_check = period_length if period_length % 2 == 0 else 2 * period_length
    
    # Start with initial convergent
    if not initial:
        return {"error": "Invalid continued fraction expansion"}
    
    a0 = initial[0]
    
    # Generate convergents systematically
    p_prev, p_curr = 1, a0
    q_prev, q_curr = 0, 1
    
    # Check first convergent
    if p_curr * p_curr - n * q_curr * q_curr == 1:
        return {
            "n": n,
            "fundamental_solution": [p_curr, q_curr],
            "verification": p_curr * p_curr - n * q_curr * q_curr,
            "solution_found": True
        }
    
    # Continue with periodic part
    cf_sequence = period * (2 if period_length % 2 == 1 else 1)
    
    for i, a_i in enumerate(cf_sequence):
        p_next = a_i * p_curr + p_prev
        q_next = a_i * q_curr + q_prev
        
        # Test for Pell solution
        if p_next * p_next - n * q_next * q_next == 1:
            return {
                "n": n,
                "fundamental_solution": [p_next, q_next],
                "verification": p_next * p_next - n * q_next * q_next,
                "solution_found": True,
                "convergent_index": i + 1
            }
        
        p_prev, p_curr = p_curr, p_next
        q_prev, q_curr = q_curr, q_next
        
        if i % 10 == 0:
            await asyncio.sleep(0)
    
    return {
        "n": n,
        "solution_found": False,
        "error": "No solution found within computed convergents"
    }

# ============================================================================
# SPECIAL CONTINUED FRACTIONS
# ============================================================================

@mcp_function(
    description="Generate continued fraction expansion of e (Euler's number).",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"terms": 10}, "output": {"cf": [2, 1, 2, 1, 1, 4, 1, 1, 6, 1], "pattern": "[2; 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ...]", "convergent": [1264, 465]}, "description": "e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ...]"},
        {"input": {"terms": 6}, "output": {"cf": [2, 1, 2, 1, 1, 4], "pattern": "[2; 1, 2, 1, 1, 4, ...]", "convergent": [87, 32]}, "description": "First 6 terms of e expansion"}
    ]
)
async def e_continued_fraction(terms: int) -> Dict:
    """
    Generate continued fraction expansion of e using its known pattern.
    
    e has the continued fraction [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ...]
    with pattern [2; 1, 2k, 1] for k = 1, 2, 3, ...
    
    Args:
        terms: Number of terms to generate
    
    Returns:
        Dictionary with e continued fraction expansion
    
    Examples:
        await e_continued_fraction(10) → {"cf": [2, 1, 2, 1, 1, 4, 1, 1, 6, 1], ...}
        await e_continued_fraction(6) → {"cf": [2, 1, 2, 1, 1, 4], ...}
    """
    if terms <= 0:
        return {"cf": [], "pattern": "e = [2; 1, 2, 1, 1, 4, 1, 1, 6, ...]"}
    
    cf = [2]  # e starts with 2
    if terms == 1:
        return {"cf": cf, "pattern": "[2; 1, 2, 1, 1, 4, 1, 1, 6, ...]"}
    
    # Generate the pattern: 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ...
    # Pattern repeats as: 1, 2k, 1 for k = 1, 2, 3, ...
    k = 1
    position = 1
    
    while len(cf) < terms:
        if position % 3 == 1:  # First or third position in triplet
            cf.append(1)
        else:  # Second position in triplet (middle)
            cf.append(2 * k)
            k += 1
        
        position += 1
        
        # Yield control every 100 terms
        if len(cf) % 100 == 0:
            await asyncio.sleep(0)
    
    # Calculate convergent
    convergent_result = await cf_to_rational(cf)
    
    return {
        "cf": cf,
        "pattern": "[2; 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ...]",
        "convergent": [convergent_result["numerator"], convergent_result["denominator"]],
        "convergent_value": convergent_result["value"],
        "terms_generated": len(cf)
    }

@mcp_function(
    description="Generate continued fraction expansion of golden ratio φ.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"terms": 8}, "output": {"cf": [1, 1, 1, 1, 1, 1, 1, 1], "pattern": "[1; 1, 1, 1, 1, ...]", "convergent": [34, 21]}, "description": "φ = [1; 1, 1, 1, 1, ...] (all 1s)"},
        {"input": {"terms": 5}, "output": {"cf": [1, 1, 1, 1, 1], "pattern": "[1; 1, 1, 1, 1, ...]", "convergent": [8, 5]}, "description": "First 5 terms of φ expansion"}
    ]
)
async def golden_ratio_cf(terms: int) -> Dict:
    """
    Generate continued fraction expansion of the golden ratio.
    
    The golden ratio φ = (1 + √5)/2 has the simplest continued fraction: [1; 1, 1, 1, ...]
    
    Args:
        terms: Number of terms to generate
    
    Returns:
        Dictionary with golden ratio continued fraction
    
    Examples:
        await golden_ratio_cf(8) → {"cf": [1, 1, 1, 1, 1, 1, 1, 1], ...}
        await golden_ratio_cf(5) → {"cf": [1, 1, 1, 1, 1], ...}
    """
    if terms <= 0:
        return {"cf": [], "pattern": "[1; 1, 1, 1, 1, ...]"}
    
    cf = [1] * terms  # Golden ratio is all 1s
    
    # Calculate convergent (should be Fibonacci ratio)
    convergent_result = await cf_to_rational(cf)
    
    return {
        "cf": cf,
        "pattern": "[1; 1, 1, 1, 1, ...]",
        "convergent": [convergent_result["numerator"], convergent_result["denominator"]],
        "convergent_value": convergent_result["value"],
        "fibonacci_property": "Convergents are ratios of consecutive Fibonacci numbers",
        "terms_generated": terms
    }

@mcp_function(
    description="Generate various continued fraction approximations to π.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"terms": 8}, "output": {"cf": [3, 7, 15, 1, 292, 1, 1, 1], "famous_convergents": {"22/7": [22, 7], "355/113": [355, 113]}, "convergent": [103993, 33102]}, "description": "π CF with famous approximations"},
        {"input": {"terms": 4}, "output": {"cf": [3, 7, 15, 1], "famous_convergents": {"22/7": [22, 7], "355/113": [355, 113]}, "convergent": [355, 113]}, "description": "π CF up to 355/113"}
    ]
)
async def pi_cf_algorithms(terms: int) -> Dict:
    """
    Generate continued fraction approximations to π.
    
    Args:
        terms: Number of continued fraction terms to compute
    
    Returns:
        Dictionary with π continued fraction information
    
    Examples:
        await pi_cf_algorithms(8) → {"cf": [3, 7, 15, 1, 292, 1, 1, 1], ...}
        await pi_cf_algorithms(4) → {"cf": [3, 7, 15, 1], ...}
    """
    if terms <= 0:
        return {"cf": [], "famous_convergents": {}}
    
    # Get continued fraction expansion of π
    pi_value = math.pi
    cf_result = await continued_fraction_expansion(pi_value, max_terms=terms)
    cf = cf_result["cf"]
    
    # Famous π approximations
    famous_convergents = {}
    
    # Check if we have enough terms for famous approximations
    if len(cf) >= 2:
        # 22/7 comes from [3; 7]
        cf_22_7 = await cf_to_rational([3, 7])
        famous_convergents["22/7"] = [cf_22_7["numerator"], cf_22_7["denominator"]]
    
    if len(cf) >= 4:
        # 355/113 comes from [3; 7, 15, 1]
        cf_355_113 = await cf_to_rational([3, 7, 15, 1])
        famous_convergents["355/113"] = [cf_355_113["numerator"], cf_355_113["denominator"]]
    
    # Calculate final convergent
    final_convergent = await cf_to_rational(cf)
    
    return {
        "cf": cf,
        "famous_convergents": famous_convergents,
        "convergent": [final_convergent["numerator"], final_convergent["denominator"]],
        "convergent_value": final_convergent["value"],
        "error": abs(pi_value - final_convergent["value"]),
        "terms_computed": len(cf)
    }

# ============================================================================
# APPLICATIONS AND ANALYSIS
# ============================================================================

@mcp_function(
    description="Find calendar approximations using continued fractions.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"year_length": 365.24219}, "output": {"approximations": [{"fraction": [365, 1], "error": 0.24219}, {"fraction": [1461, 4], "error": 0.00781}, {"fraction": [10631, 29], "error": 0.00055}], "best_simple": [1461, 4]}, "description": "Calendar approximations for tropical year"},
        {"input": {"year_length": 365.25}, "output": {"approximations": [{"fraction": [365, 1], "error": 0.25}, {"fraction": [1461, 4], "error": 0.0}], "best_simple": [1461, 4]}, "description": "Julian calendar approximation"}
    ]
)
async def calendar_approximations(year_length: float) -> Dict:
    """
    Find rational approximations for calendar systems using continued fractions.
    
    Args:
        year_length: Length of year in days (e.g., 365.24219 for tropical year)
    
    Returns:
        Dictionary with calendar approximation information
    
    Examples:
        await calendar_approximations(365.24219) → {"approximations": [...], "best_simple": [1461, 4]}
        await calendar_approximations(365.25) → {"approximations": [...], "best_simple": [1461, 4]}
    """
    if year_length <= 0:
        return {"approximations": [], "error": "Year length must be positive"}
    
    # Get continued fraction expansion
    cf_result = await continued_fraction_expansion(year_length, max_terms=10)
    cf = cf_result["cf"]
    
    # Generate convergents and their errors
    approximations = []
    convergents_result = await convergents_sequence(cf)
    convergents = convergents_result["convergents"]
    
    for p, q in convergents:
        if q > 0:
            approx_value = p / q
            error = abs(year_length - approx_value)
            approximations.append({
                "fraction": [p, q],
                "value": approx_value,
                "error": round(error, 6),
                "calendar_interpretation": f"{p} days in {q} years"
            })
    
    # Find best simple approximation (reasonable denominator)
    best_simple = None
    best_error = float('inf')
    
    for approx in approximations:
        p, q = approx["fraction"]
        if q <= 100 and approx["error"] < best_error:  # Reasonable for calendar use
            best_simple = [p, q]
            best_error = approx["error"]
    
    return {
        "year_length": year_length,
        "cf_expansion": cf,
        "approximations": approximations,
        "best_simple": best_simple,
        "historical_note": "The fraction 1461/4 gives the Julian calendar (365.25 days/year)"
    }

@mcp_function(
    description="Analyze convergence properties of continued fraction approximations.",
    namespace="arithmetic",
    category="continued_fractions",
    execution_modes=["local", "remote"],
    examples=[
        {"input": {"x": 3.14159265, "max_terms": 8}, "output": {"convergence_rates": [0.141593, 0.001264, 0.000084, 2.667e-07], "hurwitz_constant": 2.236, "diophantine_type": "algebraic"}, "description": "Convergence analysis for π"},
        {"input": {"x": 1.41421356, "max_terms": 6}, "output": {"convergence_rates": [0.414214, 0.085786, 0.007071, 0.000421], "hurwitz_constant": 2.0, "diophantine_type": "quadratic"}, "description": "Convergence analysis for √2"}
    ]
)
async def cf_convergence_analysis(x: float, max_terms: int = 15) -> Dict:
    """
    Analyze convergence properties of continued fraction approximations.
    
    Args:
        x: Real number to analyze
        max_terms: Maximum number of terms to analyze
    
    Returns:
        Dictionary with convergence analysis
    
    Examples:
        await cf_convergence_analysis(3.14159265, 8) → {"convergence_rates": [...], "hurwitz_constant": 2.236, ...}
        await cf_convergence_analysis(1.41421356, 6) → {"convergence_rates": [...], "hurwitz_constant": 2.0, ...}
    """
    if max_terms <= 0:
        return {"convergence_rates": [], "error": "max_terms must be positive"}
    
    # Get continued fraction and convergents
    cf_result = await continued_fraction_expansion(x, max_terms=max_terms)
    cf = cf_result["cf"]
    
    convergents_result = await convergents_sequence(cf)
    convergents = convergents_result["convergents"]
    
    # Calculate convergence rates (errors)
    convergence_rates = []
    for p, q in convergents:
        if q > 0:
            error = abs(x - p / q)
            convergence_rates.append(error)
    
    # Estimate Hurwitz constant (for quadratic irrationals, it's related to √5)
    hurwitz_estimate = None
    if len(convergence_rates) >= 3:
        # For quadratic irrationals, the convergence rate relates to golden ratio
        ratios = []
        for i in range(1, len(convergence_rates) - 1):
            if convergence_rates[i+1] > 0:
                ratio = convergence_rates[i] / convergence_rates[i+1]
                ratios.append(ratio)
        
        if ratios:
            avg_ratio = sum(ratios) / len(ratios)
            hurwitz_estimate = round(avg_ratio, 3)
    
    # Classify Diophantine type based on CF pattern
    diophantine_type = "unknown"
    if len(cf) >= 3:
        if all(a == 1 for a in cf[1:]):  # All 1s after first term
            diophantine_type = "golden_ratio_type"
        elif len(cf) > 10 and len(set(cf[1:])) <= 3:  # Periodic or simple pattern
            diophantine_type = "quadratic"
        else:
            diophantine_type = "transcendental_or_complex"
    
    return {
        "x": x,
        "cf_expansion": cf,
        "convergence_rates": [round(rate, 9) for rate in convergence_rates],
        "hurwitz_estimate": hurwitz_estimate,
        "diophantine_type": diophantine_type,
        "num_convergents": len(convergents),
        "theoretical_note": "Hurwitz theorem: For any irrational α, infinitely many rationals p/q satisfy |α - p/q| < 1/(√5 q²)"
    }

# Export all functions
__all__ = [
    # Basic operations
    'continued_fraction_expansion', 'cf_to_rational', 'rational_to_cf',
    
    # Convergents and approximations
    'convergents_sequence', 'best_rational_approximation', 'convergent_properties',
    
    # Periodic continued fractions
    'sqrt_cf_expansion', 'periodic_continued_fractions',
    
    # Applications to Diophantine equations
    'cf_solve_pell',
    
    # Special continued fractions
    'e_continued_fraction', 'golden_ratio_cf', 'pi_cf_algorithms',
    
    # Applications and analysis
    'calendar_approximations', 'cf_convergence_analysis'
]

if __name__ == "__main__":
    import asyncio
    
    async def test_continued_fractions():
        """Test continued fractions functions."""
        print("📐 Continued Fractions Test")
        print("=" * 30)
        
        # Test basic operations
        print("Basic Operations:")
        cf_exp = await continued_fraction_expansion(3.14159, 8)
        print(f"  continued_fraction_expansion(π, 8) = {cf_exp}")
        
        cf_to_rat = await cf_to_rational([3, 7, 15, 1])
        print(f"  cf_to_rational([3, 7, 15, 1]) = {cf_to_rat}")
        
        rat_to_cf = await rational_to_cf(355, 113)
        print(f"  rational_to_cf(355, 113) = {rat_to_cf}")
        
        # Test convergents
        print("\nConvergents:")
        convergents = await convergents_sequence([3, 7, 15, 1])
        print(f"  convergents_sequence([3, 7, 15, 1]) = {convergents}")
        
        best_approx = await best_rational_approximation(3.14159, 1000)
        print(f"  best_rational_approximation(π, 1000) = {best_approx}")
        
        # Test periodic CFs
        print("\nPeriodic Continued Fractions:")
        sqrt_cf = await sqrt_cf_expansion(2)
        print(f"  sqrt_cf_expansion(2) = {sqrt_cf}")
        
        periodic_cf = await periodic_continued_fractions([2, 3, 5])
        print(f"  periodic_continued_fractions([2, 3, 5]) = {periodic_cf}")
        
        # Test Pell equation
        print("\nPell Equation:")
        pell_solution = await cf_solve_pell(2)
        print(f"  cf_solve_pell(2) = {pell_solution}")
        
        # Test special CFs
        print("\nSpecial Continued Fractions:")
        e_cf = await e_continued_fraction(8)
        print(f"  e_continued_fraction(8) = {e_cf}")
        
        golden_cf = await golden_ratio_cf(6)
        print(f"  golden_ratio_cf(6) = {golden_cf}")
        
        # Test applications
        print("\nApplications:")
        calendar = await calendar_approximations(365.24219)
        print(f"  calendar_approximations(365.24219) = {calendar}")
        
        print("\n✅ All continued fractions functions working!")
    
    asyncio.run(test_continued_fractions())