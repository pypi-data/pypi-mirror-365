import{g as F}from"./index-SKCiK1zC.js";import{H as y,f as P}from"./HTTPFileSystem-BuB8fZgO.js";import{a as C}from"./avro-Dd9UqmeZ.js";import{W as R}from"./RoadNetworkLoader.worker-CZuyU4Ze.js";import{r as L}from"./group-DobYzF2-.js";function p(f){return new Worker("/assets/DataFetcher.worker-CchOMly-.js",{name:f?.name})}function S(f){return new Worker("/assets/WasmXmlNetworkParser.worker-CeCWYvkl.js",{name:f?.name})}const E=!!window.showDirectoryPicker,$=!E;class j{constructor(...t){this.root=t.length?t[0]:"",this.subfolder=t.length?t[1]:"",this.fileApi=this._getFileSystem(this.root)}threads=[];subfolder="";root="";fileApi;networks={};featureCollections={};kill(){for(const t of this.threads)t.terminate()}getFilteredDataset(t){return t.dataset in this.datasets?{filteredRows:this.datasets[t.dataset].filteredRows}:{filteredRows:null}}async OLDgetFiltered(t){const s=this.datasets[t.dataset].filteredRows;if(!s)return{filteredRows:null};let e={};if(t.value&&t.groupBy){const o=t.value,l=t.groupBy;e=L(s,a=>a.reduce((c,r)=>c+r[o],0),a=>a[l])}const n=Array.from(e.keys()),i=Array.from(e.values());return{filteredRows:{x:n,y:i}}}async getDataset(t,s){try{const e=`${s?.subfolder||this.subfolder}/${t.dataset}`;this.datasets[e]||(console.log("LOAD:",e),this.datasets[e]={dataset:this._fetchDataset(t,s),activeFilters:{},filteredRows:null,filterListeners:new Set});let i=await((c,r)=>{const d=new Promise((u,w)=>{setTimeout(()=>{w(new Error(`Operation timed out after ${r}s`))},r*1e3)});return Promise.race([c,d])})(this.datasets[e].dataset,60),{_comments:o,...l}=i,a=o;return t.ignoreColumns&&t.ignoreColumns.forEach(c=>{delete l[c]}),t.useLastRow&&Object.keys(l).forEach(c=>{const r=i[c].values;l[c]=r[r.length-1]}),{allRows:l,comments:a}}catch(e){const n=(""+e).replaceAll("Error: ","");throw console.error(n),Error(n)}}setRowWisePropertyTable(t,s,e){const n=t.substring(t.lastIndexOf("/")+1);let i={dataset:n};return typeof e!="string"&&(i=Object.assign(i,e)),this.datasets[n]={activeFilters:{},filteredRows:null,filterListeners:new Set,dataset:new Promise(o=>{o(s)})},this.datasets[n].dataset}getFeatureCollection(t){return this.featureCollections[t]}async registerFeatures(t,s,e){this.featureCollections[t]=s;const n=s.map(i=>i.properties||{});await this.setFeatureProperties(t,n,e),s.forEach(i=>{i.properties={}})}setFeatureProperties(t,s,e){const n=t.substring(t.lastIndexOf("/")+1),i=`${e?.subfolder||""}/${n}`;let o={dataset:i};return typeof e!="string"&&(o=Object.assign(o,e)),this.datasets[i]={activeFilters:{},filteredRows:null,filterListeners:new Set,dataset:new Promise((l,a)=>{const c=new p;this.threads.push(c);try{c.postMessage({config:o,featureProperties:s}),c.onmessage=r=>{c.terminate(),r.data.error&&(console.error(r.data.error),a(`Problem loading properties in ${t}`)),l(r.data)}}catch(r){c.terminate(),console.error(r),a(r)}})},this.datasets[i].dataset}setPreloadedDataset(t){this.datasets[t.key]={dataset:new Promise((s,e)=>{s(t.dataTable)}),activeFilters:{},filteredRows:null,filterListeners:new Set}}async getRoadNetwork(t,s,e,n,i){const o=`/${s}/${t}`,l={};return e.projection&&(l.crs=e.projection),this.networks[o]||(this.networks[o]=this._fetchNetwork({subfolder:s,filename:t,cbStatus:n,options:l,extra:i})),await this.networks[o]}async setFilter(t){const{dataset:s,column:e,value:n,invert:i,range:o}=t;if(!this.datasets[s]){console.warn(`${s} doesn't exist yet`),console.warn(Object.keys(this.datasets));return}console.log("> setFilter",s,e,n);const l=Array.isArray(n)?n:[n];this.datasets[s].activeFilters==null&&(this.datasets[s].activeFilters={});const a=this.datasets[s].activeFilters;l.length?a[e]={values:l,invert:i,range:o}:delete a[e],await this._updateFilters(s)}addFilterListener(t,s){try{const e=`${t.subfolder||this.subfolder}/${t.dataset}`;if(!this.datasets[e])throw Error("Can't add listener, no dataset named: "+e);this.datasets[e].filterListeners.add(s)}catch(e){console.error("CANT ADD FILTER LISTENER"+e)}}removeFilterListener(t,s){const e=`${t.subfolder||this.subfolder}/${t.dataset}`;try{this.datasets[e].filterListeners&&this.datasets[e].filterListeners.delete(s)}catch{}}clearCache(){this.kill(),this.datasets={},this.networks={}}async _updateFilters(t){console.log("> updateFilters ",t);const s=this.datasets[t];if(console.log({metaData:s}),!Object.keys(s.activeFilters).length){console.log("no keys"),s.filteredRows=null,this._notifyListeners(t);return}const e=await s.dataset,n=Object.keys(e);let i=[];const o=e[n[0]].values.length,l=new Array(o).fill(!0),a=/^(<|>)/;for(const[c,r]of Object.entries(s.activeFilters)){const d=e[c];if(r.values[0]===void 0||r.values[0]==="")throw Error(t+": filter error");if(a.test(r.values[0]))r.values[0].startsWith("<=")?(r.conditional="<=",r.values[0]=r.values[0].substring(2).trim()):r.values[0].startsWith(">=")?(r.conditional=">=",r.values[0]=r.values[0].substring(2).trim()):r.values[0].startsWith("<")?(r.conditional="<",r.values[0]=r.values[0].substring(1).trim()):r.values[0].startsWith(">")&&(r.conditional=">",r.values[0]=r.values[0].substring(1).trim());else if(r.values.length===1&&typeof r.values[0]=="string"){const u=parseFloat(r.values[0]);Number.isFinite(u)&&r.values.push(u)}for(let u=0;u<o;u++)D(r,d.values[u])||(l[u]=!1)}for(let c=0;c<o;c++)if(l[c]){const r={};n.forEach(d=>r[d]=e[d].values[c]),i.push(r)}s.filteredRows=i,this._notifyListeners(t)}_notifyListeners(t){const s=this.datasets[t];for(const e of s.filterListeners)e(t)}async _fetchDataset(t,s){const{files:e}=await new y(this.fileApi).getDirectory(s?.subfolder||this.subfolder);return new Promise((n,i)=>{const o=new p;this.threads.push(o);try{o.postMessage({fileSystemConfig:this.fileApi,subfolder:s?.subfolder||this.subfolder,files:e,config:t,options:s}),o.onmessage=l=>{if(o.terminate(),!l.data||l.data.error){let a=""+(l.data?.error||"Error loading file");a=a.replace("[object Response]","Error loading file"),t?.dataset&&a.indexOf(t.dataset)===-1&&(a+=`: ${t.dataset}`),i(a)}n(l.data)}}catch(l){o.terminate(),console.error(l),i(l)}})}async _getAvroNetwork(t){const e=await new y(this.fileApi).getFileBlob(`${t.subfolder}/${t.filename}`);return(await new Promise(async(o,l)=>{const a=[];C.createBlobDecoder(e).on("metadata",c=>{}).on("data",c=>{a.push(c)}).on("end",()=>{o(a)})}))[0]}async _fetchNetwork(t){return new Promise(async(s,e)=>{const{subfolder:n,filename:i,cbStatus:o,options:l}=t,a=`/${n}/${i}`;console.log("load network:",a);let c=a.indexOf("/")>-1?a.substring(0,a.lastIndexOf("/")):this.subfolder;try{const{files:d}=await new y(this.fileApi).getDirectory(c);let u=a.indexOf("/")===-1?a:a.substring(a.lastIndexOf("/")+1);P(d,u).length!==1&&e("File not found: "+a)}catch{e("Error reading folder: "+c)}if(i.toLocaleLowerCase().endsWith(".avro")){const d=await this._getAvroNetwork(t);s(d);return}if(i.toLocaleLowerCase().endsWith(".xml")||i.toLocaleLowerCase().endsWith(".xml.gz"))try{const u=await new Promise((w,v)=>{const g=new S;g.onmessage=b=>{const h=b.data;if("requestCRS"in h){const k=h.requestCRS?'"Atlantis" coordinates found. ':"";let m=prompt(`Enter EPSG projection code.

${k}Enter projection, e.g. EPSG:25832, or cancel to load without a base map.`)||"Atlantis";Number.isInteger(parseInt(m))&&(m=`EPSG:${m}`),g.postMessage({confirmedCRS:m});return}if(h.error&&v(h.error),h.status&&o){o(h.status);return}w(h.network)},g.postMessage({path:a,crs:l.crs||"",fsConfig:this.fileApi,options:l})});s(u)}catch(d){console.error(d),e(d)}finally{return}const r=new R;try{r.onmessage=d=>{if(d.data.promptUserForCRS){let u=prompt('Enter the projection coordinate reference system, e.g. "EPSG:25832", or cancel if unknown')||"Atlantis";Number.isInteger(parseInt(u))&&(u=`EPSG:${u}`),r.postMessage({crs:u});return}if(d.data.status){o&&o(d.data.status);return}r.terminate(),d.data.error&&(console.error(d.data.error),e(d.data.error)),s(d.data.links)},r.postMessage({filePath:a,fileSystem:this.fileApi,options:l,extraColumns:!!t.extra,isFirefox:$})}catch(d){r.terminate(),console.error(d),e(d)}})}_getFileSystem(t){const s=F.state.svnProjects.filter(e=>e.slug===t);if(s.length===0)throw console.error(`DDM: no such project, is slug correct? (${t})`),Error;return s[0]}datasets={}}function D(f,t){const s={"<":()=>t<f.values[0],"<=":()=>t<=f.values[0],">":()=>t>f.values[0],">=":()=>t>=f.values[0]};let e;return f.range?e=t>=f.values[0]&&t<=f.values[1]:f.conditional?e=s[f.conditional]():e=f.values.includes(t),f.invert?!e:e}export{j as D,p as W,D as c};
