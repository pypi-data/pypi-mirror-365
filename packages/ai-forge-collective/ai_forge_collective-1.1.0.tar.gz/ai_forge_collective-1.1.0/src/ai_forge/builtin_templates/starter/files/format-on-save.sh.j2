#!/bin/bash
#
# Universal Format-on-Save Hook for {{ project_name }}
# 
# This script provides cross-platform code formatting on save.
# It detects the file type and applies appropriate formatting tools.
# 
# Generated by AI Forge Starter Template
# Created: {{ date }}
# Author: {{ author }}
#

set -euo pipefail

# Configuration
readonly SCRIPT_NAME="$(basename "$0")"
readonly PROJECT_NAME="{{ project_name }}"
readonly TIMEOUT=30
readonly VERBOSE=false

# Colors for output (if terminal supports it)
if [[ -t 1 ]] && command -v tput >/dev/null 2>&1; then
    readonly RED=$(tput setaf 1)
    readonly GREEN=$(tput setaf 2)
    readonly YELLOW=$(tput setaf 3)
    readonly BLUE=$(tput setaf 4)
    readonly RESET=$(tput sgr0)
else
    readonly RED=""
    readonly GREEN=""
    readonly YELLOW=""
    readonly BLUE=""
    readonly RESET=""
fi

# Logging functions
log_info() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "${BLUE}[INFO]${RESET} $*" >&2
    fi
}

log_warn() {
    echo "${YELLOW}[WARN]${RESET} $*" >&2
}

log_error() {
    echo "${RED}[ERROR]${RESET} $*" >&2
}

log_success() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "${GREEN}[SUCCESS]${RESET} $*" >&2
    fi
}

# Error handling
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Format-on-save hook failed for $PROJECT_NAME"
    fi
    exit $exit_code
}

trap cleanup EXIT

# Timeout handling
timeout_handler() {
    log_error "Format-on-save hook timed out after ${TIMEOUT} seconds"
    exit 124
}

trap timeout_handler ALRM

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to get file extension
get_file_extension() {
    local file="$1"
    echo "${file##*.}"
}

# Function to format Python files
format_python() {
    local file="$1"
    log_info "Formatting Python file: $file"
    
    # Try ruff first (fast), then black, then autopep8
    if command_exists ruff; then
        ruff format "$file" 2>/dev/null || return 1
    elif command_exists black; then
        black --quiet "$file" 2>/dev/null || return 1
    elif command_exists autopep8; then
        autopep8 --in-place "$file" 2>/dev/null || return 1
    else
        log_warn "No Python formatter found (ruff, black, autopep8)"
        return 1
    fi
    
    return 0
}

# Function to format JavaScript/TypeScript files
format_js_ts() {
    local file="$1"
    log_info "Formatting JS/TS file: $file"
    
    # Try prettier first, then eslint
    if command_exists prettier; then
        prettier --write "$file" 2>/dev/null || return 1
    elif command_exists eslint; then
        eslint --fix "$file" 2>/dev/null || return 1
    else
        log_warn "No JS/TS formatter found (prettier, eslint)"
        return 1
    fi
    
    return 0
}

# Function to format Go files
format_go() {
    local file="$1"
    log_info "Formatting Go file: $file"
    
    if command_exists gofmt; then
        gofmt -w "$file" 2>/dev/null || return 1
    else
        log_warn "No Go formatter found (gofmt)"
        return 1
    fi
    
    return 0
}

# Function to format Rust files
format_rust() {
    local file="$1"
    log_info "Formatting Rust file: $file"
    
    if command_exists rustfmt; then
        rustfmt "$file" 2>/dev/null || return 1
    else
        log_warn "No Rust formatter found (rustfmt)"
        return 1
    fi
    
    return 0
}

# Function to format Java files
format_java() {
    local file="$1"
    log_info "Formatting Java file: $file"
    
    if command_exists google-java-format; then
        google-java-format --replace "$file" 2>/dev/null || return 1
    else
        log_warn "No Java formatter found (google-java-format)"
        return 1
    fi
    
    return 0
}

# Function to format C/C++ files
format_c_cpp() {
    local file="$1"
    log_info "Formatting C/C++ file: $file"
    
    if command_exists clang-format; then
        clang-format -i "$file" 2>/dev/null || return 1
    else
        log_warn "No C/C++ formatter found (clang-format)"
        return 1
    fi
    
    return 0
}

# Function to format JSON files
format_json() {
    local file="$1"
    log_info "Formatting JSON file: $file"
    
    # Try jq, then python, then node
    if command_exists jq; then
        local temp_file
        temp_file=$(mktemp)
        jq '.' "$file" > "$temp_file" && mv "$temp_file" "$file" 2>/dev/null || return 1
    elif command_exists python3; then
        python3 -m json.tool "$file" > "${file}.tmp" && mv "${file}.tmp" "$file" 2>/dev/null || return 1
    elif command_exists node; then
        node -e "console.log(JSON.stringify(JSON.parse(require('fs').readFileSync('$file', 'utf8')), null, 2))" > "${file}.tmp" && mv "${file}.tmp" "$file" 2>/dev/null || return 1
    else
        log_warn "No JSON formatter found (jq, python3, node)"
        return 1
    fi
    
    return 0
}

# Function to format YAML files  
format_yaml() {
    local file="$1"
    log_info "Formatting YAML file: $file"
    
    if command_exists yamlfmt; then
        yamlfmt "$file" 2>/dev/null || return 1
    elif command_exists yq; then
        local temp_file
        temp_file=$(mktemp)
        yq eval '.' "$file" > "$temp_file" && mv "$temp_file" "$file" 2>/dev/null || return 1
    else
        log_warn "No YAML formatter found (yamlfmt, yq)"
        return 1
    fi
    
    return 0
}

# Main formatting function
format_file() {
    local file="$1"
    
    # Check if file exists and is readable
    if [[ ! -f "$file" ]] || [[ ! -r "$file" ]]; then
        log_error "File not found or not readable: $file"
        return 1
    fi
    
    # Check if file is writable
    if [[ ! -w "$file" ]]; then
        log_error "File not writable: $file"
        return 1
    fi
    
    # Get file extension
    local extension
    extension=$(get_file_extension "$file")
    extension="${extension,,}" # Convert to lowercase
    
    # Format based on file type
    case "$extension" in
        py)
            format_python "$file"
            ;;
        js|jsx|ts|tsx)
            format_js_ts "$file"
            ;;
        go)
            format_go "$file"
            ;;
        rs)
            format_rust "$file"
            ;;
        java)
            format_java "$file"
            ;;
        c|cpp|cc|cxx|h|hpp)
            format_c_cpp "$file"
            ;;
        json)
            format_json "$file"
            ;;
        yml|yaml)
            format_yaml "$file"
            ;;
        *)
            log_warn "No formatter available for file type: $extension"
            return 0 # Not an error, just unsupported
            ;;
    esac
    
    local result=$?
    if [[ $result -eq 0 ]]; then
        log_success "Formatted: $file"
    else
        log_error "Failed to format: $file"
    fi
    
    return $result
}

# Main function
main() {
    # Check if running with timeout
    if command_exists timeout; then
        timeout "$TIMEOUT" "$0" "$@"
        return $?
    fi
    
    # Parse arguments
    if [[ $# -eq 0 ]]; then
        log_error "Usage: $SCRIPT_NAME <file1> [file2] ..."
        echo "       Format one or more files using appropriate tools"
        exit 1
    fi
    
    local success_count=0
    local total_count=0
    
    # Process each file
    for file in "$@"; do
        ((total_count++))
        if format_file "$file"; then
            ((success_count++))
        fi
    done
    
    # Summary
    if [[ $total_count -eq $success_count ]]; then
        log_success "Successfully formatted $success_count/$total_count files"
        exit 0
    else
        log_warn "Formatted $success_count/$total_count files (some failed)"
        exit 1
    fi
}

# Run with timeout protection
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi