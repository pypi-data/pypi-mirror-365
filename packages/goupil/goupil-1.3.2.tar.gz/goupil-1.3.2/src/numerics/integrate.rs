use super::float::Float;


//================================================================================================
// Substitutions, for integrals.
//================================================================================================

// Generic substitution.
pub trait Substitution {
    fn direct(&self, x: Float) -> Float;
    fn inverse(&self, y: Float) -> Float; 
    fn jacobian(&self, y: Float) -> Float;
}


// No substitution.
pub struct NoSubstitution;

impl Substitution for NoSubstitution {
    fn direct(&self, x: Float) -> Float { x }
    fn inverse(&self, y: Float) -> Float { y }
    fn jacobian(&self, _: Float) -> Float { 1.0 }
}


// Log substitution.
pub struct LogSubstitution;

impl Substitution for LogSubstitution {
    fn direct(&self, x: Float) -> Float { x.ln() }
    fn inverse(&self, y: Float) -> Float { y.exp() }
    fn jacobian(&self, x: Float) -> Float { x }
}


//================================================================================================
// Integrator using a sliding window Gaussian-quadrature.
//================================================================================================

pub struct GQIntegrator<const N: usize> {
    x: [Float; N],
    w: [Float; N],
}

impl<const N: usize> GQIntegrator<N> {
    pub fn new() -> Self {
        const X: [Float; 78] = [
            /* N_GQ = 1 */
            0.5000000000000000,
            /* N_GQ = 2 */
            0.2113248654051871, 0.7886751345948129,
            /* N_GQ = 3 */
            0.1127016653792583, 0.5000000000000000, 0.8872983346207417,
            /* N_GQ = 4 */
            0.0694318442029737, 0.3300094782075719, 0.6699905217924281,
            0.9305681557970262,
            /* N_GQ = 5 */
            0.0469100770306680, 0.2307653449471584, 0.5000000000000000,
            0.7692346550528415, 0.9530899229693319,
            /* N_GQ = 6 */
            0.0337652428984240, 0.1693953067668678, 0.3806904069584016,
            0.6193095930415985, 0.8306046932331322, 0.9662347571015760,
            /* N_GQ = 7 */
            0.0254460438286208, 0.1292344072003028, 0.2970774243113014,
            0.5000000000000000, 0.7029225756886985, 0.8707655927996972,
            0.9745539561713792,
            /* N_GQ = 8 */
            0.0198550717512319, 0.1016667612931866, 0.2372337950418355,
            0.4082826787521751, 0.5917173212478249, 0.7627662049581645,
            0.8983332387068134, 0.9801449282487682,
            /* N_GQ = 9 */
            0.0159198802461870, 0.0819844463366821, 0.1933142836497048,
            0.3378732882980955, 0.5000000000000000, 0.6621267117019045,
            0.8066857163502952, 0.9180155536633179, 0.9840801197538130,
            /* N_GQ = 10 */
            0.0130467357414141, 0.0674683166555077, 0.1602952158504878,
            0.2833023029353764, 0.4255628305091844, 0.5744371694908156,
            0.7166976970646236, 0.8397047841495122, 0.9325316833444923,
            0.9869532642585859,
            /* N_GQ = 11 */
            0.0108856709269715, 0.0564687001159523, 0.1349239972129753,
            0.2404519353965941, 0.3652284220238275, 0.5000000000000000,
            0.6347715779761725, 0.7595480646034058, 0.8650760027870247,
            0.9435312998840477, 0.9891143290730284,
            /* N_GQ = 12 */
            0.0092196828766404, 0.0479413718147625, 0.1150486629028477,
            0.2063410228566913, 0.3160842505009099, 0.4373832957442655,
            0.5626167042557344, 0.6839157494990901, 0.7936589771433087,
            0.8849513370971523, 0.9520586281852375, 0.9907803171233596,
        ];
        const W: [Float; 78] = [
            /* N_GQ = 1 */
            1.0000000000000000,
            /* N_GQ = 2 */
            0.5000000000000000, 0.5000000000000000,
            /* N_GQ = 3 */
            0.2777777777777778, 0.4444444444444444, 0.2777777777777778,
            /* N_GQ = 4 */
            0.1739274225687269, 0.3260725774312731, 0.3260725774312731,
            0.1739274225687269,
            /* N_GQ = 5 */
            0.1184634425280946, 0.2393143352496833, 0.2844444444444444,
            0.2393143352496833, 0.1184634425280946,
            /* N_GQ = 6 */
            0.0856622461895852, 0.1803807865240693, 0.2339569672863455,
            0.2339569672863455, 0.1803807865240693, 0.0856622461895852,
            /* N_GQ = 7 */
            0.0647424830844349, 0.1398526957446383, 0.1909150252525595,
            0.2089795918367347, 0.1909150252525595, 0.1398526957446383,
            0.0647424830844349,
            /* N_GQ = 8 */
            0.0506142681451881, 0.1111905172266872, 0.1568533229389436,
            0.1813418916891810, 0.1813418916891810, 0.1568533229389436,
            0.1111905172266872, 0.0506142681451881,
            /* N_GQ = 9 */
            0.0406371941807872, 0.0903240803474287, 0.1303053482014677,
            0.1561735385200015, 0.1651196775006299, 0.1561735385200015,
            0.1303053482014677, 0.0903240803474287, 0.0406371941807872,
            /* N_GQ = 10 */
            0.0333356721543440, 0.0747256745752903, 0.1095431812579910,
            0.1346333596549981, 0.1477621123573765, 0.1477621123573765,
            0.1346333596549981, 0.1095431812579910, 0.0747256745752903,
            0.0333356721543440,
            /* N_GQ = 11 */
            0.0278342835580868, 0.0627901847324523, 0.0931451054638671,
            0.1165968822959952, 0.1314022722551233, 0.1364625433889503,
            0.1314022722551233, 0.1165968822959952, 0.0931451054638671,
            0.0627901847324523, 0.0278342835580868,
            /* N_GQ = 12 */
            0.0235876681932559, 0.0534696629976592, 0.0800391642716731,
            0.1015837133615330, 0.1167462682691774, 0.1245735229067014,
            0.1245735229067014, 0.1167462682691774, 0.1015837133615330,
            0.0800391642716731, 0.0534696629976592, 0.0235876681932559,
        ];

        if N <= 12 {
            let n = (N * (N - 1)) / 2;
            Self {
                x: std::array::from_fn(|i| { X[n + i] }),
                w: std::array::from_fn(|i| { W[n + i] }),
            }
        } else {
            Self {
                x: [0.0; N],
                w: [0.0; N],
            }
        }
    }

    pub fn integrate<F, S>(
        &self, integrand: F, xmin: Float, xmax: Float, n: usize, substitution: S) -> Float
        where F: Fn(Float) -> Float, S: Substitution {

        // Initialisation step.
        let n_itv = (n + N - 1) / N;
        let mut x0 = substitution.direct(xmin);
        let h = (substitution.direct(xmax) - x0) / n_itv as Float;

        /* Iteration steps. */
        let mut result = 0.0;
        for _ in 0..n_itv {
            for j in 0..N {
                let x = substitution.inverse(x0 + self.x[j] * h);
                let w = self.w[j] * h * substitution.jacobian(x);
                result += (integrand)(x) * w;
            }
            x0 += h;
        }
        result
    }
}
