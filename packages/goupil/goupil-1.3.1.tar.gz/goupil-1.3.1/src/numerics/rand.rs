use rand::Rng;
use rand::distributions::Open01;
use super::float::Float;


// ===============================================================================================
// Interface for pseudo Random Numbers Generators (RNG), specialised to Float.
// ===============================================================================================
pub trait FloatRng {
    fn uniform01(&mut self) -> Float;

    fn normal(&mut self) -> Float {
        normal_ppf(self.uniform01())
    }
}

impl<T: Rng> FloatRng for T {
    fn uniform01(&mut self) -> Float {
        self.sample::<Float, Open01>(Open01)
    }
}


// ===============================================================================================
// Percentiles of the Normal distribution.
//
// Reference:
//     Wichura, M. J. (1988).
//     Algorithm AS 241: The Percentage Points of the Normal Distribution.
//     Journal of the Royal Statistical Society. Series C (Applied Statistics), 37(3), 477-484.
// ===============================================================================================
#[allow(clippy::excessive_precision)]
fn normal_ppf(p: Float) -> Float {
    if p == 0.0 {
        return Float::NEG_INFINITY;
    } else if p == 1.0 {
        return Float::INFINITY;
    }

    let q = p - 0.5;
    if q.abs() < 0.425 {
        let r = 0.180625 - q * q;
        q * (((((((2.5090809287301226727e3 * r + 3.3430575583588128105e4) * r +
                  6.7265770927008700853e4) * r + 4.5921953931549871457e4) * r +
                1.3731693765509461125e4) * r + 1.9715909503065514427e3) * r +
              1.3314166789178437745e2) * r + 3.3871328727963666080e0) /
                (((((((5.2264952788528545610e3 * r + 2.8729085735721942674e4) * r +
                  3.9307895800092710610e4) * r + 2.1213794301586595867e4) * r +
                5.3941960214247511077e3) * r + 6.8718700749205790830e2) * r +
              4.2313330701600911252e1) * r + 1.0)
    } else {
        let mut r = if q < 0.0 { p } else { 1.0 - p };
        r = (-r.ln()).sqrt();
        let sign = if q < 0.0 { -1.0 } else { 1.0 };
        if r < 5.0 {
            r -= 1.6;
            sign * (((((((7.74545014278341407640e-4 * r + 2.27238449892691845833e-2) * r +
                         2.41780725177450611770e-1) * r + 1.27045825245236838258e0) * r +
                       3.64784832476320460504e0) * r + 5.76949722146069140550e0) * r +
                     4.63033784615654529590e0) * r + 1.42343711074968357734e0) /
                       (((((((1.05075007164441684324e-9 * r + 5.47593808499534494600e-4) * r +
                      1.51986665636164571966e-2) * r + 1.48103976427480074590e-1) * r +
                    6.89767334985100004550e-1) * r + 1.67638483018380384940e0) * r +
                  2.05319162663775882187e0) * r + 1.0)
        } else {
            r -= 5.0;
            sign * (((((((2.01033439929228813265e-7 * r + 2.71155556874348757815e-5) * r +
                         1.24266094738807843860e-3) * r + 2.65321895265761230930e-2) * r +
                       2.96560571828504891230e-1) * r + 1.78482653991729133580e0) * r +
                     5.46378491116411436990e0) * r + 6.65790464350110377720e0) /
                       (((((((2.04426310338993978564e-15 * r + 1.42151175831644588870e-7) * r +
                      1.84631831751005468180e-5) * r + 7.86869131145613259100e-4) * r +
                    1.48753612908506148525e-2) * r + 1.36929880922735805310e-1) * r +
                  5.99832206555887937690e-1) * r + 1.0)
        }
    }
}


// ===============================================================================================
// Unit tests.
// ===============================================================================================
#[cfg(test)]
mod tests {
    use ::rand::thread_rng;
    use super::*;

    #[test]
    fn normal() {
        let compare = |x, y| {assert_eq!((100.0 * normal_ppf(x)).round() as i32, y)};

        compare(0.000001, -475);
        compare(0.00001, -426);
        compare(0.0001, -372);
        compare(0.001, -309);
        compare(0.01, -233);
        compare(0.10, -128);
        compare(0.25, -67);
        compare(0.75, 67);
        compare(0.90, 128);
        compare(0.99, 233);
        compare(0.999, 309);
        compare(0.9999, 372);
        compare(0.99999, 426);
        compare(0.999999, 475);
    }

    #[test]
    fn rng() {
        let mut rng = thread_rng();
        let u = rng.uniform01();
        assert!(u >= 0.0);
        assert!(u <= 1.0);
        let v = rng.uniform01();
        assert!(u != v);
        let w0 = rng.normal();
        let w1 = rng.normal();
        assert!(w0 != w1);
    }
}
