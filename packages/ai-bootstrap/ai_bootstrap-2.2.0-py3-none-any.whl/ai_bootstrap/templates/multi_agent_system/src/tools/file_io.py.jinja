"""File I/O tools for {{ project_name }}."""

from typing import Dict, Any, Optional
import logging
from pathlib import Path
from langchain.tools import BaseTool
from pydantic import BaseModel, Field

from ..config import settings

logger = logging.getLogger(__name__)

class FileReadInput(BaseModel):
    """Input schema for file reading."""
    file_path: str = Field(description="Path to the file to read")

class FileWriteInput(BaseModel):
    """Input schema for file writing."""
    file_path: str = Field(description="Path to the file to write")
    content: str = Field(description="Content to write to the file")
    mode: str = Field(default="w", description="Write mode (w, a, etc.)")

def read_file(file_path: str) -> Dict[str, Any]:
    """Read content from a file."""
    try:
        path = Path(file_path)
        
        # Security check - ensure file is within project directory
        project_root = settings.PROJECT_ROOT
        try:
            path.resolve().relative_to(project_root.resolve())
        except ValueError:
            return {
                "success": False,
                "error": "File access outside project directory not allowed",
                "content": ""
            }
        
        if not path.exists():
            return {
                "success": False,
                "error": f"File does not exist: {file_path}",
                "content": ""
            }
        
        if not path.is_file():
            return {
                "success": False,
                "error": f"Path is not a file: {file_path}",
                "content": ""
            }
        
        # Read the file
        with open(path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        logger.info(f"Successfully read file: {file_path}")
        return {
            "success": True,
            "content": content,
            "file_size": len(content),
            "file_path": str(path)
        }
        
    except Exception as e:
        logger.error(f"Error reading file {file_path}: {e}")
        return {
            "success": False,
            "error": str(e),
            "content": ""
        }

def write_file(file_path: str, content: str, mode: str = "w") -> Dict[str, Any]:
    """Write content to a file."""
    try:
        path = Path(file_path)
        
        # Security check - ensure file is within project directory
        project_root = settings.PROJECT_ROOT
        try:
            path.resolve().relative_to(project_root.resolve())
        except ValueError:
            return {
                "success": False,
                "error": "File access outside project directory not allowed"
            }
        
        # Create parent directories if they don't exist
        path.parent.mkdir(parents=True, exist_ok=True)
        
        # Write the file
        with open(path, mode, encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Successfully wrote file: {file_path}")
        return {
            "success": True,
            "message": f"File written successfully: {file_path}",
            "file_path": str(path),
            "bytes_written": len(content.encode('utf-8'))
        }
        
    except Exception as e:
        logger.error(f"Error writing file {file_path}: {e}")
        return {
            "success": False,
            "error": str(e)
        }

class FileReadTool(BaseTool):
    """LangChain tool for reading files."""
    
    name: str = "read_file"
    description: str = "Read content from a file within the project directory"
    args_schema: type[BaseModel] = FileReadInput
    
    def _run(self, file_path: str) -> str:
        """Execute file reading."""
        result = read_file(file_path)
        
        if result["success"]:
            return f"File content from {file_path}:\n\n{result['content']}"
        else:
            return f"Error reading file {file_path}: {result['error']}"
    
    async def _arun(self, file_path: str) -> str:
        """Async version of file reading."""
        return self._run(file_path)

class FileWriteTool(BaseTool):
    """LangChain tool for writing files."""
    
    name: str = "write_file"
    description: str = "Write content to a file within the project directory"
    args_schema: type[BaseModel] = FileWriteInput
    
    def _run(self, file_path: str, content: str, mode: str = "w") -> str:
        """Execute file writing."""
        result = write_file(file_path, content, mode)
        
        if result["success"]:
            return f"Successfully wrote {result['bytes_written']} bytes to {file_path}"
        else:
            return f"Error writing file {file_path}: {result['error']}"
    
    async def _arun(self, file_path: str, content: str, mode: str = "w") -> str:
        """Async version of file writing."""
        return self._run(file_path, content, mode)

class FileIOTool(BaseTool):
    """Combined file I/O tool."""
    
    name: str = "file_io"
    description: str = "Read from or write to files within the project directory"
    
    def _run(self, action: str, file_path: str, content: str = "", mode: str = "w") -> str:
        """Execute file I/O operation."""
        if action.lower() == "read":
            return FileReadTool()._run(file_path)
        elif action.lower() == "write":
            return FileWriteTool()._run(file_path, content, mode)
        else:
            return f"Invalid action: {action}. Use 'read' or 'write'."
    
    async def _arun(self, action: str, file_path: str, content: str = "", mode: str = "w") -> str:
        """Async version of file I/O."""
        return self._run(action, file_path, content, mode)

# Create global instances for easy import
file_read_tool = FileReadTool()
file_write_tool = FileWriteTool()
file_io_tool = FileIOTool()
