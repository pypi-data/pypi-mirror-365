"""Conversation memory management for {{ project_name }}."""

from typing import Dict, List, Optional, Any
import logging
from datetime import datetime, timedelta
from langchain.schema import BaseMessage, HumanMessage, AIMessage
from langchain.memory import ConversationBufferMemory, ConversationSummaryMemory, ConversationTokenBufferMemory
{% if llm_provider == "openai" %}
from langchain_openai import ChatOpenAI
{% elif llm_provider == "anthropic" %}
from langchain_anthropic import ChatAnthropic
{% elif llm_provider == "ollama" %}
from langchain_community.llms import Ollama
{% endif %}

from ..config import settings

logger = logging.getLogger(__name__)

class ConversationMemory:
    """Manages conversation memory for multiple sessions."""
    
    def __init__(self):
        """Initialize the memory manager."""
        self.sessions: Dict[str, Dict[str, Any]] = {}
        self.memory_type = settings.MEMORY_TYPE
        
        # Initialize LLM for summary memory if needed
        if self.memory_type == "summary":
            {% if llm_provider == "openai" %}
            self.summary_llm = ChatOpenAI(
                model="gpt-3.5-turbo",
                temperature=0.1,
                openai_api_key=settings.OPENAI_API_KEY,
            )
            {% elif llm_provider == "anthropic" %}
            self.summary_llm = ChatAnthropic(
                model="claude-3-haiku-20240307",
                temperature=0.1,
                anthropic_api_key=settings.ANTHROPIC_API_KEY,
            )
            {% elif llm_provider == "ollama" %}
            self.summary_llm = Ollama(
                base_url=settings.OLLAMA_BASE_URL,
                model="llama2",
                temperature=0.1,
            )
            {% endif %}
        
        logger.info(f"Conversation memory initialized with type: {self.memory_type}")
    
    def create_session(self, session_id: str) -> bool:
        """Create a new conversation session."""
        try:
            if session_id in self.sessions:
                logger.warning(f"Session {session_id} already exists")
                return False
            
            # Create memory based on configured type
            if self.memory_type == "buffer":
                memory = ConversationBufferMemory(
                    return_messages=True,
                    output_key="response"
                )
            elif self.memory_type == "summary":
                memory = ConversationSummaryMemory(
                    llm=self.summary_llm,
                    return_messages=True,
                    output_key="response"
                )
            elif self.memory_type == "token_buffer":
                memory = ConversationTokenBufferMemory(
                    llm=self.summary_llm if hasattr(self, 'summary_llm') else None,
                    max_token_limit=settings.MAX_MEMORY_TOKENS,
                    return_messages=True,
                    output_key="response"
                )
            else:
                # Default to buffer memory
                memory = ConversationBufferMemory(
                    return_messages=True,
                    output_key="response"
                )
            
            self.sessions[session_id] = {
                "memory": memory,
                "created_at": datetime.now(),
                "last_activity": datetime.now(),
                "message_count": 0,
                "metadata": {}
            }
            
            logger.info(f"Created new session: {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error creating session {session_id}: {e}")
            return False
    
    def has_session(self, session_id: str) -> bool:
        """Check if a session exists."""
        return session_id in self.sessions
    
    def add_message(self, session_id: str, message: BaseMessage) -> bool:
        """Add a message to the session memory."""
        try:
            if session_id not in self.sessions:
                logger.error(f"Session {session_id} does not exist")
                return False
            
            session = self.sessions[session_id]
            
            # Add timestamp to message if not present
            if not hasattr(message, 'timestamp'):
                setattr(message, 'timestamp', datetime.now())
            
            # Add message to memory
            if isinstance(message, HumanMessage):
                session["memory"].chat_memory.add_user_message(message.content)
            elif isinstance(message, AIMessage):
                session["memory"].chat_memory.add_ai_message(message.content)
            
            # Update session metadata
            session["last_activity"] = datetime.now()
            session["message_count"] += 1
            
            logger.debug(f"Added message to session {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error adding message to session {session_id}: {e}")
            return False
    
    def get_messages(self, session_id: str) -> List[BaseMessage]:
        """Get all messages from a session."""
        if session_id not in self.sessions:
            logger.error(f"Session {session_id} does not exist")
            return []
        
        try:
            memory = self.sessions[session_id]["memory"]
            return memory.chat_memory.messages
            
        except Exception as e:
            logger.error(f"Error getting messages from session {session_id}: {e}")
            return []
    
    def get_memory_buffer(self, session_id: str) -> str:
        """Get the current memory buffer as text."""
        if session_id not in self.sessions:
            return ""
        
        try:
            memory = self.sessions[session_id]["memory"]
            return memory.buffer
            
        except Exception as e:
            logger.error(f"Error getting memory buffer for session {session_id}: {e}")
            return ""
    
    def clear_session(self, session_id: str) -> bool:
        """Clear all messages from a session."""
        try:
            if session_id not in self.sessions:
                logger.error(f"Session {session_id} does not exist")
                return False
            
            self.sessions[session_id]["memory"].clear()
            self.sessions[session_id]["message_count"] = 0
            self.sessions[session_id]["last_activity"] = datetime.now()
            
            logger.info(f"Cleared session: {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error clearing session {session_id}: {e}")
            return False
    
    def delete_session(self, session_id: str) -> bool:
        """Delete a session entirely."""
        try:
            if session_id in self.sessions:
                del self.sessions[session_id]
                logger.info(f"Deleted session: {session_id}")
                return True
            else:
                logger.warning(f"Session {session_id} does not exist")
                return False
                
        except Exception as e:
            logger.error(f"Error deleting session {session_id}: {e}")
            return False
    
    def cleanup_expired_sessions(self) -> int:
        """Clean up expired sessions based on timeout."""
        try:
            timeout = timedelta(minutes=settings.SESSION_TIMEOUT_MINUTES)
            current_time = datetime.now()
            expired_sessions = []
            
            for session_id, session_data in self.sessions.items():
                if current_time - session_data["last_activity"] > timeout:
                    expired_sessions.append(session_id)
            
            # Delete expired sessions
            for session_id in expired_sessions:
                self.delete_session(session_id)
            
            if expired_sessions:
                logger.info(f"Cleaned up {len(expired_sessions)} expired sessions")
            
            return len(expired_sessions)
            
        except Exception as e:
            logger.error(f"Error during session cleanup: {e}")
            return 0
    
    def get_session_info(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get information about a session."""
        if session_id not in self.sessions:
            return None
        
        session = self.sessions[session_id]
        return {
            "session_id": session_id,
            "created_at": session["created_at"],
            "last_activity": session["last_activity"],
            "message_count": session["message_count"],
            "memory_type": self.memory_type,
            "metadata": session["metadata"]
        }
    
    def get_session_count(self) -> int:
        """Get the number of active sessions."""
        return len(self.sessions)
    
    def list_sessions(self) -> List[str]:
        """List all active session IDs."""
        return list(self.sessions.keys())
    
    def update_session_metadata(self, session_id: str, metadata: Dict[str, Any]) -> bool:
        """Update session metadata."""
        try:
            if session_id not in self.sessions:
                logger.error(f"Session {session_id} does not exist")
                return False
            
            self.sessions[session_id]["metadata"].update(metadata)
            self.sessions[session_id]["last_activity"] = datetime.now()
            
            logger.debug(f"Updated metadata for session {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error updating metadata for session {session_id}: {e}")
            return False

# Global memory instance  
memory_manager = ConversationMemory()
