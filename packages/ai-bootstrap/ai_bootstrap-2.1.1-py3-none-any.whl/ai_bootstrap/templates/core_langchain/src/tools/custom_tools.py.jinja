"""Custom tools for {{ project_name }}."""

{% if include_tools %}
from typing import List, Dict, Any, Optional, Type
import logging
import requests
import json
import ast
import subprocess
from pathlib import Path
from langchain.tools import BaseTool
from langchain_community.tools import DuckDuckGoSearchRun
from langchain_experimental.tools import PythonREPLTool as LangChainPythonREPL
from pydantic import BaseModel, Field

from ..config import settings

logger = logging.getLogger(__name__)

class WebSearchInput(BaseModel):
    """Input schema for web search tool."""
    query: str = Field(description="Search query")

class WebSearchTool(BaseTool):
    """Custom web search tool."""
    
    name: str = "web_search"
    description: str = "Search the web for current information on any topic"
    args_schema: Type[BaseModel] = WebSearchInput
    
    def __init__(self):
        super().__init__()
        self.search_engine = DuckDuckGoSearchRun()
    
    def _run(self, query: str) -> str:
        """Execute web search."""
        try:
            results = self.search_engine.run(query)
            logger.info(f"Web search performed for: {query}")
            return results
        except Exception as e:
            logger.error(f"Web search error: {e}")
            return f"Search failed: {str(e)}"
    
    async def _arun(self, query: str) -> str:
        """Async version of web search."""
        return self._run(query)

class CalculatorInput(BaseModel):
    """Input schema for calculator tool."""
    expression: str = Field(description="Mathematical expression to evaluate")

class CalculatorTool(BaseTool):
    """Calculator tool for mathematical operations."""
    
    name: str = "calculator"
    description: str = "Perform mathematical calculations and evaluate expressions"
    args_schema: Type[BaseModel] = CalculatorInput
    
    def _run(self, expression: str) -> str:
        """Execute calculation."""
        try:
            # Sanitize expression for safety
            allowed_names = {
                k: v for k, v in __builtins__.items()
                if k in ['abs', 'round', 'min', 'max', 'sum', 'pow']
            }
            
            # Add math functions
            import math
            allowed_names.update({
                name: getattr(math, name)
                for name in dir(math)
                if not name.startswith('_')
            })
            
            # Parse and evaluate safely
            node = ast.parse(expression, mode='eval')
            
            # Check for unsafe operations
            for subnode in ast.walk(node):
                if isinstance(subnode, (ast.Import, ast.ImportFrom, ast.Call)):
                    if isinstance(subnode, ast.Call) and hasattr(subnode.func, 'id'):
                        if subnode.func.id not in allowed_names:
                            raise ValueError(f"Function {subnode.func.id} not allowed")
            
            result = eval(compile(node, '<string>', 'eval'), {"__builtins__": {}}, allowed_names)
            
            logger.info(f"Calculation performed: {expression} = {result}")
            return str(result)
            
        except Exception as e:
            logger.error(f"Calculation error: {e}")
            return f"Calculation failed: {str(e)}"
    
    async def _arun(self, expression: str) -> str:
        """Async version of calculator."""
        return self._run(expression)

class FileReaderInput(BaseModel):
    """Input schema for file reader tool."""
    file_path: str = Field(description="Path to the file to read")

class FileReaderTool(BaseTool):
    """Tool for reading files from the file system."""
    
    name: str = "file_reader"
    description: str = "Read contents of text files"
    args_schema: Type[BaseModel] = FileReaderInput
    
    def _run(self, file_path: str) -> str:
        """Read file contents."""
        try:
            path = Path(file_path)
            
            # Security check - ensure file is within project directory
            project_root = settings.PROJECT_ROOT
            try:
                path.resolve().relative_to(project_root.resolve())
            except ValueError:
                return "Error: File access outside project directory not allowed"
            
            if not path.exists():
                return f"Error: File does not exist: {file_path}"
            
            if path.is_dir():
                # List directory contents
                contents = [item.name for item in path.iterdir()]
                return f"Directory contents: {', '.join(contents)}"
            
            # Read file
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Limit content length
            if len(content) > 10000:
                content = content[:10000] + "\n... (truncated)"
            
            logger.info(f"File read: {file_path}")
            return content
            
        except Exception as e:
            logger.error(f"File read error: {e}")
            return f"File read failed: {str(e)}"
    
    async def _arun(self, file_path: str) -> str:
        """Async version of file reader."""
        return self._run(file_path)

class PythonREPLInput(BaseModel):
    """Input schema for Python REPL tool."""
    code: str = Field(description="Python code to execute")

class PythonREPLTool(BaseTool):
    """Python REPL tool for code execution."""
    
    name: str = "python_repl"
    description: str = "Execute Python code and return the result"
    args_schema: Type[BaseModel] = PythonREPLInput
    
    def __init__(self):
        super().__init__()
        self.repl = LangChainPythonREPL()
    
    def _run(self, code: str) -> str:
        """Execute Python code."""
        try:
            result = self.repl.run(code)
            logger.info("Python code executed successfully")
            return result
        except Exception as e:
            logger.error(f"Python execution error: {e}")
            return f"Execution failed: {str(e)}"
    
    async def _arun(self, code: str) -> str:
        """Async version of Python REPL."""
        return self._run(code)

class APICallInput(BaseModel):
    """Input schema for API call tool."""
    url: str = Field(description="API endpoint URL")
    method: str = Field(default="GET", description="HTTP method")
    headers: Optional[Dict[str, str]] = Field(default=None, description="HTTP headers")
    data: Optional[Dict[str, Any]] = Field(default=None, description="Request data")

class APICallTool(BaseTool):
    """Tool for making HTTP API calls."""
    
    name: str = "api_call"
    description: str = "Make HTTP API calls to external services"
    args_schema: Type[BaseModel] = APICallInput
    
    def _run(
        self,
        url: str,
        method: str = "GET",
        headers: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, Any]] = None
    ) -> str:
        """Make HTTP API call."""
        try:
            # Basic URL validation
            if not url.startswith(('http://', 'https://')):
                return "Error: Only HTTP and HTTPS URLs are allowed"
            
            # Prepare request
            kwargs = {
                'method': method.upper(),
                'url': url,
                'timeout': 30,
            }
            
            if headers:
                kwargs['headers'] = headers
            
            if data and method.upper() in ['POST', 'PUT', 'PATCH']:
                kwargs['json'] = data
            
            # Make request
            response = requests.request(**kwargs)
            response.raise_for_status()
            
            # Try to parse JSON response
            try:
                result = response.json()
                return json.dumps(result, indent=2)
            except json.JSONDecodeError:
                return response.text
            
        except requests.exceptions.RequestException as e:
            logger.error(f"API call error: {e}")
            return f"API call failed: {str(e)}"
        except Exception as e:
            logger.error(f"Unexpected error in API call: {e}")
            return f"Unexpected error: {str(e)}"
    
    async def _arun(
        self,
        url: str,
        method: str = "GET",
        headers: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, Any]] = None
    ) -> str:
        """Async version of API call."""
        return self._run(url, method, headers, data)

def get_available_tools() -> List[BaseTool]:
    """Get a list of all available tools.
    
    Returns:
        List of configured tool instances
    """
    tools = [
        WebSearchTool(),
        CalculatorTool(),
        FileReaderTool(),
        PythonREPLTool(),
        APICallTool(),
    ]
    
    logger.info(f"Loaded {len(tools)} tools")
    return tools

def get_tool_by_name(tool_name: str) -> Optional[BaseTool]:
    """Get a specific tool by name.
    
    Args:
        tool_name: Name of the tool to retrieve
        
    Returns:
        Tool instance if found, None otherwise
    """
    tools = get_available_tools()
    
    for tool in tools:
        if tool.name == tool_name:
            return tool
    
    logger.warning(f"Tool not found: {tool_name}")
    return None

def list_tool_names() -> List[str]:
    """List names of all available tools.
    
    Returns:
        List of tool names
    """
    tools = get_available_tools()
    return [tool.name for tool in tools]

class ToolManager:
    """Manager class for handling tools."""
    
    def __init__(self):
        """Initialize the tool manager."""
        self._tools = get_available_tools()
        self._tool_map = {tool.name: tool for tool in self._tools}
    
    def get_tool(self, name: str) -> Optional[BaseTool]:
        """Get a tool by name."""
        return self._tool_map.get(name)
    
    def list_tools(self) -> List[str]:
        """List all available tool names."""
        return list(self._tool_map.keys())
    
    def execute_tool(self, name: str, **kwargs) -> str:
        """Execute a tool by name with given arguments."""
        tool = self.get_tool(name)
        if not tool:
            return f"Tool '{name}' not found"
        
        try:
            return tool.run(kwargs)
        except Exception as e:
            logger.error(f"Error executing tool {name}: {e}")
            return f"Tool execution failed: {str(e)}"

# Global tool manager instance
tool_manager = ToolManager()

{% else %}
# Tools are not included in this configuration
def get_available_tools():
    """Tools not configured for this project."""
    return []
{% endif %}
