Metadata-Version: 2.4
Name: slice-to-offset-range
Version: 0.1.0a0
Summary: A utility function that converts Python slice objects to explicit `(start_offset, stop_offset, step)` offset ranges given a sequence length.
Author-email: Jifeng Wu <jifengwu2k@gmail.com>
License-Expression: MIT
Project-URL: Homepage, https://github.com/jifengwu2k/slice-to-offset-range
Project-URL: Bug Tracker, https://github.com/jifengwu2k/slice-to-offset-range/issues
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 3
Classifier: Operating System :: OS Independent
Requires-Python: >=2
Description-Content-Type: text/markdown
License-File: LICENSE
Dynamic: license-file

# `slice-to-offset-range`

A utility function that converts Python slice objects to explicit `(start_offset, stop_offset, step)` offset ranges given a sequence length.

## Features

- Converts slice objects to explicit offset ranges
  - `offset = 0` refers to the first element of a sequence, `< 0` to memory before that, and `> 0` to memory after that
- Converts negative indices and None values
- Handles both positive and negative steps
- Ensures `start_offset <= stop_offset` when `step > 0` and `stop_offset >= stop_offset` when `step < 0`
- Lightweight with no dependencies

## Installation

```bash
pip install slice-to-offset-range
```

## Usage

```python
from slice_to_offset_range import slice_to_offset_range


# Basic positive step cases
assert slice_to_offset_range(slice(2, 5), 10) == (2, 5, 1)
assert slice_to_offset_range(slice(2, 5, 2), 10) == (2, 5, 2)
assert slice_to_offset_range(slice(0, 100), 10) == (0, 100, 1)  # Converted as-is, no bound checking
assert slice_to_offset_range(slice(1, 1), 10) == (1, 1, 1)  # Empty slice
assert slice_to_offset_range(slice(1, 0), 10) == (1, 1, 1)  # Empty slice

# Basic negative step cases
assert slice_to_offset_range(slice(5, 2, -1), 10) == (5, 2, -1)
assert slice_to_offset_range(slice(5, 2, -2), 10) == (5, 2, -2)
assert slice_to_offset_range(slice(5, 5, -1), 10) == (5, 5, -1)  # Empty slice
assert slice_to_offset_range(slice(5, 6, -1), 10) == (5, 5, -1)  # Empty slice

# Negative indices with positive step
assert slice_to_offset_range(slice(-3, -1), 10) == (7, 9, 1)
assert slice_to_offset_range(slice(2, -3), 10) == (2, 7, 1)
assert slice_to_offset_range(slice(-11, -2), 10) == (-1, 8, 1)  # Converted as-is, no bound checking

# Negative indices with negative step
assert slice_to_offset_range(slice(-2, -5, -1), 10) == (8, 5, -1)
assert slice_to_offset_range(slice(-1, -7, -1), 5) == (4, -2, -1)  # Converted as-is, no bound checking
assert slice_to_offset_range(slice(-3, -6, -1), 10) == (7, 4, -1)

# None values with positive step
assert slice_to_offset_range(slice(None, 5), 10) == (0, 5, 1)
assert slice_to_offset_range(slice(2, None), 10) == (2, 10, 1)
assert slice_to_offset_range(slice(None, None), 10) == (0, 10, 1)

# None values with negative step
assert slice_to_offset_range(slice(None, None, -1), 5) == (4, -1, -1)
assert slice_to_offset_range(slice(3, None, -1), 5) == (3, -1, -1)
assert slice_to_offset_range(slice(None, 2, -1), 5) == (4, 2, -1)

# Invalid cases (should raise ValueError)
try:
    slice_to_offset_range(slice(2, 5, 0), 10)
    assert False, "Should raise ValueError for step=0"
except ValueError:
    pass

try:
    slice_to_offset_range(slice(2.5, 5), 10)
    assert False, "Should raise ValueError for non-integer start"
except ValueError:
    pass

try:
    slice_to_offset_range(slice(2, 5), -1)
    assert False, "Should raise ValueError for negative n"
except ValueError:
    pass
```

## Contributing

Contributions are welcome! Please submit pull requests or open issues on the GitHub repository.

## License

This project is licensed under the [MIT License](LICENSE).
