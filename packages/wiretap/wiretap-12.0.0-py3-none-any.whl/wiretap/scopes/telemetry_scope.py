import contextlib
import dataclasses
import logging
import uuid
from contextvars import ContextVar
from inspect import FrameInfo
from typing import Optional, Any, Iterator, TypeVar

from tools import Elapsed
from wiretap.data import TagSet

T = TypeVar("T", bound="TelemetryScope")


class TelemetryScope:
    """
    This class represents a single telemetry scope.
    """

    current_scope: ContextVar[Optional["TelemetryScope"]] = ContextVar("current_scope", default=None)

    def __init__(
            self,
            id: Any | None,
            name: str | None,
            dump: dict[str, Any] | None,
            tags: set[Any] | None,
            frame: FrameInfo,
            parent: Optional["TelemetryScope"]
    ):
        self.id = id or uuid.uuid4()
        self.name = name or frame.function
        self.dump = dump or {}
        self.tags = tags or set()
        self.frame = frame
        self.depth = 1
        self.parent = parent
        self.can_log = True

        if parent:
            self.tags |= parent.tags
            self.depth += parent.depth

        self.elapsed = Elapsed()
        self.logger: logging.Logger = logging.getLogger(name)

        # Counts traces logged by this scope only.
        self.trace_count_own: int = 0

        # Counts traces logged by this scope and its children.
        self.trace_count_all: int = 0

    def __iter__(self) -> Iterator["TelemetryScope"]:
        current: Optional["TelemetryScope"] = self
        while current:
            yield current
            current = current.parent

    @property
    def is_debug(self) -> bool:
        return self.logger.isEnabledFor(logging.DEBUG)

    def log_trace(
            self,
            name: str = "scrap",
            message: str | None = None,
            dump: dict | None = None,
            tags: set[Any] | None = None,
            level: int = logging.INFO,
            exc_info: bool = False,
            is_final: bool = False,
            **kwargs
    ) -> None:
        """Logs scrap trace at the info level."""

        # Can no longer log.
        if not self.can_log:
            # Ignore logs from other final logs.
            if is_final:
                return
            # Logging non-final logs is otherwise illegal.
            else:
                raise Exception(f"The current scope '{self.name}' can no longer log.")

        self.logger.log(
            level=level,
            msg=message,
            exc_info=exc_info,
            extra=TelemetryItem(
                scope=self,
                trace=TelemetryTrace(
                    name=name,
                    message=message,
                    dump=(dump or {}) | kwargs | self.dump,
                    tags=TagSet(tags),
                    is_final=is_final,
                )
            ).to_extra()
        )

        # Increment counters if logged.
        if self.logger.isEnabledFor(level):
            self.trace_count_own += 1
            self.trace_count_all += 1

        self.can_log = not is_final

    def log_debug(
            self,
            name: str = "scrap",
            message: str | None = None,
            dump: dict | None = None,
            tags: set[Any] | None = None,
            is_final: bool = False,
            **kwargs
    ) -> None:
        """
        Logs scrap trace at the debug level.
        """
        self.log_trace(
            name=name,
            message=message,
            dump=dump,
            tags=tags,
            level=logging.DEBUG,
            is_final=is_final,
            **kwargs
        )

    def log_error(
            self,
            message: str | None = None,
            dump: dict | None = None,
            tags: set[Any] | None = None,
            is_final: bool = True,
            **kwargs
    ) -> None:
        """Logs error trace at the error level."""
        self.log_trace(
            name="error",
            message=message,
            dump=dump,
            tags=(tags or set()),
            level=logging.ERROR,
            exc_info=True,
            is_final=is_final,
            **kwargs
        )

    @classmethod
    @contextlib.contextmanager
    def push(
            cls: type[T],
            id: Any | None,
            name: str | None,
            dump: dict[str, Any] | None,
            tags: set[Any] | None,
            frame: FrameInfo
    ) -> Iterator[T]:
        """
        Pushes a new telemetry scope onto the stack.


        Parameters:
        :param id: Correlation id for the scope; autogenerated if not provided.
        :param name: Name of the scope, derived from the calling frame if not provided.
        :param tags: Tags to associate with this telemetry scope.
        :param dump: Extra data to attach to the scope.
        :param frame: Frame information about the scopeâ€™s context.

        :returns: The newly created scope.
        """

        if frame is None:
            raise ValueError("FrameInfo must not be None.")

        parent = cls.peek()
        scope = cls(id=id, name=name, dump=dump, tags=tags, frame=frame, parent=parent)
        token = cls.current_scope.set(scope)
        try:
            yield scope
        finally:
            if parent:
                parent.trace_count_all += scope.trace_count_all
            cls.current_scope.reset(token)

    @classmethod
    def peek(cls) -> Optional["TelemetryScope"]:
        return cls.current_scope.get()


@dataclasses.dataclass
class TelemetryTrace:
    name: str | None
    message: str | None
    dump: dict[str, Any]
    tags: TagSet
    is_final: bool


@dataclasses.dataclass
class TelemetryItem:
    """
    This class takes care of the extra data that is added to the log record.
    """

    KEY = "_telemetry"

    scope: TelemetryScope | None
    trace: TelemetryTrace | None

    @property
    def properties(self) -> tuple[Optional[TelemetryScope], Optional[TelemetryTrace]]:
        return self.scope, self.trace

    def to_extra(self) -> dict[str, Any]:
        return {
            self.KEY: TelemetryItem(
                self.scope,
                self.trace,
            )
        }

    @classmethod
    def from_record_or_scope(cls, record: logging.LogRecord) -> Optional["TelemetryItem"]:
        # Try to get telemetry scope and trace from the record.
        item: Optional["TelemetryItem"] = record.__dict__.get(cls.KEY, None)
        if item:
            return item

        # Try to get the closest telemetry scope.
        scope = TelemetryScope.peek()
        if scope:
            return cls(scope, None)

        # There was nothing to get.
        return TelemetryItem(None, None)

    def __bool__(self) -> bool:
        return bool(self.scope or self.trace)
