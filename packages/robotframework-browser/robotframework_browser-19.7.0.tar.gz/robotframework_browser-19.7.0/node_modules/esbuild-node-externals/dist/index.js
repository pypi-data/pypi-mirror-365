"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeExternalsPlugin = void 0;
const utils_1 = require("./utils");
const foundPackagePaths = new Map();
const findPackagePathsMemoized = (cwd) => {
    if (foundPackagePaths.has(cwd)) {
        return foundPackagePaths.get(cwd);
    }
    foundPackagePaths.set(cwd, (0, utils_1.findPackagePaths)(cwd));
    return findPackagePathsMemoized(cwd);
};
const nodeExternalsPlugin = (paramsOptions = {}) => {
    const options = {
        dependencies: true,
        devDependencies: true,
        peerDependencies: true,
        optionalDependencies: true,
        allowWorkspaces: false,
        ...paramsOptions,
        packagePath: paramsOptions.packagePath && typeof paramsOptions.packagePath === 'string'
            ? [paramsOptions.packagePath]
            : paramsOptions.packagePath,
    };
    const allowPredicate = options.allowList && (0, utils_1.createAllowPredicate)(options.allowList);
    const externalPredicate = options.forceExternalList &&
        (0, utils_1.createAllowPredicate)(options.forceExternalList);
    return {
        name: 'node-externals',
        setup(build) {
            const cwd = options.cwd || build.initialOptions.absWorkingDir || process.cwd();
            const nodeModules = (0, utils_1.findDependencies)({
                packagePaths: options.packagePath
                    ? options.packagePath
                    : findPackagePathsMemoized(cwd),
                dependencies: options.dependencies,
                devDependencies: options.devDependencies,
                peerDependencies: options.peerDependencies,
                optionalDependencies: options.optionalDependencies,
                allowPredicate,
                allowWorkspaces: options.allowWorkspaces,
            });
            // On every module resolved, we check if the module name should be an external
            build.onResolve({ namespace: 'file', filter: /.*/ }, (args) => {
                // To allow allowList to target sub imports
                if (allowPredicate?.(args.path)) {
                    return null;
                }
                // To allow sub imports from packages we take only the first path to deduct the name
                let moduleName = args.path.split('/')[0];
                // In case of scoped package
                if (args.path.startsWith('@')) {
                    const split = args.path.split('/');
                    moduleName = `${split[0]}/${split[1]}`;
                }
                // Mark the module as external so it is not resolved
                if (moduleName && nodeModules.includes(moduleName)) {
                    return { path: args.path, external: true };
                }
                // Allow one last override to force a path/package to be treated as external
                if (externalPredicate?.(args.path)) {
                    return { path: args.path, external: true };
                }
                return null;
            });
        },
    };
};
exports.nodeExternalsPlugin = nodeExternalsPlugin;
exports.default = exports.nodeExternalsPlugin;
//# sourceMappingURL=index.js.map