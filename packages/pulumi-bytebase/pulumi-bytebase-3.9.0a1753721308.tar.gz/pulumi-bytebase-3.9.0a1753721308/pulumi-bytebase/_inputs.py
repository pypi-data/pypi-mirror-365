# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'DatabaseCatalogArgs',
    'DatabaseCatalogArgsDict',
    'DatabaseCatalogSchemaArgs',
    'DatabaseCatalogSchemaArgsDict',
    'DatabaseCatalogSchemaTableArgs',
    'DatabaseCatalogSchemaTableArgsDict',
    'DatabaseCatalogSchemaTableColumnArgs',
    'DatabaseCatalogSchemaTableColumnArgsDict',
    'GroupMemberArgs',
    'GroupMemberArgsDict',
    'InstanceDataSourceArgs',
    'InstanceDataSourceArgsDict',
    'InstanceDataSourceExternalSecretArgs',
    'InstanceDataSourceExternalSecretArgsDict',
    'InstanceDataSourceExternalSecretAwsSecretsManagerArgs',
    'InstanceDataSourceExternalSecretAwsSecretsManagerArgsDict',
    'InstanceDataSourceExternalSecretGcpSecretManagerArgs',
    'InstanceDataSourceExternalSecretGcpSecretManagerArgsDict',
    'InstanceDataSourceExternalSecretVaultArgs',
    'InstanceDataSourceExternalSecretVaultArgsDict',
    'InstanceDataSourceExternalSecretVaultAppRoleArgs',
    'InstanceDataSourceExternalSecretVaultAppRoleArgsDict',
    'PolicyDataSourceQueryPolicyArgs',
    'PolicyDataSourceQueryPolicyArgsDict',
    'PolicyDisableCopyDataPolicyArgs',
    'PolicyDisableCopyDataPolicyArgsDict',
    'PolicyGlobalMaskingPolicyArgs',
    'PolicyGlobalMaskingPolicyArgsDict',
    'PolicyGlobalMaskingPolicyRuleArgs',
    'PolicyGlobalMaskingPolicyRuleArgsDict',
    'PolicyMaskingExceptionPolicyArgs',
    'PolicyMaskingExceptionPolicyArgsDict',
    'PolicyMaskingExceptionPolicyExceptionArgs',
    'PolicyMaskingExceptionPolicyExceptionArgsDict',
    'PolicyRolloutPolicyArgs',
    'PolicyRolloutPolicyArgsDict',
    'ProjectWebhookArgs',
    'ProjectWebhookArgsDict',
    'SettingApprovalFlowArgs',
    'SettingApprovalFlowArgsDict',
    'SettingApprovalFlowRuleArgs',
    'SettingApprovalFlowRuleArgsDict',
    'SettingApprovalFlowRuleConditionArgs',
    'SettingApprovalFlowRuleConditionArgsDict',
    'SettingApprovalFlowRuleFlowArgs',
    'SettingApprovalFlowRuleFlowArgsDict',
    'SettingApprovalFlowRuleFlowStepArgs',
    'SettingApprovalFlowRuleFlowStepArgsDict',
    'SettingClassificationArgs',
    'SettingClassificationArgsDict',
    'SettingClassificationClassificationArgs',
    'SettingClassificationClassificationArgsDict',
    'SettingClassificationLevelArgs',
    'SettingClassificationLevelArgsDict',
    'SettingEnvironmentSettingArgs',
    'SettingEnvironmentSettingArgsDict',
    'SettingEnvironmentSettingEnvironmentArgs',
    'SettingEnvironmentSettingEnvironmentArgsDict',
    'SettingPasswordRestrictionArgs',
    'SettingPasswordRestrictionArgsDict',
    'SettingSemanticTypeArgs',
    'SettingSemanticTypeArgsDict',
    'SettingSemanticTypeAlgorithmArgs',
    'SettingSemanticTypeAlgorithmArgsDict',
    'SettingSemanticTypeAlgorithmFullMaskArgs',
    'SettingSemanticTypeAlgorithmFullMaskArgsDict',
    'SettingSemanticTypeAlgorithmInnerOuterMaskArgs',
    'SettingSemanticTypeAlgorithmInnerOuterMaskArgsDict',
    'SettingSemanticTypeAlgorithmMd5MaskArgs',
    'SettingSemanticTypeAlgorithmMd5MaskArgsDict',
    'SettingSemanticTypeAlgorithmRangeMaskArgs',
    'SettingSemanticTypeAlgorithmRangeMaskArgsDict',
    'SettingSemanticTypeAlgorithmRangeMaskSliceArgs',
    'SettingSemanticTypeAlgorithmRangeMaskSliceArgsDict',
    'SettingSqlQueryRestrictionArgs',
    'SettingSqlQueryRestrictionArgsDict',
    'SettingWorkspaceProfileArgs',
    'SettingWorkspaceProfileArgsDict',
    'SettingWorkspaceProfileAnnouncementArgs',
    'SettingWorkspaceProfileAnnouncementArgsDict',
    'GetPolicyDataSourceQueryPolicyArgs',
    'GetPolicyDataSourceQueryPolicyArgsDict',
    'GetPolicyDisableCopyDataPolicyArgs',
    'GetPolicyDisableCopyDataPolicyArgsDict',
    'GetPolicyGlobalMaskingPolicyArgs',
    'GetPolicyGlobalMaskingPolicyArgsDict',
    'GetPolicyGlobalMaskingPolicyRuleArgs',
    'GetPolicyGlobalMaskingPolicyRuleArgsDict',
    'GetPolicyMaskingExceptionPolicyArgs',
    'GetPolicyMaskingExceptionPolicyArgsDict',
    'GetPolicyMaskingExceptionPolicyExceptionArgs',
    'GetPolicyMaskingExceptionPolicyExceptionArgsDict',
    'GetPolicyRolloutPolicyArgs',
    'GetPolicyRolloutPolicyArgsDict',
    'GetSettingApprovalFlowArgs',
    'GetSettingApprovalFlowArgsDict',
    'GetSettingApprovalFlowRuleArgs',
    'GetSettingApprovalFlowRuleArgsDict',
    'GetSettingApprovalFlowRuleConditionArgs',
    'GetSettingApprovalFlowRuleConditionArgsDict',
    'GetSettingApprovalFlowRuleFlowArgs',
    'GetSettingApprovalFlowRuleFlowArgsDict',
    'GetSettingApprovalFlowRuleFlowStepArgs',
    'GetSettingApprovalFlowRuleFlowStepArgsDict',
    'GetSettingClassificationArgs',
    'GetSettingClassificationArgsDict',
    'GetSettingClassificationClassificationArgs',
    'GetSettingClassificationClassificationArgsDict',
    'GetSettingClassificationLevelArgs',
    'GetSettingClassificationLevelArgsDict',
    'GetSettingEnvironmentSettingArgs',
    'GetSettingEnvironmentSettingArgsDict',
    'GetSettingEnvironmentSettingEnvironmentArgs',
    'GetSettingEnvironmentSettingEnvironmentArgsDict',
    'GetSettingPasswordRestrictionArgs',
    'GetSettingPasswordRestrictionArgsDict',
    'GetSettingSemanticTypeArgs',
    'GetSettingSemanticTypeArgsDict',
    'GetSettingSemanticTypeAlgorithmArgs',
    'GetSettingSemanticTypeAlgorithmArgsDict',
    'GetSettingSemanticTypeAlgorithmFullMaskArgs',
    'GetSettingSemanticTypeAlgorithmFullMaskArgsDict',
    'GetSettingSemanticTypeAlgorithmInnerOuterMaskArgs',
    'GetSettingSemanticTypeAlgorithmInnerOuterMaskArgsDict',
    'GetSettingSemanticTypeAlgorithmMd5MaskArgs',
    'GetSettingSemanticTypeAlgorithmMd5MaskArgsDict',
    'GetSettingSemanticTypeAlgorithmRangeMaskArgs',
    'GetSettingSemanticTypeAlgorithmRangeMaskArgsDict',
    'GetSettingSemanticTypeAlgorithmRangeMaskSliceArgs',
    'GetSettingSemanticTypeAlgorithmRangeMaskSliceArgsDict',
    'GetSettingSqlQueryRestrictionArgs',
    'GetSettingSqlQueryRestrictionArgsDict',
    'GetSettingWorkspaceProfileArgs',
    'GetSettingWorkspaceProfileArgsDict',
    'GetSettingWorkspaceProfileAnnouncementArgs',
    'GetSettingWorkspaceProfileAnnouncementArgsDict',
]

MYPY = False

if not MYPY:
    class DatabaseCatalogArgsDict(TypedDict):
        schemas: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaArgsDict']]]
elif False:
    DatabaseCatalogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseCatalogArgs:
    def __init__(__self__, *,
                 schemas: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaArgs']]]):
        pulumi.set(__self__, "schemas", schemas)

    @property
    @pulumi.getter
    def schemas(self) -> pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaArgs']]]:
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaArgs']]]):
        pulumi.set(self, "schemas", value)


if not MYPY:
    class DatabaseCatalogSchemaArgsDict(TypedDict):
        tables: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableArgsDict']]]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DatabaseCatalogSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseCatalogSchemaArgs:
    def __init__(__self__, *,
                 tables: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableArgs']]],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "tables", tables)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def tables(self) -> pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableArgs']]]:
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableArgs']]]):
        pulumi.set(self, "tables", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DatabaseCatalogSchemaTableArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableColumnArgsDict']]]
        name: pulumi.Input[builtins.str]
        classification: NotRequired[pulumi.Input[builtins.str]]
        """
        The classification id
        """
elif False:
    DatabaseCatalogSchemaTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseCatalogSchemaTableArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableColumnArgs']]],
                 name: pulumi.Input[builtins.str],
                 classification: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] classification: The classification id
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "name", name)
        if classification is not None:
            pulumi.set(__self__, "classification", classification)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableColumnArgs']]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['DatabaseCatalogSchemaTableColumnArgs']]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def classification(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The classification id
        """
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "classification", value)


if not MYPY:
    class DatabaseCatalogSchemaTableColumnArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        classification: NotRequired[pulumi.Input[builtins.str]]
        """
        The classification id
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        semantic_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The semantic type id
        """
elif False:
    DatabaseCatalogSchemaTableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseCatalogSchemaTableColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 classification: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 semantic_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] classification: The classification id
        :param pulumi.Input[builtins.str] semantic_type: The semantic type id
        """
        pulumi.set(__self__, "name", name)
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if semantic_type is not None:
            pulumi.set(__self__, "semantic_type", semantic_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def classification(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The classification id
        """
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "classification", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The semantic type id
        """
        return pulumi.get(self, "semantic_type")

    @semantic_type.setter
    def semantic_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "semantic_type", value)


if not MYPY:
    class GroupMemberArgsDict(TypedDict):
        member: pulumi.Input[builtins.str]
        """
        The member in users/{email} format.
        """
        role: pulumi.Input[builtins.str]
        """
        The member's role in the group, should be OWNER or MEMBER.
        """
elif False:
    GroupMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupMemberArgs:
    def __init__(__self__, *,
                 member: pulumi.Input[builtins.str],
                 role: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] member: The member in users/{email} format.
        :param pulumi.Input[builtins.str] role: The member's role in the group, should be OWNER or MEMBER.
        """
        pulumi.set(__self__, "member", member)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def member(self) -> pulumi.Input[builtins.str]:
        """
        The member in users/{email} format.
        """
        return pulumi.get(self, "member")

    @member.setter
    def member(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "member", value)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[builtins.str]:
        """
        The member's role in the group, should be OWNER or MEMBER.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role", value)


if not MYPY:
    class InstanceDataSourceArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        """
        Host or socket for your instance, or the account name if the instance type is Snowflake.
        """
        id: pulumi.Input[builtins.str]
        """
        The unique data source id in this instance.
        """
        port: pulumi.Input[builtins.str]
        """
        The port for your instance.
        """
        type: pulumi.Input[builtins.str]
        """
        The data source type. Should be ADMIN or READ_ONLY.
        """
        database: NotRequired[pulumi.Input[builtins.str]]
        """
        The database for the instance, you can set this if the engine type is POSTGRES.
        """
        external_secret: NotRequired[pulumi.Input['InstanceDataSourceExternalSecretArgsDict']]
        """
        The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        The connection user password used by Bytebase to perform DDL and DML operations.
        """
        ssl_ca: NotRequired[pulumi.Input[builtins.str]]
        """
        The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        ssl_cert: NotRequired[pulumi.Input[builtins.str]]
        """
        The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        ssl_key: NotRequired[pulumi.Input[builtins.str]]
        """
        The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        use_ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable SSL connection. Required to use SSL certificates.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        The connection user name used by Bytebase to perform DDL and DML operations.
        """
elif False:
    InstanceDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDataSourceArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 id: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 database: Optional[pulumi.Input[builtins.str]] = None,
                 external_secret: Optional[pulumi.Input['InstanceDataSourceExternalSecretArgs']] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_ca: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_key: Optional[pulumi.Input[builtins.str]] = None,
                 use_ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] host: Host or socket for your instance, or the account name if the instance type is Snowflake.
        :param pulumi.Input[builtins.str] id: The unique data source id in this instance.
        :param pulumi.Input[builtins.str] port: The port for your instance.
        :param pulumi.Input[builtins.str] type: The data source type. Should be ADMIN or READ_ONLY.
        :param pulumi.Input[builtins.str] database: The database for the instance, you can set this if the engine type is POSTGRES.
        :param pulumi.Input['InstanceDataSourceExternalSecretArgs'] external_secret: The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
        :param pulumi.Input[builtins.str] password: The connection user password used by Bytebase to perform DDL and DML operations.
        :param pulumi.Input[builtins.str] ssl_ca: The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        :param pulumi.Input[builtins.str] ssl_cert: The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        :param pulumi.Input[builtins.str] ssl_key: The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        :param pulumi.Input[builtins.bool] use_ssl: Enable SSL connection. Required to use SSL certificates.
        :param pulumi.Input[builtins.str] username: The connection user name used by Bytebase to perform DDL and DML operations.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if external_secret is not None:
            pulumi.set(__self__, "external_secret", external_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssl_ca is not None:
            pulumi.set(__self__, "ssl_ca", ssl_ca)
        if ssl_cert is not None:
            pulumi.set(__self__, "ssl_cert", ssl_cert)
        if ssl_key is not None:
            pulumi.set(__self__, "ssl_key", ssl_key)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        Host or socket for your instance, or the account name if the instance type is Snowflake.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The unique data source id in this instance.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.str]:
        """
        The port for your instance.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The data source type. Should be ADMIN or READ_ONLY.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The database for the instance, you can set this if the engine type is POSTGRES.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="externalSecret")
    def external_secret(self) -> Optional[pulumi.Input['InstanceDataSourceExternalSecretArgs']]:
        """
        The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
        """
        return pulumi.get(self, "external_secret")

    @external_secret.setter
    def external_secret(self, value: Optional[pulumi.Input['InstanceDataSourceExternalSecretArgs']]):
        pulumi.set(self, "external_secret", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The connection user password used by Bytebase to perform DDL and DML operations.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sslCa")
    def ssl_ca(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        return pulumi.get(self, "ssl_ca")

    @ssl_ca.setter
    def ssl_ca(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_ca", value)

    @property
    @pulumi.getter(name="sslCert")
    def ssl_cert(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        return pulumi.get(self, "ssl_cert")

    @ssl_cert.setter
    def ssl_cert(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert", value)

    @property
    @pulumi.getter(name="sslKey")
    def ssl_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        return pulumi.get(self, "ssl_key")

    @ssl_key.setter
    def ssl_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_key", value)

    @property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable SSL connection. Required to use SSL certificates.
        """
        return pulumi.get(self, "use_ssl")

    @use_ssl.setter
    def use_ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The connection user name used by Bytebase to perform DDL and DML operations.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class InstanceDataSourceExternalSecretArgsDict(TypedDict):
        aws_secrets_manager: NotRequired[pulumi.Input['InstanceDataSourceExternalSecretAwsSecretsManagerArgsDict']]
        """
        The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
        """
        gcp_secret_manager: NotRequired[pulumi.Input['InstanceDataSourceExternalSecretGcpSecretManagerArgsDict']]
        """
        The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
        """
        vault: NotRequired[pulumi.Input['InstanceDataSourceExternalSecretVaultArgsDict']]
elif False:
    InstanceDataSourceExternalSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDataSourceExternalSecretArgs:
    def __init__(__self__, *,
                 aws_secrets_manager: Optional[pulumi.Input['InstanceDataSourceExternalSecretAwsSecretsManagerArgs']] = None,
                 gcp_secret_manager: Optional[pulumi.Input['InstanceDataSourceExternalSecretGcpSecretManagerArgs']] = None,
                 vault: Optional[pulumi.Input['InstanceDataSourceExternalSecretVaultArgs']] = None):
        """
        :param pulumi.Input['InstanceDataSourceExternalSecretAwsSecretsManagerArgs'] aws_secrets_manager: The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
        :param pulumi.Input['InstanceDataSourceExternalSecretGcpSecretManagerArgs'] gcp_secret_manager: The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
        """
        if aws_secrets_manager is not None:
            pulumi.set(__self__, "aws_secrets_manager", aws_secrets_manager)
        if gcp_secret_manager is not None:
            pulumi.set(__self__, "gcp_secret_manager", gcp_secret_manager)
        if vault is not None:
            pulumi.set(__self__, "vault", vault)

    @property
    @pulumi.getter(name="awsSecretsManager")
    def aws_secrets_manager(self) -> Optional[pulumi.Input['InstanceDataSourceExternalSecretAwsSecretsManagerArgs']]:
        """
        The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
        """
        return pulumi.get(self, "aws_secrets_manager")

    @aws_secrets_manager.setter
    def aws_secrets_manager(self, value: Optional[pulumi.Input['InstanceDataSourceExternalSecretAwsSecretsManagerArgs']]):
        pulumi.set(self, "aws_secrets_manager", value)

    @property
    @pulumi.getter(name="gcpSecretManager")
    def gcp_secret_manager(self) -> Optional[pulumi.Input['InstanceDataSourceExternalSecretGcpSecretManagerArgs']]:
        """
        The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
        """
        return pulumi.get(self, "gcp_secret_manager")

    @gcp_secret_manager.setter
    def gcp_secret_manager(self, value: Optional[pulumi.Input['InstanceDataSourceExternalSecretGcpSecretManagerArgs']]):
        pulumi.set(self, "gcp_secret_manager", value)

    @property
    @pulumi.getter
    def vault(self) -> Optional[pulumi.Input['InstanceDataSourceExternalSecretVaultArgs']]:
        return pulumi.get(self, "vault")

    @vault.setter
    def vault(self, value: Optional[pulumi.Input['InstanceDataSourceExternalSecretVaultArgs']]):
        pulumi.set(self, "vault", value)


if not MYPY:
    class InstanceDataSourceExternalSecretAwsSecretsManagerArgsDict(TypedDict):
        password_key_name: pulumi.Input[builtins.str]
        """
        The key name for the password.
        """
        secret_name: pulumi.Input[builtins.str]
        """
        The secret name to store the password.
        """
elif False:
    InstanceDataSourceExternalSecretAwsSecretsManagerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDataSourceExternalSecretAwsSecretsManagerArgs:
    def __init__(__self__, *,
                 password_key_name: pulumi.Input[builtins.str],
                 secret_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] password_key_name: The key name for the password.
        :param pulumi.Input[builtins.str] secret_name: The secret name to store the password.
        """
        pulumi.set(__self__, "password_key_name", password_key_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="passwordKeyName")
    def password_key_name(self) -> pulumi.Input[builtins.str]:
        """
        The key name for the password.
        """
        return pulumi.get(self, "password_key_name")

    @password_key_name.setter
    def password_key_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_key_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[builtins.str]:
        """
        The secret name to store the password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class InstanceDataSourceExternalSecretGcpSecretManagerArgsDict(TypedDict):
        secret_name: pulumi.Input[builtins.str]
        """
        The secret name should be like "projects/{project-id}/secrets/{secret-id}".
        """
elif False:
    InstanceDataSourceExternalSecretGcpSecretManagerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDataSourceExternalSecretGcpSecretManagerArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] secret_name: The secret name should be like "projects/{project-id}/secrets/{secret-id}".
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[builtins.str]:
        """
        The secret name should be like "projects/{project-id}/secrets/{secret-id}".
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class InstanceDataSourceExternalSecretVaultArgsDict(TypedDict):
        engine_name: pulumi.Input[builtins.str]
        """
        The name for secret engine.
        """
        password_key_name: pulumi.Input[builtins.str]
        """
        The key name for the password.
        """
        secret_name: pulumi.Input[builtins.str]
        """
        The secret name in the engine to store the password.
        """
        url: pulumi.Input[builtins.str]
        """
        The Vault URL.
        """
        app_role: NotRequired[pulumi.Input['InstanceDataSourceExternalSecretVaultAppRoleArgsDict']]
        """
        The Vault app role to get the password.
        """
        token: NotRequired[pulumi.Input[builtins.str]]
elif False:
    InstanceDataSourceExternalSecretVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDataSourceExternalSecretVaultArgs:
    def __init__(__self__, *,
                 engine_name: pulumi.Input[builtins.str],
                 password_key_name: pulumi.Input[builtins.str],
                 secret_name: pulumi.Input[builtins.str],
                 url: pulumi.Input[builtins.str],
                 app_role: Optional[pulumi.Input['InstanceDataSourceExternalSecretVaultAppRoleArgs']] = None,
                 token: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] engine_name: The name for secret engine.
        :param pulumi.Input[builtins.str] password_key_name: The key name for the password.
        :param pulumi.Input[builtins.str] secret_name: The secret name in the engine to store the password.
        :param pulumi.Input[builtins.str] url: The Vault URL.
        :param pulumi.Input['InstanceDataSourceExternalSecretVaultAppRoleArgs'] app_role: The Vault app role to get the password.
        """
        pulumi.set(__self__, "engine_name", engine_name)
        pulumi.set(__self__, "password_key_name", password_key_name)
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "url", url)
        if app_role is not None:
            pulumi.set(__self__, "app_role", app_role)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="engineName")
    def engine_name(self) -> pulumi.Input[builtins.str]:
        """
        The name for secret engine.
        """
        return pulumi.get(self, "engine_name")

    @engine_name.setter
    def engine_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "engine_name", value)

    @property
    @pulumi.getter(name="passwordKeyName")
    def password_key_name(self) -> pulumi.Input[builtins.str]:
        """
        The key name for the password.
        """
        return pulumi.get(self, "password_key_name")

    @password_key_name.setter
    def password_key_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_key_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[builtins.str]:
        """
        The secret name in the engine to store the password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[builtins.str]:
        """
        The Vault URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="appRole")
    def app_role(self) -> Optional[pulumi.Input['InstanceDataSourceExternalSecretVaultAppRoleArgs']]:
        """
        The Vault app role to get the password.
        """
        return pulumi.get(self, "app_role")

    @app_role.setter
    def app_role(self, value: Optional[pulumi.Input['InstanceDataSourceExternalSecretVaultAppRoleArgs']]):
        pulumi.set(self, "app_role", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class InstanceDataSourceExternalSecretVaultAppRoleArgsDict(TypedDict):
        role_id: pulumi.Input[builtins.str]
        """
        The app role id.
        """
        secret: pulumi.Input[builtins.str]
        """
        The secret id for the role without ttl.
        """
        secret_type: pulumi.Input[builtins.str]
        """
        The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
        """
elif False:
    InstanceDataSourceExternalSecretVaultAppRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDataSourceExternalSecretVaultAppRoleArgs:
    def __init__(__self__, *,
                 role_id: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 secret_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] role_id: The app role id.
        :param pulumi.Input[builtins.str] secret: The secret id for the role without ttl.
        :param pulumi.Input[builtins.str] secret_type: The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
        """
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "secret_type", secret_type)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[builtins.str]:
        """
        The app role id.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        """
        The secret id for the role without ttl.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> pulumi.Input[builtins.str]:
        """
        The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
        """
        return pulumi.get(self, "secret_type")

    @secret_type.setter
    def secret_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_type", value)


if not MYPY:
    class PolicyDataSourceQueryPolicyArgsDict(TypedDict):
        disallow_ddl: NotRequired[pulumi.Input[builtins.bool]]
        """
        Disallow running DDL statements in the SQL editor.
        """
        disallow_dml: NotRequired[pulumi.Input[builtins.bool]]
        """
        Disallow running DML statements in the SQL editor.
        """
        restriction: NotRequired[pulumi.Input[builtins.str]]
        """
        RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
elif False:
    PolicyDataSourceQueryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyDataSourceQueryPolicyArgs:
    def __init__(__self__, *,
                 disallow_ddl: Optional[pulumi.Input[builtins.bool]] = None,
                 disallow_dml: Optional[pulumi.Input[builtins.bool]] = None,
                 restriction: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disallow_ddl: Disallow running DDL statements in the SQL editor.
        :param pulumi.Input[builtins.bool] disallow_dml: Disallow running DML statements in the SQL editor.
        :param pulumi.Input[builtins.str] restriction: RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        if disallow_ddl is not None:
            pulumi.set(__self__, "disallow_ddl", disallow_ddl)
        if disallow_dml is not None:
            pulumi.set(__self__, "disallow_dml", disallow_dml)
        if restriction is not None:
            pulumi.set(__self__, "restriction", restriction)

    @property
    @pulumi.getter(name="disallowDdl")
    def disallow_ddl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disallow running DDL statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_ddl")

    @disallow_ddl.setter
    def disallow_ddl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disallow_ddl", value)

    @property
    @pulumi.getter(name="disallowDml")
    def disallow_dml(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disallow running DML statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_dml")

    @disallow_dml.setter
    def disallow_dml(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disallow_dml", value)

    @property
    @pulumi.getter
    def restriction(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        return pulumi.get(self, "restriction")

    @restriction.setter
    def restriction(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restriction", value)


if not MYPY:
    class PolicyDisableCopyDataPolicyArgsDict(TypedDict):
        enable: pulumi.Input[builtins.bool]
        """
        Restrict data copying
        """
elif False:
    PolicyDisableCopyDataPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyDisableCopyDataPolicyArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enable: Restrict data copying
        """
        pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> pulumi.Input[builtins.bool]:
        """
        Restrict data copying
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class PolicyGlobalMaskingPolicyArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicyGlobalMaskingPolicyRuleArgsDict']]]]
elif False:
    PolicyGlobalMaskingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyGlobalMaskingPolicyArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyGlobalMaskingPolicyRuleArgs']]]] = None):
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicyGlobalMaskingPolicyRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyGlobalMaskingPolicyRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class PolicyGlobalMaskingPolicyRuleArgsDict(TypedDict):
        condition: pulumi.Input[builtins.str]
        """
        The condition expression
        """
        id: pulumi.Input[builtins.str]
        """
        The unique rule id
        """
        semantic_type: pulumi.Input[builtins.str]
        """
        The semantic type id
        """
        title: NotRequired[pulumi.Input[builtins.str]]
        """
        The title for the rule
        """
elif False:
    PolicyGlobalMaskingPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyGlobalMaskingPolicyRuleArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[builtins.str],
                 id: pulumi.Input[builtins.str],
                 semantic_type: pulumi.Input[builtins.str],
                 title: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] condition: The condition expression
        :param pulumi.Input[builtins.str] id: The unique rule id
        :param pulumi.Input[builtins.str] semantic_type: The semantic type id
        :param pulumi.Input[builtins.str] title: The title for the rule
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "semantic_type", semantic_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[builtins.str]:
        """
        The condition expression
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The unique rule id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> pulumi.Input[builtins.str]:
        """
        The semantic type id
        """
        return pulumi.get(self, "semantic_type")

    @semantic_type.setter
    def semantic_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "semantic_type", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The title for the rule
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class PolicyMaskingExceptionPolicyArgsDict(TypedDict):
        exceptions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicyMaskingExceptionPolicyExceptionArgsDict']]]]
elif False:
    PolicyMaskingExceptionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyMaskingExceptionPolicyArgs:
    def __init__(__self__, *,
                 exceptions: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyMaskingExceptionPolicyExceptionArgs']]]] = None):
        if exceptions is not None:
            pulumi.set(__self__, "exceptions", exceptions)

    @property
    @pulumi.getter
    def exceptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicyMaskingExceptionPolicyExceptionArgs']]]]:
        return pulumi.get(self, "exceptions")

    @exceptions.setter
    def exceptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyMaskingExceptionPolicyExceptionArgs']]]]):
        pulumi.set(self, "exceptions", value)


if not MYPY:
    class PolicyMaskingExceptionPolicyExceptionArgsDict(TypedDict):
        action: pulumi.Input[builtins.str]
        database: pulumi.Input[builtins.str]
        """
        The database full name in instances/{instance resource id}/databases/{database name} format
        """
        member: pulumi.Input[builtins.str]
        """
        The member in user:{email} or group:{email} format.
        """
        column: NotRequired[pulumi.Input[builtins.str]]
        expire_timestamp: NotRequired[pulumi.Input[builtins.str]]
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        """
        reason: NotRequired[pulumi.Input[builtins.str]]
        """
        The reason for the masking exemption
        """
        schema: NotRequired[pulumi.Input[builtins.str]]
        table: NotRequired[pulumi.Input[builtins.str]]
elif False:
    PolicyMaskingExceptionPolicyExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyMaskingExceptionPolicyExceptionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[builtins.str],
                 database: pulumi.Input[builtins.str],
                 member: pulumi.Input[builtins.str],
                 column: Optional[pulumi.Input[builtins.str]] = None,
                 expire_timestamp: Optional[pulumi.Input[builtins.str]] = None,
                 reason: Optional[pulumi.Input[builtins.str]] = None,
                 schema: Optional[pulumi.Input[builtins.str]] = None,
                 table: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] database: The database full name in instances/{instance resource id}/databases/{database name} format
        :param pulumi.Input[builtins.str] member: The member in user:{email} or group:{email} format.
        :param pulumi.Input[builtins.str] expire_timestamp: The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        :param pulumi.Input[builtins.str] reason: The reason for the masking exemption
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "member", member)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if expire_timestamp is not None:
            pulumi.set(__self__, "expire_timestamp", expire_timestamp)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database full name in instances/{instance resource id}/databases/{database name} format
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def member(self) -> pulumi.Input[builtins.str]:
        """
        The member in user:{email} or group:{email} format.
        """
        return pulumi.get(self, "member")

    @member.setter
    def member(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "member", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="expireTimestamp")
    def expire_timestamp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        """
        return pulumi.get(self, "expire_timestamp")

    @expire_timestamp.setter
    def expire_timestamp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expire_timestamp", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reason for the masking exemption
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "table", value)


if not MYPY:
    class PolicyRolloutPolicyArgsDict(TypedDict):
        automatic: NotRequired[pulumi.Input[builtins.bool]]
        """
        If all check pass, the change will be rolled out and executed automatically.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
elif False:
    PolicyRolloutPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyRolloutPolicyArgs:
    def __init__(__self__, *,
                 automatic: Optional[pulumi.Input[builtins.bool]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] automatic: If all check pass, the change will be rolled out and executed automatically.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] roles: If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def automatic(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If all check pass, the change will be rolled out and executed automatically.
        """
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class ProjectWebhookArgsDict(TypedDict):
        notification_types: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        """
        title: pulumi.Input[builtins.str]
        """
        The webhook title
        """
        type: pulumi.Input[builtins.str]
        """
        The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        """
        url: pulumi.Input[builtins.str]
        """
        The webhook URL
        """
        direct_message: NotRequired[pulumi.Input[builtins.bool]]
        """
        If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The webhook full name in projects/{resource id}/webhooks/{id} format.
        """
elif False:
    ProjectWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectWebhookArgs:
    def __init__(__self__, *,
                 notification_types: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 title: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 url: pulumi.Input[builtins.str],
                 direct_message: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] notification_types: notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        :param pulumi.Input[builtins.str] title: The webhook title
        :param pulumi.Input[builtins.str] type: The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        :param pulumi.Input[builtins.str] url: The webhook URL
        :param pulumi.Input[builtins.bool] direct_message: If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        :param pulumi.Input[builtins.str] name: The webhook full name in projects/{resource id}/webhooks/{id} format.
        """
        pulumi.set(__self__, "notification_types", notification_types)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if direct_message is not None:
            pulumi.set(__self__, "direct_message", direct_message)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        """
        return pulumi.get(self, "notification_types")

    @notification_types.setter
    def notification_types(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "notification_types", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        The webhook title
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[builtins.str]:
        """
        The webhook URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="directMessage")
    def direct_message(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        """
        return pulumi.get(self, "direct_message")

    @direct_message.setter
    def direct_message(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "direct_message", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The webhook full name in projects/{resource id}/webhooks/{id} format.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SettingApprovalFlowArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleArgsDict']]]
elif False:
    SettingApprovalFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingApprovalFlowArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleArgs']]]):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleArgs']]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class SettingApprovalFlowRuleArgsDict(TypedDict):
        flows: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowArgsDict']]]
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleConditionArgsDict']]]]
        """
        Match any condition will trigger this approval flow.
        """
elif False:
    SettingApprovalFlowRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingApprovalFlowRuleArgs:
    def __init__(__self__, *,
                 flows: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowArgs']]],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleConditionArgs']]] conditions: Match any condition will trigger this approval flow.
        """
        pulumi.set(__self__, "flows", flows)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def flows(self) -> pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowArgs']]]:
        return pulumi.get(self, "flows")

    @flows.setter
    def flows(self, value: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowArgs']]]):
        pulumi.set(self, "flows", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleConditionArgs']]]]:
        """
        Match any condition will trigger this approval flow.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class SettingApprovalFlowRuleConditionArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[builtins.str]]
        source: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SettingApprovalFlowRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingApprovalFlowRuleConditionArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class SettingApprovalFlowRuleFlowArgsDict(TypedDict):
        steps: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowStepArgsDict']]]
        """
        Approval flow following the step order.
        """
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SettingApprovalFlowRuleFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingApprovalFlowRuleFlowArgs:
    def __init__(__self__, *,
                 steps: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowStepArgs']]],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowStepArgs']]] steps: Approval flow following the step order.
        """
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowStepArgs']]]:
        """
        Approval flow following the step order.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['SettingApprovalFlowRuleFlowStepArgs']]]):
        pulumi.set(self, "steps", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SettingApprovalFlowRuleFlowStepArgsDict(TypedDict):
        role: pulumi.Input[builtins.str]
        """
        The role require to review in this step
        """
elif False:
    SettingApprovalFlowRuleFlowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingApprovalFlowRuleFlowStepArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] role: The role require to review in this step
        """
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[builtins.str]:
        """
        The role require to review in this step
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role", value)


if not MYPY:
    class SettingClassificationArgsDict(TypedDict):
        classifications: pulumi.Input[Sequence[pulumi.Input['SettingClassificationClassificationArgsDict']]]
        id: pulumi.Input[builtins.str]
        """
        The classification unique uuid.
        """
        levels: pulumi.Input[Sequence[pulumi.Input['SettingClassificationLevelArgsDict']]]
        title: pulumi.Input[builtins.str]
        """
        The classification title. Optional.
        """
        classification_from_config: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
elif False:
    SettingClassificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingClassificationArgs:
    def __init__(__self__, *,
                 classifications: pulumi.Input[Sequence[pulumi.Input['SettingClassificationClassificationArgs']]],
                 id: pulumi.Input[builtins.str],
                 levels: pulumi.Input[Sequence[pulumi.Input['SettingClassificationLevelArgs']]],
                 title: pulumi.Input[builtins.str],
                 classification_from_config: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] id: The classification unique uuid.
        :param pulumi.Input[builtins.str] title: The classification title. Optional.
        :param pulumi.Input[builtins.bool] classification_from_config: If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
        pulumi.set(__self__, "classifications", classifications)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "title", title)
        if classification_from_config is not None:
            pulumi.set(__self__, "classification_from_config", classification_from_config)

    @property
    @pulumi.getter
    def classifications(self) -> pulumi.Input[Sequence[pulumi.Input['SettingClassificationClassificationArgs']]]:
        return pulumi.get(self, "classifications")

    @classifications.setter
    def classifications(self, value: pulumi.Input[Sequence[pulumi.Input['SettingClassificationClassificationArgs']]]):
        pulumi.set(self, "classifications", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The classification unique uuid.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def levels(self) -> pulumi.Input[Sequence[pulumi.Input['SettingClassificationLevelArgs']]]:
        return pulumi.get(self, "levels")

    @levels.setter
    def levels(self, value: pulumi.Input[Sequence[pulumi.Input['SettingClassificationLevelArgs']]]):
        pulumi.set(self, "levels", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        The classification title. Optional.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="classificationFromConfig")
    def classification_from_config(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
        return pulumi.get(self, "classification_from_config")

    @classification_from_config.setter
    def classification_from_config(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "classification_from_config", value)


if not MYPY:
    class SettingClassificationClassificationArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The classification unique id, must in {number}-{number} format.
        """
        title: pulumi.Input[builtins.str]
        """
        The classification title.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The classification description.
        """
        level: NotRequired[pulumi.Input[builtins.str]]
        """
        The classification level id.
        """
elif False:
    SettingClassificationClassificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingClassificationClassificationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 level: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: The classification unique id, must in {number}-{number} format.
        :param pulumi.Input[builtins.str] title: The classification title.
        :param pulumi.Input[builtins.str] description: The classification description.
        :param pulumi.Input[builtins.str] level: The classification level id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The classification unique id, must in {number}-{number} format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        The classification title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The classification description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The classification level id.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class SettingClassificationLevelArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The classification level unique uuid.
        """
        title: pulumi.Input[builtins.str]
        """
        The classification level title.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The classification level description.
        """
elif False:
    SettingClassificationLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingClassificationLevelArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: The classification level unique uuid.
        :param pulumi.Input[builtins.str] title: The classification level title.
        :param pulumi.Input[builtins.str] description: The classification level description.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The classification level unique uuid.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        The classification level title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The classification level description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SettingEnvironmentSettingArgsDict(TypedDict):
        environments: pulumi.Input[Sequence[pulumi.Input['SettingEnvironmentSettingEnvironmentArgsDict']]]
elif False:
    SettingEnvironmentSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingEnvironmentSettingArgs:
    def __init__(__self__, *,
                 environments: pulumi.Input[Sequence[pulumi.Input['SettingEnvironmentSettingEnvironmentArgs']]]):
        pulumi.set(__self__, "environments", environments)

    @property
    @pulumi.getter
    def environments(self) -> pulumi.Input[Sequence[pulumi.Input['SettingEnvironmentSettingEnvironmentArgs']]]:
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: pulumi.Input[Sequence[pulumi.Input['SettingEnvironmentSettingEnvironmentArgs']]]):
        pulumi.set(self, "environments", value)


if not MYPY:
    class SettingEnvironmentSettingEnvironmentArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The environment unique id.
        """
        title: pulumi.Input[builtins.str]
        """
        The environment display name.
        """
        color: NotRequired[pulumi.Input[builtins.str]]
        """
        The environment color.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The environment readonly name in environments/{id} format.
        """
        protected: NotRequired[pulumi.Input[builtins.bool]]
        """
        The environment is protected or not.
        """
elif False:
    SettingEnvironmentSettingEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingEnvironmentSettingEnvironmentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 color: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 protected: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] id: The environment unique id.
        :param pulumi.Input[builtins.str] title: The environment display name.
        :param pulumi.Input[builtins.str] color: The environment color.
        :param pulumi.Input[builtins.str] name: The environment readonly name in environments/{id} format.
        :param pulumi.Input[builtins.bool] protected: The environment is protected or not.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protected is not None:
            pulumi.set(__self__, "protected", protected)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The environment unique id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        The environment display name.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The environment color.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The environment readonly name in environments/{id} format.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def protected(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The environment is protected or not.
        """
        return pulumi.get(self, "protected")

    @protected.setter
    def protected(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "protected", value)


if not MYPY:
    class SettingPasswordRestrictionArgsDict(TypedDict):
        min_length: NotRequired[pulumi.Input[builtins.int]]
        """
        min_length is the minimum length for password, should no less than 8.
        """
        password_rotation_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        """
        require_letter: NotRequired[pulumi.Input[builtins.bool]]
        """
        require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        """
        require_number: NotRequired[pulumi.Input[builtins.bool]]
        """
        require_number requires the password must contains at least one number.
        """
        require_reset_password_for_first_login: NotRequired[pulumi.Input[builtins.bool]]
        """
        require*reset*password*for*first_login requires users to reset their password after the 1st login.
        """
        require_special_character: NotRequired[pulumi.Input[builtins.bool]]
        """
        require*special*character requires the password must contains at least one special character.
        """
        require_uppercase_letter: NotRequired[pulumi.Input[builtins.bool]]
        """
        require*uppercase*letter requires the password must contains at least one upper case letter.
        """
elif False:
    SettingPasswordRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingPasswordRestrictionArgs:
    def __init__(__self__, *,
                 min_length: Optional[pulumi.Input[builtins.int]] = None,
                 password_rotation_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 require_letter: Optional[pulumi.Input[builtins.bool]] = None,
                 require_number: Optional[pulumi.Input[builtins.bool]] = None,
                 require_reset_password_for_first_login: Optional[pulumi.Input[builtins.bool]] = None,
                 require_special_character: Optional[pulumi.Input[builtins.bool]] = None,
                 require_uppercase_letter: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] min_length: min_length is the minimum length for password, should no less than 8.
        :param pulumi.Input[builtins.int] password_rotation_in_seconds: password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        :param pulumi.Input[builtins.bool] require_letter: require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        :param pulumi.Input[builtins.bool] require_number: require_number requires the password must contains at least one number.
        :param pulumi.Input[builtins.bool] require_reset_password_for_first_login: require*reset*password*for*first_login requires users to reset their password after the 1st login.
        :param pulumi.Input[builtins.bool] require_special_character: require*special*character requires the password must contains at least one special character.
        :param pulumi.Input[builtins.bool] require_uppercase_letter: require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if password_rotation_in_seconds is not None:
            pulumi.set(__self__, "password_rotation_in_seconds", password_rotation_in_seconds)
        if require_letter is not None:
            pulumi.set(__self__, "require_letter", require_letter)
        if require_number is not None:
            pulumi.set(__self__, "require_number", require_number)
        if require_reset_password_for_first_login is not None:
            pulumi.set(__self__, "require_reset_password_for_first_login", require_reset_password_for_first_login)
        if require_special_character is not None:
            pulumi.set(__self__, "require_special_character", require_special_character)
        if require_uppercase_letter is not None:
            pulumi.set(__self__, "require_uppercase_letter", require_uppercase_letter)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        min_length is the minimum length for password, should no less than 8.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="passwordRotationInSeconds")
    def password_rotation_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        """
        return pulumi.get(self, "password_rotation_in_seconds")

    @password_rotation_in_seconds.setter
    def password_rotation_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "password_rotation_in_seconds", value)

    @property
    @pulumi.getter(name="requireLetter")
    def require_letter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        """
        return pulumi.get(self, "require_letter")

    @require_letter.setter
    def require_letter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_letter", value)

    @property
    @pulumi.getter(name="requireNumber")
    def require_number(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        require_number requires the password must contains at least one number.
        """
        return pulumi.get(self, "require_number")

    @require_number.setter
    def require_number(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_number", value)

    @property
    @pulumi.getter(name="requireResetPasswordForFirstLogin")
    def require_reset_password_for_first_login(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        require*reset*password*for*first_login requires users to reset their password after the 1st login.
        """
        return pulumi.get(self, "require_reset_password_for_first_login")

    @require_reset_password_for_first_login.setter
    def require_reset_password_for_first_login(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_reset_password_for_first_login", value)

    @property
    @pulumi.getter(name="requireSpecialCharacter")
    def require_special_character(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        require*special*character requires the password must contains at least one special character.
        """
        return pulumi.get(self, "require_special_character")

    @require_special_character.setter
    def require_special_character(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_special_character", value)

    @property
    @pulumi.getter(name="requireUppercaseLetter")
    def require_uppercase_letter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        return pulumi.get(self, "require_uppercase_letter")

    @require_uppercase_letter.setter
    def require_uppercase_letter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_uppercase_letter", value)


if not MYPY:
    class SettingSemanticTypeArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The semantic type unique uuid.
        """
        title: pulumi.Input[builtins.str]
        """
        The semantic type title. Required.
        """
        algorithm: NotRequired[pulumi.Input['SettingSemanticTypeAlgorithmArgsDict']]
        """
        The semantic type algorithm. Required.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The semantic type description. Optional.
        """
elif False:
    SettingSemanticTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSemanticTypeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 algorithm: Optional[pulumi.Input['SettingSemanticTypeAlgorithmArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: The semantic type unique uuid.
        :param pulumi.Input[builtins.str] title: The semantic type title. Required.
        :param pulumi.Input['SettingSemanticTypeAlgorithmArgs'] algorithm: The semantic type algorithm. Required.
        :param pulumi.Input[builtins.str] description: The semantic type description. Optional.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The semantic type unique uuid.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        The semantic type title. Required.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input['SettingSemanticTypeAlgorithmArgs']]:
        """
        The semantic type algorithm. Required.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input['SettingSemanticTypeAlgorithmArgs']]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The semantic type description. Optional.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SettingSemanticTypeAlgorithmArgsDict(TypedDict):
        full_mask: NotRequired[pulumi.Input['SettingSemanticTypeAlgorithmFullMaskArgsDict']]
        inner_outer_mask: NotRequired[pulumi.Input['SettingSemanticTypeAlgorithmInnerOuterMaskArgsDict']]
        md5_mask: NotRequired[pulumi.Input['SettingSemanticTypeAlgorithmMd5MaskArgsDict']]
        range_mask: NotRequired[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskArgsDict']]
elif False:
    SettingSemanticTypeAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSemanticTypeAlgorithmArgs:
    def __init__(__self__, *,
                 full_mask: Optional[pulumi.Input['SettingSemanticTypeAlgorithmFullMaskArgs']] = None,
                 inner_outer_mask: Optional[pulumi.Input['SettingSemanticTypeAlgorithmInnerOuterMaskArgs']] = None,
                 md5_mask: Optional[pulumi.Input['SettingSemanticTypeAlgorithmMd5MaskArgs']] = None,
                 range_mask: Optional[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskArgs']] = None):
        if full_mask is not None:
            pulumi.set(__self__, "full_mask", full_mask)
        if inner_outer_mask is not None:
            pulumi.set(__self__, "inner_outer_mask", inner_outer_mask)
        if md5_mask is not None:
            pulumi.set(__self__, "md5_mask", md5_mask)
        if range_mask is not None:
            pulumi.set(__self__, "range_mask", range_mask)

    @property
    @pulumi.getter(name="fullMask")
    def full_mask(self) -> Optional[pulumi.Input['SettingSemanticTypeAlgorithmFullMaskArgs']]:
        return pulumi.get(self, "full_mask")

    @full_mask.setter
    def full_mask(self, value: Optional[pulumi.Input['SettingSemanticTypeAlgorithmFullMaskArgs']]):
        pulumi.set(self, "full_mask", value)

    @property
    @pulumi.getter(name="innerOuterMask")
    def inner_outer_mask(self) -> Optional[pulumi.Input['SettingSemanticTypeAlgorithmInnerOuterMaskArgs']]:
        return pulumi.get(self, "inner_outer_mask")

    @inner_outer_mask.setter
    def inner_outer_mask(self, value: Optional[pulumi.Input['SettingSemanticTypeAlgorithmInnerOuterMaskArgs']]):
        pulumi.set(self, "inner_outer_mask", value)

    @property
    @pulumi.getter(name="md5Mask")
    def md5_mask(self) -> Optional[pulumi.Input['SettingSemanticTypeAlgorithmMd5MaskArgs']]:
        return pulumi.get(self, "md5_mask")

    @md5_mask.setter
    def md5_mask(self, value: Optional[pulumi.Input['SettingSemanticTypeAlgorithmMd5MaskArgs']]):
        pulumi.set(self, "md5_mask", value)

    @property
    @pulumi.getter(name="rangeMask")
    def range_mask(self) -> Optional[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskArgs']]:
        return pulumi.get(self, "range_mask")

    @range_mask.setter
    def range_mask(self, value: Optional[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskArgs']]):
        pulumi.set(self, "range_mask", value)


if not MYPY:
    class SettingSemanticTypeAlgorithmFullMaskArgsDict(TypedDict):
        substitution: pulumi.Input[builtins.str]
        """
        Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
elif False:
    SettingSemanticTypeAlgorithmFullMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSemanticTypeAlgorithmFullMaskArgs:
    def __init__(__self__, *,
                 substitution: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] substitution: Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter
    def substitution(self) -> pulumi.Input[builtins.str]:
        """
        Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "substitution", value)


if not MYPY:
    class SettingSemanticTypeAlgorithmInnerOuterMaskArgsDict(TypedDict):
        prefix_len: pulumi.Input[builtins.int]
        """
        The length of prefix.
        """
        substitution: pulumi.Input[builtins.str]
        """
        Substitution is the string used to replace the inner or outer substring.
        """
        suffix_len: pulumi.Input[builtins.int]
        """
        The length of suffix.
        """
        type: pulumi.Input[builtins.str]
        """
        INNER or OUTER.
        """
elif False:
    SettingSemanticTypeAlgorithmInnerOuterMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSemanticTypeAlgorithmInnerOuterMaskArgs:
    def __init__(__self__, *,
                 prefix_len: pulumi.Input[builtins.int],
                 substitution: pulumi.Input[builtins.str],
                 suffix_len: pulumi.Input[builtins.int],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.int] prefix_len: The length of prefix.
        :param pulumi.Input[builtins.str] substitution: Substitution is the string used to replace the inner or outer substring.
        :param pulumi.Input[builtins.int] suffix_len: The length of suffix.
        :param pulumi.Input[builtins.str] type: INNER or OUTER.
        """
        pulumi.set(__self__, "prefix_len", prefix_len)
        pulumi.set(__self__, "substitution", substitution)
        pulumi.set(__self__, "suffix_len", suffix_len)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="prefixLen")
    def prefix_len(self) -> pulumi.Input[builtins.int]:
        """
        The length of prefix.
        """
        return pulumi.get(self, "prefix_len")

    @prefix_len.setter
    def prefix_len(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "prefix_len", value)

    @property
    @pulumi.getter
    def substitution(self) -> pulumi.Input[builtins.str]:
        """
        Substitution is the string used to replace the inner or outer substring.
        """
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "substitution", value)

    @property
    @pulumi.getter(name="suffixLen")
    def suffix_len(self) -> pulumi.Input[builtins.int]:
        """
        The length of suffix.
        """
        return pulumi.get(self, "suffix_len")

    @suffix_len.setter
    def suffix_len(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "suffix_len", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        INNER or OUTER.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SettingSemanticTypeAlgorithmMd5MaskArgsDict(TypedDict):
        salt: pulumi.Input[builtins.str]
        """
        Salt is the salt value to generate a different hash that with the word alone.
        """
elif False:
    SettingSemanticTypeAlgorithmMd5MaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSemanticTypeAlgorithmMd5MaskArgs:
    def __init__(__self__, *,
                 salt: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] salt: Salt is the salt value to generate a different hash that with the word alone.
        """
        pulumi.set(__self__, "salt", salt)

    @property
    @pulumi.getter
    def salt(self) -> pulumi.Input[builtins.str]:
        """
        Salt is the salt value to generate a different hash that with the word alone.
        """
        return pulumi.get(self, "salt")

    @salt.setter
    def salt(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "salt", value)


if not MYPY:
    class SettingSemanticTypeAlgorithmRangeMaskArgsDict(TypedDict):
        slices: NotRequired[pulumi.Input[Sequence[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskSliceArgsDict']]]]
elif False:
    SettingSemanticTypeAlgorithmRangeMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSemanticTypeAlgorithmRangeMaskArgs:
    def __init__(__self__, *,
                 slices: Optional[pulumi.Input[Sequence[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskSliceArgs']]]] = None):
        if slices is not None:
            pulumi.set(__self__, "slices", slices)

    @property
    @pulumi.getter
    def slices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskSliceArgs']]]]:
        return pulumi.get(self, "slices")

    @slices.setter
    def slices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingSemanticTypeAlgorithmRangeMaskSliceArgs']]]]):
        pulumi.set(self, "slices", value)


if not MYPY:
    class SettingSemanticTypeAlgorithmRangeMaskSliceArgsDict(TypedDict):
        end: pulumi.Input[builtins.int]
        """
        End is the stop index of the original value, should be less than the length of the original value.
        """
        start: pulumi.Input[builtins.int]
        """
        Start is the start index of the original value, start from 0 and should be less than stop.
        """
        substitution: pulumi.Input[builtins.str]
        """
        Substitution is the string used to replace the OriginalValue[start:end).
        """
elif False:
    SettingSemanticTypeAlgorithmRangeMaskSliceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSemanticTypeAlgorithmRangeMaskSliceArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[builtins.int],
                 start: pulumi.Input[builtins.int],
                 substitution: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.int] end: End is the stop index of the original value, should be less than the length of the original value.
        :param pulumi.Input[builtins.int] start: Start is the start index of the original value, start from 0 and should be less than stop.
        :param pulumi.Input[builtins.str] substitution: Substitution is the string used to replace the OriginalValue[start:end).
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[builtins.int]:
        """
        End is the stop index of the original value, should be less than the length of the original value.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[builtins.int]:
        """
        Start is the start index of the original value, start from 0 and should be less than stop.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter
    def substitution(self) -> pulumi.Input[builtins.str]:
        """
        Substitution is the string used to replace the OriginalValue[start:end).
        """
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "substitution", value)


if not MYPY:
    class SettingSqlQueryRestrictionArgsDict(TypedDict):
        maximum_result_rows: NotRequired[pulumi.Input[builtins.int]]
        """
        The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        """
        maximum_result_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
elif False:
    SettingSqlQueryRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSqlQueryRestrictionArgs:
    def __init__(__self__, *,
                 maximum_result_rows: Optional[pulumi.Input[builtins.int]] = None,
                 maximum_result_size: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] maximum_result_rows: The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        :param pulumi.Input[builtins.int] maximum_result_size: The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        if maximum_result_rows is not None:
            pulumi.set(__self__, "maximum_result_rows", maximum_result_rows)
        if maximum_result_size is not None:
            pulumi.set(__self__, "maximum_result_size", maximum_result_size)

    @property
    @pulumi.getter(name="maximumResultRows")
    def maximum_result_rows(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        """
        return pulumi.get(self, "maximum_result_rows")

    @maximum_result_rows.setter
    def maximum_result_rows(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum_result_rows", value)

    @property
    @pulumi.getter(name="maximumResultSize")
    def maximum_result_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        return pulumi.get(self, "maximum_result_size")

    @maximum_result_size.setter
    def maximum_result_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum_result_size", value)


if not MYPY:
    class SettingWorkspaceProfileArgsDict(TypedDict):
        announcement: NotRequired[pulumi.Input['SettingWorkspaceProfileAnnouncementArgsDict']]
        """
        Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        """
        database_change_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        """
        disallow_password_signin: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        """
        disallow_signup: NotRequired[pulumi.Input[builtins.bool]]
        """
        Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        """
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The workspace domain, e.g. bytebase.com. Required for the group
        """
        enforce_identity_domain: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only user and group from the domains can be created and login.
        """
        external_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        """
        maximum_role_expiration_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        """
        token_duration_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
elif False:
    SettingWorkspaceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingWorkspaceProfileArgs:
    def __init__(__self__, *,
                 announcement: Optional[pulumi.Input['SettingWorkspaceProfileAnnouncementArgs']] = None,
                 database_change_mode: Optional[pulumi.Input[builtins.str]] = None,
                 disallow_password_signin: Optional[pulumi.Input[builtins.bool]] = None,
                 disallow_signup: Optional[pulumi.Input[builtins.bool]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 enforce_identity_domain: Optional[pulumi.Input[builtins.bool]] = None,
                 external_url: Optional[pulumi.Input[builtins.str]] = None,
                 maximum_role_expiration_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 token_duration_in_seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input['SettingWorkspaceProfileAnnouncementArgs'] announcement: Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        :param pulumi.Input[builtins.str] database_change_mode: The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        :param pulumi.Input[builtins.bool] disallow_password_signin: Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        :param pulumi.Input[builtins.bool] disallow_signup: Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] domains: The workspace domain, e.g. bytebase.com. Required for the group
        :param pulumi.Input[builtins.bool] enforce_identity_domain: Only user and group from the domains can be created and login.
        :param pulumi.Input[builtins.str] external_url: The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        :param pulumi.Input[builtins.int] maximum_role_expiration_in_seconds: The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        :param pulumi.Input[builtins.int] token_duration_in_seconds: The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        if announcement is not None:
            pulumi.set(__self__, "announcement", announcement)
        if database_change_mode is not None:
            pulumi.set(__self__, "database_change_mode", database_change_mode)
        if disallow_password_signin is not None:
            pulumi.set(__self__, "disallow_password_signin", disallow_password_signin)
        if disallow_signup is not None:
            pulumi.set(__self__, "disallow_signup", disallow_signup)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enforce_identity_domain is not None:
            pulumi.set(__self__, "enforce_identity_domain", enforce_identity_domain)
        if external_url is not None:
            pulumi.set(__self__, "external_url", external_url)
        if maximum_role_expiration_in_seconds is not None:
            pulumi.set(__self__, "maximum_role_expiration_in_seconds", maximum_role_expiration_in_seconds)
        if token_duration_in_seconds is not None:
            pulumi.set(__self__, "token_duration_in_seconds", token_duration_in_seconds)

    @property
    @pulumi.getter
    def announcement(self) -> Optional[pulumi.Input['SettingWorkspaceProfileAnnouncementArgs']]:
        """
        Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        """
        return pulumi.get(self, "announcement")

    @announcement.setter
    def announcement(self, value: Optional[pulumi.Input['SettingWorkspaceProfileAnnouncementArgs']]):
        pulumi.set(self, "announcement", value)

    @property
    @pulumi.getter(name="databaseChangeMode")
    def database_change_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        """
        return pulumi.get(self, "database_change_mode")

    @database_change_mode.setter
    def database_change_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "database_change_mode", value)

    @property
    @pulumi.getter(name="disallowPasswordSignin")
    def disallow_password_signin(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        """
        return pulumi.get(self, "disallow_password_signin")

    @disallow_password_signin.setter
    def disallow_password_signin(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disallow_password_signin", value)

    @property
    @pulumi.getter(name="disallowSignup")
    def disallow_signup(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        """
        return pulumi.get(self, "disallow_signup")

    @disallow_signup.setter
    def disallow_signup(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disallow_signup", value)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The workspace domain, e.g. bytebase.com. Required for the group
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter(name="enforceIdentityDomain")
    def enforce_identity_domain(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only user and group from the domains can be created and login.
        """
        return pulumi.get(self, "enforce_identity_domain")

    @enforce_identity_domain.setter
    def enforce_identity_domain(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enforce_identity_domain", value)

    @property
    @pulumi.getter(name="externalUrl")
    def external_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        """
        return pulumi.get(self, "external_url")

    @external_url.setter
    def external_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_url", value)

    @property
    @pulumi.getter(name="maximumRoleExpirationInSeconds")
    def maximum_role_expiration_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        """
        return pulumi.get(self, "maximum_role_expiration_in_seconds")

    @maximum_role_expiration_in_seconds.setter
    def maximum_role_expiration_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum_role_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="tokenDurationInSeconds")
    def token_duration_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        return pulumi.get(self, "token_duration_in_seconds")

    @token_duration_in_seconds.setter
    def token_duration_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "token_duration_in_seconds", value)


if not MYPY:
    class SettingWorkspaceProfileAnnouncementArgsDict(TypedDict):
        level: pulumi.Input[builtins.str]
        """
        The alert level of announcement
        """
        text: pulumi.Input[builtins.str]
        """
        The text of announcement. Leave it as empty string can clear the announcement
        """
        link: NotRequired[pulumi.Input[builtins.str]]
        """
        The optional link, user can follow the link to check extra details
        """
elif False:
    SettingWorkspaceProfileAnnouncementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingWorkspaceProfileAnnouncementArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[builtins.str],
                 text: pulumi.Input[builtins.str],
                 link: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] level: The alert level of announcement
        :param pulumi.Input[builtins.str] text: The text of announcement. Leave it as empty string can clear the announcement
        :param pulumi.Input[builtins.str] link: The optional link, user can follow the link to check extra details
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "text", text)
        if link is not None:
            pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[builtins.str]:
        """
        The alert level of announcement
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[builtins.str]:
        """
        The text of announcement. Leave it as empty string can clear the announcement
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The optional link, user can follow the link to check extra details
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "link", value)


if not MYPY:
    class GetPolicyDataSourceQueryPolicyArgsDict(TypedDict):
        disallow_ddl: NotRequired[builtins.bool]
        """
        Disallow running DDL statements in the SQL editor.
        """
        disallow_dml: NotRequired[builtins.bool]
        """
        Disallow running DML statements in the SQL editor.
        """
        restriction: NotRequired[builtins.str]
        """
        RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
elif False:
    GetPolicyDataSourceQueryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyDataSourceQueryPolicyArgs:
    def __init__(__self__, *,
                 disallow_ddl: Optional[builtins.bool] = None,
                 disallow_dml: Optional[builtins.bool] = None,
                 restriction: Optional[builtins.str] = None):
        """
        :param builtins.bool disallow_ddl: Disallow running DDL statements in the SQL editor.
        :param builtins.bool disallow_dml: Disallow running DML statements in the SQL editor.
        :param builtins.str restriction: RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        if disallow_ddl is not None:
            pulumi.set(__self__, "disallow_ddl", disallow_ddl)
        if disallow_dml is not None:
            pulumi.set(__self__, "disallow_dml", disallow_dml)
        if restriction is not None:
            pulumi.set(__self__, "restriction", restriction)

    @property
    @pulumi.getter(name="disallowDdl")
    def disallow_ddl(self) -> Optional[builtins.bool]:
        """
        Disallow running DDL statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_ddl")

    @disallow_ddl.setter
    def disallow_ddl(self, value: Optional[builtins.bool]):
        pulumi.set(self, "disallow_ddl", value)

    @property
    @pulumi.getter(name="disallowDml")
    def disallow_dml(self) -> Optional[builtins.bool]:
        """
        Disallow running DML statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_dml")

    @disallow_dml.setter
    def disallow_dml(self, value: Optional[builtins.bool]):
        pulumi.set(self, "disallow_dml", value)

    @property
    @pulumi.getter
    def restriction(self) -> Optional[builtins.str]:
        """
        RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        return pulumi.get(self, "restriction")

    @restriction.setter
    def restriction(self, value: Optional[builtins.str]):
        pulumi.set(self, "restriction", value)


if not MYPY:
    class GetPolicyDisableCopyDataPolicyArgsDict(TypedDict):
        enable: builtins.bool
        """
        Restrict data copying
        """
elif False:
    GetPolicyDisableCopyDataPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyDisableCopyDataPolicyArgs:
    def __init__(__self__, *,
                 enable: builtins.bool):
        """
        :param builtins.bool enable: Restrict data copying
        """
        pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> builtins.bool:
        """
        Restrict data copying
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: builtins.bool):
        pulumi.set(self, "enable", value)


if not MYPY:
    class GetPolicyGlobalMaskingPolicyArgsDict(TypedDict):
        rules: Sequence['GetPolicyGlobalMaskingPolicyRuleArgsDict']
elif False:
    GetPolicyGlobalMaskingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyGlobalMaskingPolicyArgs:
    def __init__(__self__, *,
                 rules: Sequence['GetPolicyGlobalMaskingPolicyRuleArgs']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['GetPolicyGlobalMaskingPolicyRuleArgs']:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetPolicyGlobalMaskingPolicyRuleArgs']):
        pulumi.set(self, "rules", value)


if not MYPY:
    class GetPolicyGlobalMaskingPolicyRuleArgsDict(TypedDict):
        condition: builtins.str
        """
        The condition expression
        """
        id: builtins.str
        """
        The unique rule id
        """
        semantic_type: builtins.str
        """
        The semantic type id
        """
        title: NotRequired[builtins.str]
        """
        The title for the rule
        """
elif False:
    GetPolicyGlobalMaskingPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyGlobalMaskingPolicyRuleArgs:
    def __init__(__self__, *,
                 condition: builtins.str,
                 id: builtins.str,
                 semantic_type: builtins.str,
                 title: Optional[builtins.str] = None):
        """
        :param builtins.str condition: The condition expression
        :param builtins.str id: The unique rule id
        :param builtins.str semantic_type: The semantic type id
        :param builtins.str title: The title for the rule
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "semantic_type", semantic_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        The condition expression
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: builtins.str):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The unique rule id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> builtins.str:
        """
        The semantic type id
        """
        return pulumi.get(self, "semantic_type")

    @semantic_type.setter
    def semantic_type(self, value: builtins.str):
        pulumi.set(self, "semantic_type", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        The title for the rule
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[builtins.str]):
        pulumi.set(self, "title", value)


if not MYPY:
    class GetPolicyMaskingExceptionPolicyArgsDict(TypedDict):
        exceptions: Sequence['GetPolicyMaskingExceptionPolicyExceptionArgsDict']
elif False:
    GetPolicyMaskingExceptionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyMaskingExceptionPolicyArgs:
    def __init__(__self__, *,
                 exceptions: Sequence['GetPolicyMaskingExceptionPolicyExceptionArgs']):
        pulumi.set(__self__, "exceptions", exceptions)

    @property
    @pulumi.getter
    def exceptions(self) -> Sequence['GetPolicyMaskingExceptionPolicyExceptionArgs']:
        return pulumi.get(self, "exceptions")

    @exceptions.setter
    def exceptions(self, value: Sequence['GetPolicyMaskingExceptionPolicyExceptionArgs']):
        pulumi.set(self, "exceptions", value)


if not MYPY:
    class GetPolicyMaskingExceptionPolicyExceptionArgsDict(TypedDict):
        action: builtins.str
        column: builtins.str
        database: builtins.str
        """
        The database full name in instances/{instance resource id}/databases/{database name} format
        """
        expire_timestamp: builtins.str
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        """
        member: builtins.str
        """
        The member in user:{email} or group:{email} format.
        """
        schema: builtins.str
        table: builtins.str
        reason: NotRequired[builtins.str]
        """
        The reason for the masking exemption
        """
elif False:
    GetPolicyMaskingExceptionPolicyExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyMaskingExceptionPolicyExceptionArgs:
    def __init__(__self__, *,
                 action: builtins.str,
                 column: builtins.str,
                 database: builtins.str,
                 expire_timestamp: builtins.str,
                 member: builtins.str,
                 schema: builtins.str,
                 table: builtins.str,
                 reason: Optional[builtins.str] = None):
        """
        :param builtins.str database: The database full name in instances/{instance resource id}/databases/{database name} format
        :param builtins.str expire_timestamp: The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        :param builtins.str member: The member in user:{email} or group:{email} format.
        :param builtins.str reason: The reason for the masking exemption
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "expire_timestamp", expire_timestamp)
        pulumi.set(__self__, "member", member)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "table", table)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: builtins.str):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def column(self) -> builtins.str:
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: builtins.str):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def database(self) -> builtins.str:
        """
        The database full name in instances/{instance resource id}/databases/{database name} format
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: builtins.str):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="expireTimestamp")
    def expire_timestamp(self) -> builtins.str:
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        """
        return pulumi.get(self, "expire_timestamp")

    @expire_timestamp.setter
    def expire_timestamp(self, value: builtins.str):
        pulumi.set(self, "expire_timestamp", value)

    @property
    @pulumi.getter
    def member(self) -> builtins.str:
        """
        The member in user:{email} or group:{email} format.
        """
        return pulumi.get(self, "member")

    @member.setter
    def member(self, value: builtins.str):
        pulumi.set(self, "member", value)

    @property
    @pulumi.getter
    def schema(self) -> builtins.str:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: builtins.str):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def table(self) -> builtins.str:
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: builtins.str):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        The reason for the masking exemption
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[builtins.str]):
        pulumi.set(self, "reason", value)


if not MYPY:
    class GetPolicyRolloutPolicyArgsDict(TypedDict):
        automatic: NotRequired[builtins.bool]
        """
        If all check pass, the change will be rolled out and executed automatically.
        """
        roles: NotRequired[Sequence[builtins.str]]
        """
        If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
elif False:
    GetPolicyRolloutPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyRolloutPolicyArgs:
    def __init__(__self__, *,
                 automatic: Optional[builtins.bool] = None,
                 roles: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool automatic: If all check pass, the change will be rolled out and executed automatically.
        :param Sequence[builtins.str] roles: If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def automatic(self) -> Optional[builtins.bool]:
        """
        If all check pass, the change will be rolled out and executed automatically.
        """
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: Optional[builtins.bool]):
        pulumi.set(self, "automatic", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[builtins.str]]:
        """
        If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class GetSettingApprovalFlowArgsDict(TypedDict):
        rules: Sequence['GetSettingApprovalFlowRuleArgsDict']
elif False:
    GetSettingApprovalFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingApprovalFlowArgs:
    def __init__(__self__, *,
                 rules: Sequence['GetSettingApprovalFlowRuleArgs']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['GetSettingApprovalFlowRuleArgs']:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetSettingApprovalFlowRuleArgs']):
        pulumi.set(self, "rules", value)


if not MYPY:
    class GetSettingApprovalFlowRuleArgsDict(TypedDict):
        conditions: Sequence['GetSettingApprovalFlowRuleConditionArgsDict']
        """
        Match any condition will trigger this approval flow.
        """
        flows: Sequence['GetSettingApprovalFlowRuleFlowArgsDict']
elif False:
    GetSettingApprovalFlowRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingApprovalFlowRuleArgs:
    def __init__(__self__, *,
                 conditions: Sequence['GetSettingApprovalFlowRuleConditionArgs'],
                 flows: Sequence['GetSettingApprovalFlowRuleFlowArgs']):
        """
        :param Sequence['GetSettingApprovalFlowRuleConditionArgs'] conditions: Match any condition will trigger this approval flow.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "flows", flows)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['GetSettingApprovalFlowRuleConditionArgs']:
        """
        Match any condition will trigger this approval flow.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Sequence['GetSettingApprovalFlowRuleConditionArgs']):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def flows(self) -> Sequence['GetSettingApprovalFlowRuleFlowArgs']:
        return pulumi.get(self, "flows")

    @flows.setter
    def flows(self, value: Sequence['GetSettingApprovalFlowRuleFlowArgs']):
        pulumi.set(self, "flows", value)


if not MYPY:
    class GetSettingApprovalFlowRuleConditionArgsDict(TypedDict):
        level: builtins.str
        source: builtins.str
elif False:
    GetSettingApprovalFlowRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingApprovalFlowRuleConditionArgs:
    def __init__(__self__, *,
                 level: builtins.str,
                 source: builtins.str):
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def level(self) -> builtins.str:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: builtins.str):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def source(self) -> builtins.str:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: builtins.str):
        pulumi.set(self, "source", value)


if not MYPY:
    class GetSettingApprovalFlowRuleFlowArgsDict(TypedDict):
        description: builtins.str
        steps: Sequence['GetSettingApprovalFlowRuleFlowStepArgsDict']
        """
        Approval flow following the step order.
        """
        title: builtins.str
elif False:
    GetSettingApprovalFlowRuleFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingApprovalFlowRuleFlowArgs:
    def __init__(__self__, *,
                 description: builtins.str,
                 steps: Sequence['GetSettingApprovalFlowRuleFlowStepArgs'],
                 title: builtins.str):
        """
        :param Sequence['GetSettingApprovalFlowRuleFlowStepArgs'] steps: Approval flow following the step order.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: builtins.str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def steps(self) -> Sequence['GetSettingApprovalFlowRuleFlowStepArgs']:
        """
        Approval flow following the step order.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Sequence['GetSettingApprovalFlowRuleFlowStepArgs']):
        pulumi.set(self, "steps", value)

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: builtins.str):
        pulumi.set(self, "title", value)


if not MYPY:
    class GetSettingApprovalFlowRuleFlowStepArgsDict(TypedDict):
        role: builtins.str
        """
        The role require to review in this step
        """
elif False:
    GetSettingApprovalFlowRuleFlowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingApprovalFlowRuleFlowStepArgs:
    def __init__(__self__, *,
                 role: builtins.str):
        """
        :param builtins.str role: The role require to review in this step
        """
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def role(self) -> builtins.str:
        """
        The role require to review in this step
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: builtins.str):
        pulumi.set(self, "role", value)


if not MYPY:
    class GetSettingClassificationArgsDict(TypedDict):
        classification_from_config: builtins.bool
        """
        If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
        classifications: Sequence['GetSettingClassificationClassificationArgsDict']
        id: builtins.str
        """
        The classification unique uuid.
        """
        levels: Sequence['GetSettingClassificationLevelArgsDict']
        title: builtins.str
        """
        The classification title. Optional.
        """
elif False:
    GetSettingClassificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingClassificationArgs:
    def __init__(__self__, *,
                 classification_from_config: builtins.bool,
                 classifications: Sequence['GetSettingClassificationClassificationArgs'],
                 id: builtins.str,
                 levels: Sequence['GetSettingClassificationLevelArgs'],
                 title: builtins.str):
        """
        :param builtins.bool classification_from_config: If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        :param builtins.str id: The classification unique uuid.
        :param builtins.str title: The classification title. Optional.
        """
        pulumi.set(__self__, "classification_from_config", classification_from_config)
        pulumi.set(__self__, "classifications", classifications)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="classificationFromConfig")
    def classification_from_config(self) -> builtins.bool:
        """
        If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
        return pulumi.get(self, "classification_from_config")

    @classification_from_config.setter
    def classification_from_config(self, value: builtins.bool):
        pulumi.set(self, "classification_from_config", value)

    @property
    @pulumi.getter
    def classifications(self) -> Sequence['GetSettingClassificationClassificationArgs']:
        return pulumi.get(self, "classifications")

    @classifications.setter
    def classifications(self, value: Sequence['GetSettingClassificationClassificationArgs']):
        pulumi.set(self, "classifications", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The classification unique uuid.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def levels(self) -> Sequence['GetSettingClassificationLevelArgs']:
        return pulumi.get(self, "levels")

    @levels.setter
    def levels(self, value: Sequence['GetSettingClassificationLevelArgs']):
        pulumi.set(self, "levels", value)

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        """
        The classification title. Optional.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: builtins.str):
        pulumi.set(self, "title", value)


if not MYPY:
    class GetSettingClassificationClassificationArgsDict(TypedDict):
        description: builtins.str
        """
        The classification description.
        """
        id: builtins.str
        """
        The classification unique id, must in {number}-{number} format.
        """
        level: builtins.str
        """
        The classification level id.
        """
        title: builtins.str
        """
        The classification title.
        """
elif False:
    GetSettingClassificationClassificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingClassificationClassificationArgs:
    def __init__(__self__, *,
                 description: builtins.str,
                 id: builtins.str,
                 level: builtins.str,
                 title: builtins.str):
        """
        :param builtins.str description: The classification description.
        :param builtins.str id: The classification unique id, must in {number}-{number} format.
        :param builtins.str level: The classification level id.
        :param builtins.str title: The classification title.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The classification description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: builtins.str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The classification unique id, must in {number}-{number} format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def level(self) -> builtins.str:
        """
        The classification level id.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: builtins.str):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        """
        The classification title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: builtins.str):
        pulumi.set(self, "title", value)


if not MYPY:
    class GetSettingClassificationLevelArgsDict(TypedDict):
        description: builtins.str
        """
        The classification level description.
        """
        id: builtins.str
        """
        The classification level unique uuid.
        """
        title: builtins.str
        """
        The classification level title.
        """
elif False:
    GetSettingClassificationLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingClassificationLevelArgs:
    def __init__(__self__, *,
                 description: builtins.str,
                 id: builtins.str,
                 title: builtins.str):
        """
        :param builtins.str description: The classification level description.
        :param builtins.str id: The classification level unique uuid.
        :param builtins.str title: The classification level title.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The classification level description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: builtins.str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The classification level unique uuid.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        """
        The classification level title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: builtins.str):
        pulumi.set(self, "title", value)


if not MYPY:
    class GetSettingEnvironmentSettingArgsDict(TypedDict):
        environments: Sequence['GetSettingEnvironmentSettingEnvironmentArgsDict']
elif False:
    GetSettingEnvironmentSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingEnvironmentSettingArgs:
    def __init__(__self__, *,
                 environments: Sequence['GetSettingEnvironmentSettingEnvironmentArgs']):
        pulumi.set(__self__, "environments", environments)

    @property
    @pulumi.getter
    def environments(self) -> Sequence['GetSettingEnvironmentSettingEnvironmentArgs']:
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Sequence['GetSettingEnvironmentSettingEnvironmentArgs']):
        pulumi.set(self, "environments", value)


if not MYPY:
    class GetSettingEnvironmentSettingEnvironmentArgsDict(TypedDict):
        id: builtins.str
        """
        The environment unique id.
        """
        name: builtins.str
        """
        The environment readonly name in environments/{id} format.
        """
        title: builtins.str
        """
        The environment display name.
        """
        color: NotRequired[builtins.str]
        """
        The environment color.
        """
        protected: NotRequired[builtins.bool]
        """
        The environment is protected or not.
        """
elif False:
    GetSettingEnvironmentSettingEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingEnvironmentSettingEnvironmentArgs:
    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 title: builtins.str,
                 color: Optional[builtins.str] = None,
                 protected: Optional[builtins.bool] = None):
        """
        :param builtins.str id: The environment unique id.
        :param builtins.str name: The environment readonly name in environments/{id} format.
        :param builtins.str title: The environment display name.
        :param builtins.str color: The environment color.
        :param builtins.bool protected: The environment is protected or not.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "title", title)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if protected is not None:
            pulumi.set(__self__, "protected", protected)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The environment unique id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The environment readonly name in environments/{id} format.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        """
        The environment display name.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: builtins.str):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[builtins.str]:
        """
        The environment color.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[builtins.str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def protected(self) -> Optional[builtins.bool]:
        """
        The environment is protected or not.
        """
        return pulumi.get(self, "protected")

    @protected.setter
    def protected(self, value: Optional[builtins.bool]):
        pulumi.set(self, "protected", value)


if not MYPY:
    class GetSettingPasswordRestrictionArgsDict(TypedDict):
        min_length: NotRequired[builtins.int]
        """
        min_length is the minimum length for password, should no less than 8.
        """
        password_rotation_in_seconds: NotRequired[builtins.int]
        """
        password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        """
        require_letter: NotRequired[builtins.bool]
        """
        require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        """
        require_number: NotRequired[builtins.bool]
        """
        require_number requires the password must contains at least one number.
        """
        require_reset_password_for_first_login: NotRequired[builtins.bool]
        """
        require*reset*password*for*first_login requires users to reset their password after the 1st login.
        """
        require_special_character: NotRequired[builtins.bool]
        """
        require*special*character requires the password must contains at least one special character.
        """
        require_uppercase_letter: NotRequired[builtins.bool]
        """
        require*uppercase*letter requires the password must contains at least one upper case letter.
        """
elif False:
    GetSettingPasswordRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingPasswordRestrictionArgs:
    def __init__(__self__, *,
                 min_length: Optional[builtins.int] = None,
                 password_rotation_in_seconds: Optional[builtins.int] = None,
                 require_letter: Optional[builtins.bool] = None,
                 require_number: Optional[builtins.bool] = None,
                 require_reset_password_for_first_login: Optional[builtins.bool] = None,
                 require_special_character: Optional[builtins.bool] = None,
                 require_uppercase_letter: Optional[builtins.bool] = None):
        """
        :param builtins.int min_length: min_length is the minimum length for password, should no less than 8.
        :param builtins.int password_rotation_in_seconds: password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        :param builtins.bool require_letter: require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        :param builtins.bool require_number: require_number requires the password must contains at least one number.
        :param builtins.bool require_reset_password_for_first_login: require*reset*password*for*first_login requires users to reset their password after the 1st login.
        :param builtins.bool require_special_character: require*special*character requires the password must contains at least one special character.
        :param builtins.bool require_uppercase_letter: require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if password_rotation_in_seconds is not None:
            pulumi.set(__self__, "password_rotation_in_seconds", password_rotation_in_seconds)
        if require_letter is not None:
            pulumi.set(__self__, "require_letter", require_letter)
        if require_number is not None:
            pulumi.set(__self__, "require_number", require_number)
        if require_reset_password_for_first_login is not None:
            pulumi.set(__self__, "require_reset_password_for_first_login", require_reset_password_for_first_login)
        if require_special_character is not None:
            pulumi.set(__self__, "require_special_character", require_special_character)
        if require_uppercase_letter is not None:
            pulumi.set(__self__, "require_uppercase_letter", require_uppercase_letter)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[builtins.int]:
        """
        min_length is the minimum length for password, should no less than 8.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[builtins.int]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="passwordRotationInSeconds")
    def password_rotation_in_seconds(self) -> Optional[builtins.int]:
        """
        password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        """
        return pulumi.get(self, "password_rotation_in_seconds")

    @password_rotation_in_seconds.setter
    def password_rotation_in_seconds(self, value: Optional[builtins.int]):
        pulumi.set(self, "password_rotation_in_seconds", value)

    @property
    @pulumi.getter(name="requireLetter")
    def require_letter(self) -> Optional[builtins.bool]:
        """
        require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        """
        return pulumi.get(self, "require_letter")

    @require_letter.setter
    def require_letter(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_letter", value)

    @property
    @pulumi.getter(name="requireNumber")
    def require_number(self) -> Optional[builtins.bool]:
        """
        require_number requires the password must contains at least one number.
        """
        return pulumi.get(self, "require_number")

    @require_number.setter
    def require_number(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_number", value)

    @property
    @pulumi.getter(name="requireResetPasswordForFirstLogin")
    def require_reset_password_for_first_login(self) -> Optional[builtins.bool]:
        """
        require*reset*password*for*first_login requires users to reset their password after the 1st login.
        """
        return pulumi.get(self, "require_reset_password_for_first_login")

    @require_reset_password_for_first_login.setter
    def require_reset_password_for_first_login(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_reset_password_for_first_login", value)

    @property
    @pulumi.getter(name="requireSpecialCharacter")
    def require_special_character(self) -> Optional[builtins.bool]:
        """
        require*special*character requires the password must contains at least one special character.
        """
        return pulumi.get(self, "require_special_character")

    @require_special_character.setter
    def require_special_character(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_special_character", value)

    @property
    @pulumi.getter(name="requireUppercaseLetter")
    def require_uppercase_letter(self) -> Optional[builtins.bool]:
        """
        require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        return pulumi.get(self, "require_uppercase_letter")

    @require_uppercase_letter.setter
    def require_uppercase_letter(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_uppercase_letter", value)


if not MYPY:
    class GetSettingSemanticTypeArgsDict(TypedDict):
        algorithm: 'GetSettingSemanticTypeAlgorithmArgsDict'
        """
        The semantic type algorithm. Required.
        """
        description: builtins.str
        """
        The semantic type description. Optional.
        """
        id: builtins.str
        """
        The semantic type unique uuid.
        """
        title: builtins.str
        """
        The semantic type title. Required.
        """
elif False:
    GetSettingSemanticTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSemanticTypeArgs:
    def __init__(__self__, *,
                 algorithm: 'GetSettingSemanticTypeAlgorithmArgs',
                 description: builtins.str,
                 id: builtins.str,
                 title: builtins.str):
        """
        :param 'GetSettingSemanticTypeAlgorithmArgs' algorithm: The semantic type algorithm. Required.
        :param builtins.str description: The semantic type description. Optional.
        :param builtins.str id: The semantic type unique uuid.
        :param builtins.str title: The semantic type title. Required.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def algorithm(self) -> 'GetSettingSemanticTypeAlgorithmArgs':
        """
        The semantic type algorithm. Required.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: 'GetSettingSemanticTypeAlgorithmArgs'):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The semantic type description. Optional.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: builtins.str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The semantic type unique uuid.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        """
        The semantic type title. Required.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: builtins.str):
        pulumi.set(self, "title", value)


if not MYPY:
    class GetSettingSemanticTypeAlgorithmArgsDict(TypedDict):
        full_mask: 'GetSettingSemanticTypeAlgorithmFullMaskArgsDict'
        inner_outer_mask: 'GetSettingSemanticTypeAlgorithmInnerOuterMaskArgsDict'
        md5_mask: 'GetSettingSemanticTypeAlgorithmMd5MaskArgsDict'
        range_mask: 'GetSettingSemanticTypeAlgorithmRangeMaskArgsDict'
elif False:
    GetSettingSemanticTypeAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSemanticTypeAlgorithmArgs:
    def __init__(__self__, *,
                 full_mask: 'GetSettingSemanticTypeAlgorithmFullMaskArgs',
                 inner_outer_mask: 'GetSettingSemanticTypeAlgorithmInnerOuterMaskArgs',
                 md5_mask: 'GetSettingSemanticTypeAlgorithmMd5MaskArgs',
                 range_mask: 'GetSettingSemanticTypeAlgorithmRangeMaskArgs'):
        pulumi.set(__self__, "full_mask", full_mask)
        pulumi.set(__self__, "inner_outer_mask", inner_outer_mask)
        pulumi.set(__self__, "md5_mask", md5_mask)
        pulumi.set(__self__, "range_mask", range_mask)

    @property
    @pulumi.getter(name="fullMask")
    def full_mask(self) -> 'GetSettingSemanticTypeAlgorithmFullMaskArgs':
        return pulumi.get(self, "full_mask")

    @full_mask.setter
    def full_mask(self, value: 'GetSettingSemanticTypeAlgorithmFullMaskArgs'):
        pulumi.set(self, "full_mask", value)

    @property
    @pulumi.getter(name="innerOuterMask")
    def inner_outer_mask(self) -> 'GetSettingSemanticTypeAlgorithmInnerOuterMaskArgs':
        return pulumi.get(self, "inner_outer_mask")

    @inner_outer_mask.setter
    def inner_outer_mask(self, value: 'GetSettingSemanticTypeAlgorithmInnerOuterMaskArgs'):
        pulumi.set(self, "inner_outer_mask", value)

    @property
    @pulumi.getter(name="md5Mask")
    def md5_mask(self) -> 'GetSettingSemanticTypeAlgorithmMd5MaskArgs':
        return pulumi.get(self, "md5_mask")

    @md5_mask.setter
    def md5_mask(self, value: 'GetSettingSemanticTypeAlgorithmMd5MaskArgs'):
        pulumi.set(self, "md5_mask", value)

    @property
    @pulumi.getter(name="rangeMask")
    def range_mask(self) -> 'GetSettingSemanticTypeAlgorithmRangeMaskArgs':
        return pulumi.get(self, "range_mask")

    @range_mask.setter
    def range_mask(self, value: 'GetSettingSemanticTypeAlgorithmRangeMaskArgs'):
        pulumi.set(self, "range_mask", value)


if not MYPY:
    class GetSettingSemanticTypeAlgorithmFullMaskArgsDict(TypedDict):
        substitution: builtins.str
        """
        Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
elif False:
    GetSettingSemanticTypeAlgorithmFullMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSemanticTypeAlgorithmFullMaskArgs:
    def __init__(__self__, *,
                 substitution: builtins.str):
        """
        :param builtins.str substitution: Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter
    def substitution(self) -> builtins.str:
        """
        Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: builtins.str):
        pulumi.set(self, "substitution", value)


if not MYPY:
    class GetSettingSemanticTypeAlgorithmInnerOuterMaskArgsDict(TypedDict):
        prefix_len: builtins.int
        """
        The length of prefix.
        """
        substitution: builtins.str
        """
        Substitution is the string used to replace the inner or outer substring.
        """
        suffix_len: builtins.int
        """
        The length of suffix.
        """
        type: builtins.str
        """
        INNER or OUTER.
        """
elif False:
    GetSettingSemanticTypeAlgorithmInnerOuterMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSemanticTypeAlgorithmInnerOuterMaskArgs:
    def __init__(__self__, *,
                 prefix_len: builtins.int,
                 substitution: builtins.str,
                 suffix_len: builtins.int,
                 type: builtins.str):
        """
        :param builtins.int prefix_len: The length of prefix.
        :param builtins.str substitution: Substitution is the string used to replace the inner or outer substring.
        :param builtins.int suffix_len: The length of suffix.
        :param builtins.str type: INNER or OUTER.
        """
        pulumi.set(__self__, "prefix_len", prefix_len)
        pulumi.set(__self__, "substitution", substitution)
        pulumi.set(__self__, "suffix_len", suffix_len)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="prefixLen")
    def prefix_len(self) -> builtins.int:
        """
        The length of prefix.
        """
        return pulumi.get(self, "prefix_len")

    @prefix_len.setter
    def prefix_len(self, value: builtins.int):
        pulumi.set(self, "prefix_len", value)

    @property
    @pulumi.getter
    def substitution(self) -> builtins.str:
        """
        Substitution is the string used to replace the inner or outer substring.
        """
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: builtins.str):
        pulumi.set(self, "substitution", value)

    @property
    @pulumi.getter(name="suffixLen")
    def suffix_len(self) -> builtins.int:
        """
        The length of suffix.
        """
        return pulumi.get(self, "suffix_len")

    @suffix_len.setter
    def suffix_len(self, value: builtins.int):
        pulumi.set(self, "suffix_len", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        INNER or OUTER.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: builtins.str):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetSettingSemanticTypeAlgorithmMd5MaskArgsDict(TypedDict):
        salt: builtins.str
        """
        Salt is the salt value to generate a different hash that with the word alone.
        """
elif False:
    GetSettingSemanticTypeAlgorithmMd5MaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSemanticTypeAlgorithmMd5MaskArgs:
    def __init__(__self__, *,
                 salt: builtins.str):
        """
        :param builtins.str salt: Salt is the salt value to generate a different hash that with the word alone.
        """
        pulumi.set(__self__, "salt", salt)

    @property
    @pulumi.getter
    def salt(self) -> builtins.str:
        """
        Salt is the salt value to generate a different hash that with the word alone.
        """
        return pulumi.get(self, "salt")

    @salt.setter
    def salt(self, value: builtins.str):
        pulumi.set(self, "salt", value)


if not MYPY:
    class GetSettingSemanticTypeAlgorithmRangeMaskArgsDict(TypedDict):
        slices: Sequence['GetSettingSemanticTypeAlgorithmRangeMaskSliceArgsDict']
elif False:
    GetSettingSemanticTypeAlgorithmRangeMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSemanticTypeAlgorithmRangeMaskArgs:
    def __init__(__self__, *,
                 slices: Sequence['GetSettingSemanticTypeAlgorithmRangeMaskSliceArgs']):
        pulumi.set(__self__, "slices", slices)

    @property
    @pulumi.getter
    def slices(self) -> Sequence['GetSettingSemanticTypeAlgorithmRangeMaskSliceArgs']:
        return pulumi.get(self, "slices")

    @slices.setter
    def slices(self, value: Sequence['GetSettingSemanticTypeAlgorithmRangeMaskSliceArgs']):
        pulumi.set(self, "slices", value)


if not MYPY:
    class GetSettingSemanticTypeAlgorithmRangeMaskSliceArgsDict(TypedDict):
        end: builtins.int
        """
        End is the stop index of the original value, should be less than the length of the original value.
        """
        start: builtins.int
        """
        Start is the start index of the original value, start from 0 and should be less than stop.
        """
        substitution: builtins.str
        """
        Substitution is the string used to replace the OriginalValue[start:end).
        """
elif False:
    GetSettingSemanticTypeAlgorithmRangeMaskSliceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSemanticTypeAlgorithmRangeMaskSliceArgs:
    def __init__(__self__, *,
                 end: builtins.int,
                 start: builtins.int,
                 substitution: builtins.str):
        """
        :param builtins.int end: End is the stop index of the original value, should be less than the length of the original value.
        :param builtins.int start: Start is the start index of the original value, start from 0 and should be less than stop.
        :param builtins.str substitution: Substitution is the string used to replace the OriginalValue[start:end).
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter
    def end(self) -> builtins.int:
        """
        End is the stop index of the original value, should be less than the length of the original value.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: builtins.int):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> builtins.int:
        """
        Start is the start index of the original value, start from 0 and should be less than stop.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: builtins.int):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter
    def substitution(self) -> builtins.str:
        """
        Substitution is the string used to replace the OriginalValue[start:end).
        """
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: builtins.str):
        pulumi.set(self, "substitution", value)


if not MYPY:
    class GetSettingSqlQueryRestrictionArgsDict(TypedDict):
        maximum_result_rows: NotRequired[builtins.int]
        """
        The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        """
        maximum_result_size: NotRequired[builtins.int]
        """
        The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
elif False:
    GetSettingSqlQueryRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingSqlQueryRestrictionArgs:
    def __init__(__self__, *,
                 maximum_result_rows: Optional[builtins.int] = None,
                 maximum_result_size: Optional[builtins.int] = None):
        """
        :param builtins.int maximum_result_rows: The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        :param builtins.int maximum_result_size: The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        if maximum_result_rows is not None:
            pulumi.set(__self__, "maximum_result_rows", maximum_result_rows)
        if maximum_result_size is not None:
            pulumi.set(__self__, "maximum_result_size", maximum_result_size)

    @property
    @pulumi.getter(name="maximumResultRows")
    def maximum_result_rows(self) -> Optional[builtins.int]:
        """
        The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        """
        return pulumi.get(self, "maximum_result_rows")

    @maximum_result_rows.setter
    def maximum_result_rows(self, value: Optional[builtins.int]):
        pulumi.set(self, "maximum_result_rows", value)

    @property
    @pulumi.getter(name="maximumResultSize")
    def maximum_result_size(self) -> Optional[builtins.int]:
        """
        The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        return pulumi.get(self, "maximum_result_size")

    @maximum_result_size.setter
    def maximum_result_size(self, value: Optional[builtins.int]):
        pulumi.set(self, "maximum_result_size", value)


if not MYPY:
    class GetSettingWorkspaceProfileArgsDict(TypedDict):
        announcement: NotRequired['GetSettingWorkspaceProfileAnnouncementArgsDict']
        """
        Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        """
        database_change_mode: NotRequired[builtins.str]
        """
        The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        """
        disallow_password_signin: NotRequired[builtins.bool]
        """
        Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        """
        disallow_signup: NotRequired[builtins.bool]
        """
        Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        """
        domains: NotRequired[Sequence[builtins.str]]
        """
        The workspace domain, e.g. bytebase.com. Required for the group
        """
        enforce_identity_domain: NotRequired[builtins.bool]
        """
        Only user and group from the domains can be created and login.
        """
        external_url: NotRequired[builtins.str]
        """
        The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        """
        maximum_role_expiration_in_seconds: NotRequired[builtins.int]
        """
        The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        """
        token_duration_in_seconds: NotRequired[builtins.int]
        """
        The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
elif False:
    GetSettingWorkspaceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingWorkspaceProfileArgs:
    def __init__(__self__, *,
                 announcement: Optional['GetSettingWorkspaceProfileAnnouncementArgs'] = None,
                 database_change_mode: Optional[builtins.str] = None,
                 disallow_password_signin: Optional[builtins.bool] = None,
                 disallow_signup: Optional[builtins.bool] = None,
                 domains: Optional[Sequence[builtins.str]] = None,
                 enforce_identity_domain: Optional[builtins.bool] = None,
                 external_url: Optional[builtins.str] = None,
                 maximum_role_expiration_in_seconds: Optional[builtins.int] = None,
                 token_duration_in_seconds: Optional[builtins.int] = None):
        """
        :param 'GetSettingWorkspaceProfileAnnouncementArgs' announcement: Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        :param builtins.str database_change_mode: The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        :param builtins.bool disallow_password_signin: Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        :param builtins.bool disallow_signup: Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        :param Sequence[builtins.str] domains: The workspace domain, e.g. bytebase.com. Required for the group
        :param builtins.bool enforce_identity_domain: Only user and group from the domains can be created and login.
        :param builtins.str external_url: The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        :param builtins.int maximum_role_expiration_in_seconds: The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        :param builtins.int token_duration_in_seconds: The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        if announcement is not None:
            pulumi.set(__self__, "announcement", announcement)
        if database_change_mode is not None:
            pulumi.set(__self__, "database_change_mode", database_change_mode)
        if disallow_password_signin is not None:
            pulumi.set(__self__, "disallow_password_signin", disallow_password_signin)
        if disallow_signup is not None:
            pulumi.set(__self__, "disallow_signup", disallow_signup)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enforce_identity_domain is not None:
            pulumi.set(__self__, "enforce_identity_domain", enforce_identity_domain)
        if external_url is not None:
            pulumi.set(__self__, "external_url", external_url)
        if maximum_role_expiration_in_seconds is not None:
            pulumi.set(__self__, "maximum_role_expiration_in_seconds", maximum_role_expiration_in_seconds)
        if token_duration_in_seconds is not None:
            pulumi.set(__self__, "token_duration_in_seconds", token_duration_in_seconds)

    @property
    @pulumi.getter
    def announcement(self) -> Optional['GetSettingWorkspaceProfileAnnouncementArgs']:
        """
        Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        """
        return pulumi.get(self, "announcement")

    @announcement.setter
    def announcement(self, value: Optional['GetSettingWorkspaceProfileAnnouncementArgs']):
        pulumi.set(self, "announcement", value)

    @property
    @pulumi.getter(name="databaseChangeMode")
    def database_change_mode(self) -> Optional[builtins.str]:
        """
        The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        """
        return pulumi.get(self, "database_change_mode")

    @database_change_mode.setter
    def database_change_mode(self, value: Optional[builtins.str]):
        pulumi.set(self, "database_change_mode", value)

    @property
    @pulumi.getter(name="disallowPasswordSignin")
    def disallow_password_signin(self) -> Optional[builtins.bool]:
        """
        Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        """
        return pulumi.get(self, "disallow_password_signin")

    @disallow_password_signin.setter
    def disallow_password_signin(self, value: Optional[builtins.bool]):
        pulumi.set(self, "disallow_password_signin", value)

    @property
    @pulumi.getter(name="disallowSignup")
    def disallow_signup(self) -> Optional[builtins.bool]:
        """
        Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        """
        return pulumi.get(self, "disallow_signup")

    @disallow_signup.setter
    def disallow_signup(self, value: Optional[builtins.bool]):
        pulumi.set(self, "disallow_signup", value)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[builtins.str]]:
        """
        The workspace domain, e.g. bytebase.com. Required for the group
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter(name="enforceIdentityDomain")
    def enforce_identity_domain(self) -> Optional[builtins.bool]:
        """
        Only user and group from the domains can be created and login.
        """
        return pulumi.get(self, "enforce_identity_domain")

    @enforce_identity_domain.setter
    def enforce_identity_domain(self, value: Optional[builtins.bool]):
        pulumi.set(self, "enforce_identity_domain", value)

    @property
    @pulumi.getter(name="externalUrl")
    def external_url(self) -> Optional[builtins.str]:
        """
        The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        """
        return pulumi.get(self, "external_url")

    @external_url.setter
    def external_url(self, value: Optional[builtins.str]):
        pulumi.set(self, "external_url", value)

    @property
    @pulumi.getter(name="maximumRoleExpirationInSeconds")
    def maximum_role_expiration_in_seconds(self) -> Optional[builtins.int]:
        """
        The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        """
        return pulumi.get(self, "maximum_role_expiration_in_seconds")

    @maximum_role_expiration_in_seconds.setter
    def maximum_role_expiration_in_seconds(self, value: Optional[builtins.int]):
        pulumi.set(self, "maximum_role_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="tokenDurationInSeconds")
    def token_duration_in_seconds(self) -> Optional[builtins.int]:
        """
        The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        return pulumi.get(self, "token_duration_in_seconds")

    @token_duration_in_seconds.setter
    def token_duration_in_seconds(self, value: Optional[builtins.int]):
        pulumi.set(self, "token_duration_in_seconds", value)


if not MYPY:
    class GetSettingWorkspaceProfileAnnouncementArgsDict(TypedDict):
        level: builtins.str
        """
        The alert level of announcement
        """
        text: builtins.str
        """
        The text of announcement. Leave it as empty string can clear the announcement
        """
        link: NotRequired[builtins.str]
        """
        The optional link, user can follow the link to check extra details
        """
elif False:
    GetSettingWorkspaceProfileAnnouncementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSettingWorkspaceProfileAnnouncementArgs:
    def __init__(__self__, *,
                 level: builtins.str,
                 text: builtins.str,
                 link: Optional[builtins.str] = None):
        """
        :param builtins.str level: The alert level of announcement
        :param builtins.str text: The text of announcement. Leave it as empty string can clear the announcement
        :param builtins.str link: The optional link, user can follow the link to check extra details
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "text", text)
        if link is not None:
            pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def level(self) -> builtins.str:
        """
        The alert level of announcement
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: builtins.str):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def text(self) -> builtins.str:
        """
        The text of announcement. Leave it as empty string can clear the announcement
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: builtins.str):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[builtins.str]:
        """
        The optional link, user can follow the link to check extra details
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[builtins.str]):
        pulumi.set(self, "link", value)


