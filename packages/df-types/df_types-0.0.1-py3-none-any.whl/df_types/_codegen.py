import json
import os
from pathlib import Path
from textwrap import indent

from df_types.config import DFTypesConfig
from df_types._infer_types import InferredTypeNames, InferredLiterals


_HEADER = """
# This file was generated by df-types. Do not edit.

from __future__ import annotations

from dataclasses import dataclass

import pandas as pd
""".lstrip()


def _format_dict(d: dict[str, str], max_len: int, indent: int = 4) -> str:
    if len(repr(d)) < max_len:
        return json.dumps(d)  # For double quotes
    return _format_dict_multiline(d, indent)


def _format_dict_multiline(d: dict, indent: int = 4) -> str:
    """Format a dictionary across multiple lines with indentation."""
    inner_indent = " " * (indent + 4)
    items = f"\n{inner_indent}".join(
        f"{json.dumps(k)}: {json.dumps(v)}," for k, v in d.items()
    )
    return f"{{\n{inner_indent}{items}\n{' ' * indent}}}"


def _format_imports(type_names: set[tuple[str, str]]) -> str:
    return _join_import_lines(type_names)


def _join_import_lines(type_names: set[tuple[str, str]]) -> str:
    """Join import lines for a set of (module, name) tuples."""
    return "\n".join(
        f"from {module} import {name}" for module, name in type_names if module
    )


def _format_dataclass(
    col_to_attr_names: dict[str, str],
    types: dict[str, InferredTypeNames | InferredLiterals],
    config: DFTypesConfig,
) -> str:
    class_name = _validate_class_name(config.class_name)
    content = _format_dataclass_header(class_name, config.use_slots)
    imports = set()
    content += _format_dataclass_fields(col_to_attr_names, types, imports)
    type_checking_imports = _format_type_checking_imports(imports)
    return type_checking_imports + "\n\n" + content


def _validate_class_name(class_name: str) -> str:
    class_name = class_name.strip()
    if (
        not class_name
        or class_name[0].isdigit()
        or not class_name.replace("_", "").isalnum()
    ):
        raise ValueError(f"Invalid class name: {class_name}")
    return class_name


def _format_dataclass_header(class_name: str, use_slots: bool) -> str:
    return f"@dataclass{f'(slots=True)' if use_slots else ''}\nclass {class_name}:\n"


def _format_dataclass_fields(
    col_to_attr_names: dict[str, str],
    types: dict[str, InferredTypeNames | InferredLiterals],
    imports: set[tuple[str, str]],
) -> str:
    lines = []
    for attr_name, type_ in types.items():
        attr_name = col_to_attr_names.get(attr_name, attr_name)
        if isinstance(type_, InferredTypeNames):
            imports.update(n for n in type_.type_names if n[0])
            lines.append(_format_type_names_field(attr_name, type_))
        else:
            imports.add(("typing", "Literal"))
            imports.add(("typing", "Iterable"))
            lines.append(_format_literal_field(attr_name, type_))
    return "".join(lines)


def _format_type_names_field(attr_name: str, type_: InferredTypeNames) -> str:
    type_str = " | ".join(name for _, name in type_.type_names)
    if type_.contains_nans:
        type_str += " | None"
    return f"    {attr_name}: {type_str}\n"


def _format_literal_field(attr_name: str, type_: InferredLiterals) -> str:
    literals = ", ".join(type_.literal_reprs)
    return f"    {attr_name}: Literal[{literals}]\n"


def _format_type_checking_imports(imports: set[tuple[str, str]]) -> str:
    if not imports:
        return ""
    return (
        "from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n"
        + indent(_format_imports(imports), "    ")
        + "\n"
    )


def _format_col_to_attr_names_method(col_to_attr_names: dict[str, str]) -> str:
    return f"def col_to_attr_names() -> dict[str, str]:\n    return {_format_dict(col_to_attr_names, 80)}"


def _format_convert_method(config: DFTypesConfig) -> str:
    replace_stmt = (
        "\n    df = df.replace(float('nan'), None)" if config.nan_to_none else ""
    )
    return f"def convert(df: pd.DataFrame) -> pd.DataFrame:{replace_stmt}\n    return df.rename(columns=col_to_attr_names())"

def _format_iter_tuples_method(config: DFTypesConfig) -> str:
    return f"def iter_dataclasses(df: pd.DataFrame) -> Iterable[{config.class_name}]:\n    for row in df.itertuples(index=False):\n        yield {config.class_name}(*row)"

def generate_types(
    col_to_attr_names: dict[str, str],
    types: dict[str, InferredTypeNames | InferredLiterals],
    config: DFTypesConfig,
) -> str:
    """
    Generate the type definitions for a DataFrame
    """
    content = _HEADER
    return (
        content
        + _format_dataclass(col_to_attr_names, types, config)
        + "\n\n"
        + _format_col_to_attr_names_method(col_to_attr_names)
        + "\n\n\n"
        + _format_convert_method(config)
        + "\n\n\n"
        + _format_iter_tuples_method(config)
        + "\n"
    )


def _file_starts_with_header(file_path: str | Path) -> bool:
    with open(file_path, "r") as f:
        return f.read(len(_HEADER)).startswith(_HEADER)


def write_types(
    col_to_attr_names: dict[str, str],
    types: dict[str, InferredTypeNames | InferredLiterals],
    config: DFTypesConfig,
) -> None:
    output_file = config.output_file
    if isinstance(output_file, str) and not output_file.endswith(".py"):
        output_file += ".py"

    if os.path.exists(output_file) and not _file_starts_with_header(output_file):
        raise FileExistsError(f"File already exists: {output_file}")

    with open(output_file, "w") as f:
        f.write(generate_types(col_to_attr_names, types, config))
