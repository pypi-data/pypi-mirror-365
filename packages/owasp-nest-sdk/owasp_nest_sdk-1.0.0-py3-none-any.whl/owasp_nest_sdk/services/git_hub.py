# This file was generated by liblab | https://liblab.com/

from typing import Union
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..net.environment.environment import Environment
from ..models.utils.sentinel import SENTINEL
from ..models.utils.cast_models import cast_models
from ..models import (
    ListIssuesOrdering,
    ListLabelsOrdering,
    ListOrganizationsOrdering,
    ListReleasesOrdering,
    ListRepositoriesOrdering,
    ListUsersOrdering,
    PagedIssueSchema,
    PagedLabelSchema,
    PagedOrganizationSchema,
    PagedReleaseSchema,
    PagedRepositorySchema,
    PagedUserSchema,
    State,
    UserSchema,
)


class GitHubService(BaseService):

    @cast_models
    def list_issues(
        self,
        state: Union[State, None] = SENTINEL,
        ordering: Union[ListIssuesOrdering, None] = SENTINEL,
        page: int = SENTINEL,
        page_size: Union[int, None] = SENTINEL,
    ) -> PagedIssueSchema:
        """Retrieve a paginated list of GitHub issues.

        :param state: State of the issue, defaults to None
        :type state: State, optional
        :param ordering: Ordering field, defaults to None
        :type ordering: ListIssuesOrdering, optional
        :param page: page, defaults to None
        :type page: int, optional
        :param page_size: page_size, defaults to None
        :type page_size: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: PagedIssueSchema
        """

        Validator(State).is_optional().is_nullable().validate(state)
        Validator(ListIssuesOrdering).is_optional().is_nullable().validate(ordering)
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().is_nullable().min(1).validate(page_size)

        serialized_request = (
            Serializer(
                f"{self.base_url or Environment.DEFAULT.url}/api/v1/github/issues/",
                [self.get_api_key()],
            )
            .add_query("state", state, nullable=True)
            .add_query("ordering", ordering, nullable=True)
            .add_query("page", page)
            .add_query("page_size", page_size, nullable=True)
            .serialize()
            .set_method("GET")
        )

        response, _, _ = self.send_request(serialized_request)
        return PagedIssueSchema._unmap(response)

    @cast_models
    def list_labels(
        self,
        color: Union[str, None] = SENTINEL,
        ordering: Union[ListLabelsOrdering, None] = SENTINEL,
        page: int = SENTINEL,
        page_size: Union[int, None] = SENTINEL,
    ) -> PagedLabelSchema:
        """Retrieve a paginated list of GitHub labels.

        :param color: Color of the label, defaults to None
        :type color: str, optional
        :param ordering: Ordering field, defaults to None
        :type ordering: ListLabelsOrdering, optional
        :param page: page, defaults to None
        :type page: int, optional
        :param page_size: page_size, defaults to None
        :type page_size: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: PagedLabelSchema
        """

        Validator(str).is_optional().is_nullable().validate(color)
        Validator(ListLabelsOrdering).is_optional().is_nullable().validate(ordering)
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().is_nullable().min(1).validate(page_size)

        serialized_request = (
            Serializer(
                f"{self.base_url or Environment.DEFAULT.url}/api/v1/github/labels/",
                [self.get_api_key()],
            )
            .add_query("color", color, nullable=True)
            .add_query("ordering", ordering, nullable=True)
            .add_query("page", page)
            .add_query("page_size", page_size, nullable=True)
            .serialize()
            .set_method("GET")
        )

        response, _, _ = self.send_request(serialized_request)
        return PagedLabelSchema._unmap(response)

    @cast_models
    def list_organizations(
        self,
        location: Union[str, None] = SENTINEL,
        ordering: Union[ListOrganizationsOrdering, None] = SENTINEL,
        page: int = SENTINEL,
        page_size: Union[int, None] = SENTINEL,
    ) -> PagedOrganizationSchema:
        """Retrieve a paginated list of GitHub organizations.

        :param location: Location of the organization, defaults to None
        :type location: str, optional
        :param ordering: Ordering field, defaults to None
        :type ordering: ListOrganizationsOrdering, optional
        :param page: page, defaults to None
        :type page: int, optional
        :param page_size: page_size, defaults to None
        :type page_size: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: PagedOrganizationSchema
        """

        Validator(str).is_optional().is_nullable().validate(location)
        Validator(ListOrganizationsOrdering).is_optional().is_nullable().validate(
            ordering
        )
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().is_nullable().min(1).validate(page_size)

        serialized_request = (
            Serializer(
                f"{self.base_url or Environment.DEFAULT.url}/api/v1/github/organizations/",
                [self.get_api_key()],
            )
            .add_query("location", location, nullable=True)
            .add_query("ordering", ordering, nullable=True)
            .add_query("page", page)
            .add_query("page_size", page_size, nullable=True)
            .serialize()
            .set_method("GET")
        )

        response, _, _ = self.send_request(serialized_request)
        return PagedOrganizationSchema._unmap(response)

    @cast_models
    def list_releases(
        self,
        tag_name: Union[str, None] = SENTINEL,
        ordering: Union[ListReleasesOrdering, None] = SENTINEL,
        page: int = SENTINEL,
        page_size: Union[int, None] = SENTINEL,
    ) -> PagedReleaseSchema:
        """Retrieve a paginated list of GitHub releases.

        :param tag_name: Tag name of the release, defaults to None
        :type tag_name: str, optional
        :param ordering: Ordering field, defaults to None
        :type ordering: ListReleasesOrdering, optional
        :param page: page, defaults to None
        :type page: int, optional
        :param page_size: page_size, defaults to None
        :type page_size: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: PagedReleaseSchema
        """

        Validator(str).is_optional().is_nullable().validate(tag_name)
        Validator(ListReleasesOrdering).is_optional().is_nullable().validate(ordering)
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().is_nullable().min(1).validate(page_size)

        serialized_request = (
            Serializer(
                f"{self.base_url or Environment.DEFAULT.url}/api/v1/github/releases/",
                [self.get_api_key()],
            )
            .add_query("tag_name", tag_name, nullable=True)
            .add_query("ordering", ordering, nullable=True)
            .add_query("page", page)
            .add_query("page_size", page_size, nullable=True)
            .serialize()
            .set_method("GET")
        )

        response, _, _ = self.send_request(serialized_request)
        return PagedReleaseSchema._unmap(response)

    @cast_models
    def list_repositories(
        self,
        ordering: Union[ListRepositoriesOrdering, None] = SENTINEL,
        page: int = SENTINEL,
        page_size: Union[int, None] = SENTINEL,
    ) -> PagedRepositorySchema:
        """Retrieve a paginated list of GitHub repositories.

        :param ordering: Ordering field, defaults to None
        :type ordering: ListRepositoriesOrdering, optional
        :param page: page, defaults to None
        :type page: int, optional
        :param page_size: page_size, defaults to None
        :type page_size: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: PagedRepositorySchema
        """

        Validator(ListRepositoriesOrdering).is_optional().is_nullable().validate(
            ordering
        )
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().is_nullable().min(1).validate(page_size)

        serialized_request = (
            Serializer(
                f"{self.base_url or Environment.DEFAULT.url}/api/v1/github/repositories/",
                [self.get_api_key()],
            )
            .add_query("ordering", ordering, nullable=True)
            .add_query("page", page)
            .add_query("page_size", page_size, nullable=True)
            .serialize()
            .set_method("GET")
        )

        response, _, _ = self.send_request(serialized_request)
        return PagedRepositorySchema._unmap(response)

    @cast_models
    def list_users(
        self,
        company: Union[str, None] = SENTINEL,
        location: Union[str, None] = SENTINEL,
        ordering: Union[ListUsersOrdering, None] = SENTINEL,
        page: int = SENTINEL,
        page_size: Union[int, None] = SENTINEL,
    ) -> PagedUserSchema:
        """Retrieve a paginated list of GitHub users.

        :param company: Company of the user, defaults to None
        :type company: str, optional
        :param location: Location of the user, defaults to None
        :type location: str, optional
        :param ordering: Ordering field, defaults to None
        :type ordering: ListUsersOrdering, optional
        :param page: page, defaults to None
        :type page: int, optional
        :param page_size: page_size, defaults to None
        :type page_size: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: PagedUserSchema
        """

        Validator(str).is_optional().is_nullable().validate(company)
        Validator(str).is_optional().is_nullable().validate(location)
        Validator(ListUsersOrdering).is_optional().is_nullable().validate(ordering)
        Validator(int).is_optional().min(1).validate(page)
        Validator(int).is_optional().is_nullable().min(1).validate(page_size)

        serialized_request = (
            Serializer(
                f"{self.base_url or Environment.DEFAULT.url}/api/v1/github/users/",
                [self.get_api_key()],
            )
            .add_query("company", company, nullable=True)
            .add_query("location", location, nullable=True)
            .add_query("ordering", ordering, nullable=True)
            .add_query("page", page)
            .add_query("page_size", page_size, nullable=True)
            .serialize()
            .set_method("GET")
        )

        response, _, _ = self.send_request(serialized_request)
        return PagedUserSchema._unmap(response)

    @cast_models
    def get_user(self, login: str) -> UserSchema:
        """Retrieve a GitHub user by login.

        :param login: login
        :type login: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: UserSchema
        """

        Validator(str).validate(login)

        serialized_request = (
            Serializer(
                f"{self.base_url or Environment.DEFAULT.url}/api/v1/github/users/{{login}}",
                [self.get_api_key()],
            )
            .add_path("login", login)
            .serialize()
            .set_method("GET")
        )

        response, status, _ = self.send_request(serialized_request)
        return UserSchema._unmap(response)
