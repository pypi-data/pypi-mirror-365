<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todo MCP Server - Real-time Dashboard</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .card h3 {
            margin-top: 0;
            color: #333;
        }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        .log-entry.info {
            color: #0066cc;
        }
        .log-entry.success {
            color: #28a745;
        }
        .log-entry.error {
            color: #dc3545;
        }
        .log-entry.warning {
            color: #ffc107;
        }
        .controls {
            margin-bottom: 20px;
        }
        .btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .btn:hover {
            background-color: #0056b3;
        }
        .btn.danger {
            background-color: #dc3545;
        }
        .btn.danger:hover {
            background-color: #c82333;
        }
        .input-group {
            display: flex;
            margin-bottom: 10px;
        }
        .input-group input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px 0 0 5px;
        }
        .input-group button {
            border-radius: 0 5px 5px 0;
        }
        .task-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .task-item {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }
        .task-item.pending {
            border-left: 4px solid #ffc107;
        }
        .task-item.in_progress {
            border-left: 4px solid #007bff;
        }
        .task-item.completed {
            border-left: 4px solid #28a745;
        }
        .task-item.blocked {
            border-left: 4px solid #dc3545;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Todo MCP Server - Real-time Dashboard</h1>
            <p>Server-Sent Events (SSE) and WebSocket Demo</p>
            <div>
                SSE Status: <span id="sse-status" class="status disconnected">Disconnected</span>
                WebSocket Status: <span id="ws-status" class="status disconnected">Disconnected</span>
            </div>
        </div>

        <div class="controls">
            <button class="btn" onclick="connectSSE()">Connect SSE</button>
            <button class="btn" onclick="disconnectSSE()">Disconnect SSE</button>
            <button class="btn" onclick="connectWebSocket()">Connect WebSocket</button>
            <button class="btn" onclick="disconnectWebSocket()">Disconnect WebSocket</button>
            <button class="btn" onclick="clearLogs()">Clear Logs</button>
            <button class="btn" onclick="loadTasks()">Load Tasks</button>
        </div>

        <div class="grid">
            <div class="card">
                <h3>Create Task</h3>
                <div class="input-group">
                    <input type="text" id="task-title" placeholder="Task title">
                    <button class="btn" onclick="createTask()">Create</button>
                </div>
                <div class="input-group">
                    <input type="text" id="task-description" placeholder="Task description">
                </div>
                <div class="input-group">
                    <select id="task-priority">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                        <option value="urgent">Urgent</option>
                    </select>
                    <input type="text" id="task-tags" placeholder="Tags (comma-separated)">
                </div>
                <div id="create-progress" class="progress-bar" style="display: none;">
                    <div id="create-progress-fill" class="progress-fill" style="width: 0%;"></div>
                </div>
            </div>

            <div class="card">
                <h3>Server Statistics</h3>
                <div id="server-stats">
                    <p>Total Tasks: <span id="total-tasks">-</span></p>
                    <p>Pending: <span id="pending-tasks">-</span></p>
                    <p>In Progress: <span id="in-progress-tasks">-</span></p>
                    <p>Completed: <span id="completed-tasks">-</span></p>
                    <p>Blocked: <span id="blocked-tasks">-</span></p>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h3>Event Log</h3>
                <div id="event-log" class="log"></div>
            </div>

            <div class="card">
                <h3>Recent Tasks</h3>
                <div id="task-list" class="task-list"></div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let webSocket = null;
        const serverUrl = window.location.origin;

        function log(message, type = 'info') {
            const logElement = document.getElementById('event-log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateStatus(elementId, connected) {
            const element = document.getElementById(elementId);
            element.textContent = connected ? 'Connected' : 'Disconnected';
            element.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }

        function connectSSE() {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource(`${serverUrl}/events`);
            
            eventSource.onopen = function(event) {
                updateStatus('sse-status', true);
                log('SSE connection opened', 'success');
            };

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                log(`SSE message: ${JSON.stringify(data)}`, 'info');
            };

            eventSource.addEventListener('connected', function(event) {
                const data = JSON.parse(event.data);
                log(`Connected to server: ${data.message}`, 'success');
            });

            eventSource.addEventListener('heartbeat', function(event) {
                const data = JSON.parse(event.data);
                log(`Heartbeat: ${data.timestamp}`, 'info');
            });

            eventSource.addEventListener('tool_executed', function(event) {
                const data = JSON.parse(event.data);
                log(`Tool executed: ${data.tool}`, 'success');
                if (data.tool === 'create_task' || data.tool === 'update_task_status') {
                    loadTasks();
                    loadStats();
                }
            });

            eventSource.addEventListener('task_created', function(event) {
                const data = JSON.parse(event.data);
                log(`Task created: ${data.task.title}`, 'success');
                addTaskToList(data.task);
            });

            eventSource.addEventListener('task_updated', function(event) {
                const data = JSON.parse(event.data);
                log(`Task updated: ${data.task.title}`, 'info');
                updateTaskInList(data.task);
            });

            eventSource.onerror = function(event) {
                updateStatus('sse-status', false);
                log('SSE connection error', 'error');
            };
        }

        function disconnectSSE() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
                updateStatus('sse-status', false);
                log('SSE connection closed', 'warning');
            }
        }

        function connectWebSocket() {
            if (webSocket) {
                webSocket.close();
            }

            const wsUrl = serverUrl.replace('http', 'ws') + '/ws';
            webSocket = new WebSocket(wsUrl);

            webSocket.onopen = function(event) {
                updateStatus('ws-status', true);
                log('WebSocket connection opened', 'success');
            };

            webSocket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                log(`WebSocket message: ${data.type}`, 'info');
                
                if (data.type === 'tool_result') {
                    log(`Tool result: ${data.tool} - ${data.success ? 'Success' : 'Failed'}`, 
                        data.success ? 'success' : 'error');
                }
            };

            webSocket.onclose = function(event) {
                updateStatus('ws-status', false);
                log('WebSocket connection closed', 'warning');
            };

            webSocket.onerror = function(event) {
                updateStatus('ws-status', false);
                log('WebSocket connection error', 'error');
            };
        }

        function disconnectWebSocket() {
            if (webSocket) {
                webSocket.close();
                webSocket = null;
                updateStatus('ws-status', false);
                log('WebSocket connection closed', 'warning');
            }
        }

        function clearLogs() {
            document.getElementById('event-log').innerHTML = '';
        }

        async function createTask() {
            const title = document.getElementById('task-title').value;
            const description = document.getElementById('task-description').value;
            const priority = document.getElementById('task-priority').value;
            const tags = document.getElementById('task-tags').value.split(',').map(t => t.trim()).filter(t => t);

            if (!title) {
                log('Task title is required', 'error');
                return;
            }

            const progressBar = document.getElementById('create-progress');
            const progressFill = document.getElementById('create-progress-fill');
            
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';

            try {
                const response = await fetch(`${serverUrl}/stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tool: 'create_task',
                        parameters: {
                            title: title,
                            description: description,
                            priority: priority,
                            tags: tags
                        }
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n').filter(line => line.trim());

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                
                                if (data.status === 'processing' && data.progress) {
                                    progressFill.style.width = `${data.progress}%`;
                                } else if (data.status === 'completed') {
                                    progressFill.style.width = '100%';
                                    log(`Task created successfully: ${title}`, 'success');
                                    
                                    // Clear form
                                    document.getElementById('task-title').value = '';
                                    document.getElementById('task-description').value = '';
                                    document.getElementById('task-tags').value = '';
                                    
                                    // Hide progress bar after delay
                                    setTimeout(() => {
                                        progressBar.style.display = 'none';
                                    }, 1000);
                                    
                                    loadTasks();
                                    loadStats();
                                } else if (data.status === 'error') {
                                    log(`Task creation failed: ${data.error}`, 'error');
                                    progressBar.style.display = 'none';
                                }
                            } catch (e) {
                                console.error('Failed to parse streaming data:', e);
                            }
                        }
                    }
                }
            } catch (error) {
                log(`Failed to create task: ${error.message}`, 'error');
                progressBar.style.display = 'none';
            }
        }

        async function loadTasks() {
            try {
                const response = await fetch(`${serverUrl}/tools/list_tasks`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ limit: 10 })
                });

                const data = await response.json();
                if (data.success) {
                    const result = JSON.parse(data.result);
                    if (result.success) {
                        displayTasks(result.tasks);
                    }
                }
            } catch (error) {
                log(`Failed to load tasks: ${error.message}`, 'error');
            }
        }

        async function loadStats() {
            try {
                const response = await fetch(`${serverUrl}/tools/get_task_statistics`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                });

                const data = await response.json();
                if (data.success) {
                    const result = JSON.parse(data.result);
                    if (result.success) {
                        const stats = result.statistics;
                        document.getElementById('total-tasks').textContent = stats.total_tasks || 0;
                        document.getElementById('pending-tasks').textContent = stats.status_distribution?.pending || 0;
                        document.getElementById('in-progress-tasks').textContent = stats.status_distribution?.in_progress || 0;
                        document.getElementById('completed-tasks').textContent = stats.status_distribution?.completed || 0;
                        document.getElementById('blocked-tasks').textContent = stats.status_distribution?.blocked || 0;
                    }
                }
            } catch (error) {
                log(`Failed to load statistics: ${error.message}`, 'error');
            }
        }

        function displayTasks(tasks) {
            const taskList = document.getElementById('task-list');
            taskList.innerHTML = '';

            tasks.forEach(task => {
                addTaskToList(task);
            });
        }

        function addTaskToList(task) {
            const taskList = document.getElementById('task-list');
            const taskElement = document.createElement('div');
            taskElement.className = `task-item ${task.status}`;
            taskElement.id = `task-${task.id}`;
            
            taskElement.innerHTML = `
                <div style="font-weight: bold;">${task.title}</div>
                <div style="font-size: 12px; color: #666; margin: 5px 0;">
                    Status: ${task.status} | Priority: ${task.priority}
                </div>
                <div style="font-size: 12px;">${task.description || 'No description'}</div>
                ${task.tags && task.tags.length > 0 ? 
                    `<div style="margin-top: 5px;">
                        ${task.tags.map(tag => `<span style="background: #e9ecef; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 5px;">${tag}</span>`).join('')}
                    </div>` : ''
                }
            `;
            
            taskList.insertBefore(taskElement, taskList.firstChild);
        }

        function updateTaskInList(task) {
            const existingElement = document.getElementById(`task-${task.id}`);
            if (existingElement) {
                existingElement.remove();
            }
            addTaskToList(task);
        }

        // Initialize connections on page load
        window.onload = function() {
            log('Page loaded, initializing connections...', 'info');
            connectSSE();
            loadTasks();
            loadStats();
        };

        // Cleanup on page unload
        window.onbeforeunload = function() {
            disconnectSSE();
            disconnectWebSocket();
        };
    </script>
</body>
</html>