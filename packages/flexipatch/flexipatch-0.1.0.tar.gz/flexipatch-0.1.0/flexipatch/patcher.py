# flexipatch/patcher.py

import re
from typing import List

class RobustPatcher:
    """
    A robust patch utility designed to work with imperfect code modifications,
    often generated by Large Language Models. It forgives differences in
    line endings and surrounding whitespace in context lines.
    """

    def __init__(self):
        # Regex to parse the hunk header of a unified diff
        # e.g., @@ -1,5 +1,6 @@
        self.hunk_header_re = re.compile(
            r"^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@"
        )

    def _normalize_line_endings(self, text: str) -> str:
        """Converts all line endings to a single \\n."""
        return text.replace("\r\n", "\n").replace("\r", "\n")

    def apply_patch(self, original_content: str, patch_text: str) -> str:
        """
        Applies a patch to the original content in a forgiving manner.

        Args:
            original_content: The original string content to be patched.
            patch_text: A string containing the patch in unified diff format.

        Returns:
            The patched string content.

        Raises:
            ValueError: If the patch is malformed or cannot be applied.
        """
        original_lines = self._normalize_line_endings(original_content).splitlines()
        patch_lines = self._normalize_line_endings(patch_text).splitlines()
        
        # Filter out header lines like --- a/file.txt and +++ b/file.txt
        patch_lines = [line for line in patch_lines if not (line.startswith("--- ") or line.startswith("+++ "))]


        patched_lines: List[str] = []
        original_line_idx = 0
        patch_line_idx = 0

        while patch_line_idx < len(patch_lines):
            line = patch_lines[patch_line_idx]
            match = self.hunk_header_re.match(line)

            if not match:
                patch_line_idx += 1
                continue
            
            # This is a hunk header, let's process the hunk
            old_start = int(match.group(1))
            new_start = int(match.group(4))
            
            # Copy lines from original that are before this hunk
            # The line numbers in patches are 1-indexed
            lines_before_hunk = old_start - 1 - original_line_idx
            if lines_before_hunk > 0:
                patched_lines.extend(original_lines[original_line_idx:original_line_idx + lines_before_hunk])
                original_line_idx += lines_before_hunk

            patch_line_idx += 1 # Move to the first line of the hunk content

            # Process lines within the hunk
            while patch_line_idx < len(patch_lines) and not patch_lines[patch_line_idx].startswith("@@"):
                hunk_line = patch_lines[patch_line_idx]
                if not hunk_line: # handle empty lines in patch
                    patch_line_idx += 1
                    continue
                
                op = hunk_line[0]
                content = hunk_line[1:]

                if op == ' ': # Context line
                    if original_line_idx >= len(original_lines):
                        raise ValueError(f"Patch context goes beyond end of original file.")
                    
                    # Forgiving comparison: strip whitespace
                    if original_lines[original_line_idx].strip() != content.strip():
                        raise ValueError(
                            f"Context mismatch at original line {original_line_idx + 1}:\n"
                            f"Expected: '{original_lines[original_line_idx]}'\n"
                            f"Got (from patch): '{content}'"
                        )
                    patched_lines.append(original_lines[original_line_idx])
                    original_line_idx += 1
                
                elif op == '-': # Deletion line
                    if original_line_idx >= len(original_lines):
                         raise ValueError(f"Patch deletion goes beyond end of original file.")
                    
                    # Forgiving comparison for deletion as well
                    if original_lines[original_line_idx].strip() != content.strip():
                         raise ValueError(
                            f"Deletion mismatch at original line {original_line_idx + 1}:\n"
                            f"Expected to delete: '{original_lines[original_line_idx]}'\n"
                            f"Got (from patch): '{content}'"
                        )
                    original_line_idx += 1 # Consume the original line
                
                elif op == '+': # Addition line
                    patched_lines.append(content)
                
                elif hunk_line.startswith("\\ No newline at end of file"):
                    # This is handled at the end, just consume the line
                    pass

                else:
                    raise ValueError(f"Malformed hunk line: {hunk_line}")

                patch_line_idx += 1

        # Add any remaining lines from the original file
        if original_line_idx < len(original_lines):
            patched_lines.extend(original_lines[original_line_idx:])
        
        # Reconstruct the final text
        final_text = "\n".join(patched_lines)
        
        # Handle the "\ No newline at end of file" case for the *new* file.
        # If the original had a newline but the patch removes it, we need to strip.
        if patch_text.endswith("\\ No newline at end of file"):
             if final_text.endswith("\n"):
                 return final_text[:-1]

        # If original content was not empty and did not end with a newline,
        # and the patch didn't add one, preserve that.
        if original_content and not original_content.endswith('\n') and not final_text.endswith('\n'):
             return final_text
             
        # By default, if there is content, ensure it ends with a newline,
        # unless explicitly told not to by the patch.
        if final_text and not patch_text.endswith("\\ No newline at end of file"):
            return final_text + "\n"

        return final_text