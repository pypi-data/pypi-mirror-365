# DO NOT EDIT!
# This code was auto generated by the `protoc-gen-pokete-resources-python` plugin,
# part of the pokete project, by <lxgr@protonmail.com>
from typing import TypedDict
from . import (Coords, CoordsDict, )


class StationGenDict(TypedDict):
    additionals: list[str]
    desc: str
    text: str
    color: str
    a_next: str | None
    w_next: str | None
    s_next: str | None
    d_next: str | None


class StationGen:
    def __init__(
        self,
        additionals: list[str],
        desc: str,
        text: str,
        color: str,
        a_next: str | None,
        w_next: str | None,
        s_next: str | None,
        d_next: str | None
    ):
        self.additionals: list[str] = additionals
        self.desc: str = desc
        self.text: str = text
        self.color: str = color
        self.a_next: str | None = a_next
        self.w_next: str | None = w_next
        self.s_next: str | None = s_next
        self.d_next: str | None = d_next

    @classmethod
    def from_dict(cls, _d: StationGenDict | None) -> "StationGen | None":
        if _d is None:
            return None
        return cls(
            additionals=_d["additionals"],
            desc=_d["desc"],
            text=_d["text"],
            color=_d["color"],
            a_next=_d.get("a_next", None),
            w_next=_d.get("w_next", None),
            s_next=_d.get("s_next", None),
            d_next=_d.get("d_next", None),
        )

    @staticmethod
    def validate(_d: StationGenDict) -> bool:
        return all([
            "additionals" in _d and all(type(i) is str for i in _d["additionals"]),
            "desc" in _d and type(_d["desc"]) is str,
            "text" in _d and type(_d["text"]) is str,
            "color" in _d and type(_d["color"]) is str,
            type(_d.get("a_next", None)) is str or _d.get("a_next", None) is None,
            type(_d.get("w_next", None)) is str or _d.get("w_next", None) is None,
            type(_d.get("s_next", None)) is str or _d.get("s_next", None) is None,
            type(_d.get("d_next", None)) is str or _d.get("d_next", None) is None,
        ])

    def to_dict(self) -> StationGenDict:
        ret: StationGenDict = {}
        
        ret["additionals"] = self.additionals
        ret["desc"] = self.desc
        ret["text"] = self.text
        ret["color"] = self.color
        if self.a_next is not None:
            ret["a_next"] = self.a_next
        if self.w_next is not None:
            ret["w_next"] = self.w_next
        if self.s_next is not None:
            ret["s_next"] = self.s_next
        if self.d_next is not None:
            ret["d_next"] = self.d_next

        return ret


class StationDict(TypedDict):
    gen: "StationGenDict"
    add: "CoordsDict"


class Station:
    def __init__(
        self,
        gen: "StationGen",
        add: "Coords"
    ):
        self.gen: "StationGen" = gen
        self.add: "Coords" = add

    @classmethod
    def from_dict(cls, _d: StationDict | None) -> "Station | None":
        if _d is None:
            return None
        return cls(
            gen=StationGen.from_dict(_d["gen"]),
            add=Coords.from_dict(_d["add"]),
        )

    @staticmethod
    def validate(_d: StationDict) -> bool:
        return all([
            "gen" in _d and StationGen.validate(_d["gen"]),
            "add" in _d and Coords.validate(_d["add"]),
        ])

    def to_dict(self) -> StationDict:
        ret: StationDict = {}
        
        ret["gen"] = StationGen.to_dict(self.gen)
        ret["add"] = Coords.to_dict(self.add)

        return ret


class DecorationGenDict(TypedDict):
    text: str
    color: str


class DecorationGen:
    def __init__(
        self,
        text: str,
        color: str
    ):
        self.text: str = text
        self.color: str = color

    @classmethod
    def from_dict(cls, _d: DecorationGenDict | None) -> "DecorationGen | None":
        if _d is None:
            return None
        return cls(
            text=_d["text"],
            color=_d["color"],
        )

    @staticmethod
    def validate(_d: DecorationGenDict) -> bool:
        return all([
            "text" in _d and type(_d["text"]) is str,
            "color" in _d and type(_d["color"]) is str,
        ])

    def to_dict(self) -> DecorationGenDict:
        ret: DecorationGenDict = {}
        
        ret["text"] = self.text
        ret["color"] = self.color

        return ret


class DecorationDict(TypedDict):
    gen: "DecorationGenDict"
    add: "CoordsDict"


class Decoration:
    def __init__(
        self,
        gen: "DecorationGen",
        add: "Coords"
    ):
        self.gen: "DecorationGen" = gen
        self.add: "Coords" = add

    @classmethod
    def from_dict(cls, _d: DecorationDict | None) -> "Decoration | None":
        if _d is None:
            return None
        return cls(
            gen=DecorationGen.from_dict(_d["gen"]),
            add=Coords.from_dict(_d["add"]),
        )

    @staticmethod
    def validate(_d: DecorationDict) -> bool:
        return all([
            "gen" in _d and DecorationGen.validate(_d["gen"]),
            "add" in _d and Coords.validate(_d["add"]),
        ])

    def to_dict(self) -> DecorationDict:
        ret: DecorationDict = {}
        
        ret["gen"] = DecorationGen.to_dict(self.gen)
        ret["add"] = Coords.to_dict(self.add)

        return ret
