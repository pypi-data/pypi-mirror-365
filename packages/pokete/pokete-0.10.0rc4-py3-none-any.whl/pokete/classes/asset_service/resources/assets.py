# DO NOT EDIT!
# This code was auto generated by the `protoc-gen-pokete-resources-python` plugin,
# part of the pokete project, by <lxgr@protonmail.com>
from typing import TypedDict
from .base import (Item, ItemDict, Poke, PokeDict, Attack, AttackDict, Nature, NatureDict, Weather, WeatherDict, Type, TypeDict, Achievement, AchievementDict, )
from . import (Trainer, TrainerDict, NPC, NPCDict, Obmap, ObmapDict, Station, StationDict, Decoration, DecorationDict, Map, MapDict, )


class BaseAssetsDict(TypedDict):
    items: dict[str, "ItemDict"]
    pokes: dict[str, "PokeDict"]
    attacks: dict[str, "AttackDict"]
    natures: dict[str, "NatureDict"]
    weathers: dict[str, "WeatherDict"]
    types: dict[str, "TypeDict"]
    sub_types: list[str]
    achievements: dict[str, "AchievementDict"]


class BaseAssets:
    def __init__(
        self,
        items: dict[str, "Item"],
        pokes: dict[str, "Poke"],
        attacks: dict[str, "Attack"],
        natures: dict[str, "Nature"],
        weathers: dict[str, "Weather"],
        types: dict[str, "Type"],
        sub_types: list[str],
        achievements: dict[str, "Achievement"]
    ):
        self.items: dict[str, "Item"] = items
        self.pokes: dict[str, "Poke"] = pokes
        self.attacks: dict[str, "Attack"] = attacks
        self.natures: dict[str, "Nature"] = natures
        self.weathers: dict[str, "Weather"] = weathers
        self.types: dict[str, "Type"] = types
        self.sub_types: list[str] = sub_types
        self.achievements: dict[str, "Achievement"] = achievements

    @classmethod
    def from_dict(cls, _d: BaseAssetsDict | None) -> "BaseAssets | None":
        if _d is None:
            return None
        return cls(
            items={i: Item.from_dict(item) for i, item in _d["items"].items()},
            pokes={i: Poke.from_dict(item) for i, item in _d["pokes"].items()},
            attacks={i: Attack.from_dict(item) for i, item in _d["attacks"].items()},
            natures={i: Nature.from_dict(item) for i, item in _d["natures"].items()},
            weathers={i: Weather.from_dict(item) for i, item in _d["weathers"].items()},
            types={i: Type.from_dict(item) for i, item in _d["types"].items()},
            sub_types=_d["sub_types"],
            achievements={i: Achievement.from_dict(item) for i, item in _d["achievements"].items()},
        )

    @staticmethod
    def validate(_d: BaseAssetsDict) -> bool:
        return all([
            "items" in _d and all(Item.validate(item) for _, item in _d["items"].items()),
            "pokes" in _d and all(Poke.validate(item) for _, item in _d["pokes"].items()),
            "attacks" in _d and all(Attack.validate(item) for _, item in _d["attacks"].items()),
            "natures" in _d and all(Nature.validate(item) for _, item in _d["natures"].items()),
            "weathers" in _d and all(Weather.validate(item) for _, item in _d["weathers"].items()),
            "types" in _d and all(Type.validate(item) for _, item in _d["types"].items()),
            "sub_types" in _d and all(type(i) is str for i in _d["sub_types"]),
            "achievements" in _d and all(Achievement.validate(item) for _, item in _d["achievements"].items()),
        ])

    def to_dict(self) -> BaseAssetsDict:
        ret: BaseAssetsDict = {}
        
        ret["items"] = {i: Item.to_dict(item) for i, item in self.items.items()}
        ret["pokes"] = {i: Poke.to_dict(item) for i, item in self.pokes.items()}
        ret["attacks"] = {i: Attack.to_dict(item) for i, item in self.attacks.items()}
        ret["natures"] = {i: Nature.to_dict(item) for i, item in self.natures.items()}
        ret["weathers"] = {i: Weather.to_dict(item) for i, item in self.weathers.items()}
        ret["types"] = {i: Type.to_dict(item) for i, item in self.types.items()}
        ret["sub_types"] = self.sub_types
        ret["achievements"] = {i: Achievement.to_dict(item) for i, item in self.achievements.items()}

        return ret


class MapTrainersDict(TypedDict):
    trainers: list["TrainerDict"]


class MapTrainers:
    def __init__(
        self,
        trainers: list["Trainer"]
    ):
        self.trainers: list["Trainer"] = trainers

    @classmethod
    def from_dict(cls, _d: MapTrainersDict | None) -> "MapTrainers | None":
        if _d is None:
            return None
        return cls(
            trainers=[Trainer.from_dict(i) for i in _d["trainers"]],
        )

    @staticmethod
    def validate(_d: MapTrainersDict) -> bool:
        return all([
            "trainers" in _d and all(Trainer.validate(i) for i in _d["trainers"]),
        ])

    def to_dict(self) -> MapTrainersDict:
        ret: MapTrainersDict = {}
        
        ret["trainers"] = [Trainer.to_dict(i) for i in self.trainers]

        return ret


class AssetsDict(TypedDict):
    trainers: dict[str, "MapTrainersDict"]
    npcs: dict[str, "NPCDict"]
    obmaps: dict[str, "ObmapDict"]
    stations: dict[str, "StationDict"]
    decorations: dict[str, "DecorationDict"]
    maps: dict[str, "MapDict"]


class Assets:
    def __init__(
        self,
        trainers: dict[str, "MapTrainers"],
        npcs: dict[str, "NPC"],
        obmaps: dict[str, "Obmap"],
        stations: dict[str, "Station"],
        decorations: dict[str, "Decoration"],
        maps: dict[str, "Map"]
    ):
        self.trainers: dict[str, "MapTrainers"] = trainers
        self.npcs: dict[str, "NPC"] = npcs
        self.obmaps: dict[str, "Obmap"] = obmaps
        self.stations: dict[str, "Station"] = stations
        self.decorations: dict[str, "Decoration"] = decorations
        self.maps: dict[str, "Map"] = maps

    @classmethod
    def from_dict(cls, _d: AssetsDict | None) -> "Assets | None":
        if _d is None:
            return None
        return cls(
            trainers={i: MapTrainers.from_dict(item) for i, item in _d["trainers"].items()},
            npcs={i: NPC.from_dict(item) for i, item in _d["npcs"].items()},
            obmaps={i: Obmap.from_dict(item) for i, item in _d["obmaps"].items()},
            stations={i: Station.from_dict(item) for i, item in _d["stations"].items()},
            decorations={i: Decoration.from_dict(item) for i, item in _d["decorations"].items()},
            maps={i: Map.from_dict(item) for i, item in _d["maps"].items()},
        )

    @staticmethod
    def validate(_d: AssetsDict) -> bool:
        return all([
            "trainers" in _d and all(MapTrainers.validate(item) for _, item in _d["trainers"].items()),
            "npcs" in _d and all(NPC.validate(item) for _, item in _d["npcs"].items()),
            "obmaps" in _d and all(Obmap.validate(item) for _, item in _d["obmaps"].items()),
            "stations" in _d and all(Station.validate(item) for _, item in _d["stations"].items()),
            "decorations" in _d and all(Decoration.validate(item) for _, item in _d["decorations"].items()),
            "maps" in _d and all(Map.validate(item) for _, item in _d["maps"].items()),
        ])

    def to_dict(self) -> AssetsDict:
        ret: AssetsDict = {}
        
        ret["trainers"] = {i: MapTrainers.to_dict(item) for i, item in self.trainers.items()}
        ret["npcs"] = {i: NPC.to_dict(item) for i, item in self.npcs.items()}
        ret["obmaps"] = {i: Obmap.to_dict(item) for i, item in self.obmaps.items()}
        ret["stations"] = {i: Station.to_dict(item) for i, item in self.stations.items()}
        ret["decorations"] = {i: Decoration.to_dict(item) for i, item in self.decorations.items()}
        ret["maps"] = {i: Map.to_dict(item) for i, item in self.maps.items()}

        return ret
