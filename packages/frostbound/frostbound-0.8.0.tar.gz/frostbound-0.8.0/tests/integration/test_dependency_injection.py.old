"""Integration tests for dependency injection functionality.

This module tests the dependency injection capabilities:
- Registering and injecting dependencies by name
- Registering and injecting dependencies by type
- Dependency override mechanisms
- Factory providers for lazy instantiation
- Error handling for missing dependencies
- Singleton behavior and registry management
"""

from __future__ import annotations

import logging
import os
from typing import Any, Protocol

import pytest

from frostbound.pydanticonf import (
    ConfigFactory,
    DynamicConfig,
    FactoryProvider,
)
from tests.integration.conftest import MemoryCache, ServiceWithDependencies


# Test protocols and classes
class CacheProtocol(Protocol):
    """Protocol for cache implementations."""

    def get(self, key: str) -> Any: ...

    def set(self, key: str, value: Any) -> None: ...


class DatabaseProtocol(Protocol):
    """Protocol for database implementations."""

    def query(self, sql: str) -> list[dict]: ...

    def execute(self, sql: str) -> None: ...


class MockDatabase:
    """Mock database for testing."""

    def __init__(self, connection_string: str):
        self.connection_string = connection_string
        self.queries: list[str] = []
        self.connected = True

    def query(self, sql: str) -> list[dict]:
        self.queries.append(sql)
        return [{"id": 1, "name": "test"}]

    def execute(self, sql: str) -> None:
        self.queries.append(sql)


class RepositoryWithDb:
    """Repository that requires database dependency."""

    def __init__(self, db: DatabaseProtocol, table_name: str = "users"):
        self.db = db
        self.table_name = table_name

    def find_all(self) -> list[dict]:
        return self.db.query(f"SELECT * FROM {self.table_name}")


class ApiClient:
    """API client with required configuration."""

    def __init__(self, base_url: str, api_key: str, timeout: int = 30):
        self.base_url = base_url
        self.api_key = api_key
        self.timeout = timeout


class TestDependencyInjectionByName:
    """Test suite for dependency injection by parameter name."""

    def test_inject_by_name_simple(self) -> None:
        """Verify basic dependency injection by parameter name."""
        # Arrange
        test_db = MockDatabase("test://localhost/db")
        test_cache = MemoryCache(max_size=50)

        ConfigFactory.register_dependency("database", test_db)
        ConfigFactory.register_dependency("cache", test_cache)
        ConfigFactory.register_dependency("api_key", "test-api-key-123")

        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "TestService",
            "max_retries": 5,
        }

        # Act
        service = ConfigFactory.create(config)

        # Assert
        assert service.__class__.__name__ == "ServiceWithDependencies"
        assert service.service_name == "TestService"
        assert service.database is test_db
        assert service.cache is test_cache
        assert service.api_key == "test-api-key-123"
        assert service.max_retries == 5
        assert service.initialized is True

    def test_inject_multiple_services(self) -> None:
        """Verify same dependencies are injected into multiple services."""
        # Arrange
        shared_db = MockDatabase("shared://localhost/db")
        shared_logger = logging.getLogger("shared.logger")

        ConfigFactory.register_dependency("database", shared_db)
        ConfigFactory.register_dependency("logger", shared_logger)

        # Create multiple services
        services = []
        for i in range(3):
            config = {
                "_target_": "tests.integration.conftest.ServiceWithDependencies",
                "service_name": f"Service{i}",
            }
            services.append(ConfigFactory.create(config))

        # Assert - All services share the same dependencies
        assert all(s.database is shared_db for s in services)
        assert all(s.logger is shared_logger for s in services)
        assert services[0].database is services[1].database
        assert services[1].logger is services[2].logger

    def test_dependency_not_found(self) -> None:
        """Verify behavior when optional dependency is not registered."""
        # Arrange - Don't register any dependencies
        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "ServiceWithoutDeps",
        }

        # Act
        service = ConfigFactory.create(config)

        # Assert - Optional dependencies are None
        assert service.database is None
        assert service.cache is None
        assert service.logger is None
        assert service.api_key is None

    def test_override_injected_dependency(self) -> None:
        """Verify explicit config values override injected dependencies."""
        # Arrange
        injected_db = MockDatabase("injected://localhost/db")
        explicit_db = MockDatabase("explicit://localhost/db")

        ConfigFactory.register_dependency("database", injected_db)
        ConfigFactory.register_dependency("api_key", "injected-key")

        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "OverrideService",
            "database": explicit_db,  # Explicit value
            "api_key": "explicit-key",  # Explicit value
        }

        # Act
        service = ConfigFactory.create(config)

        # Assert - Explicit values take precedence
        assert service.database is explicit_db
        assert service.api_key == "explicit-key"


class TestDependencyInjectionByType:
    """Test suite for dependency injection by type annotation."""

    def test_inject_by_type_simple(self) -> None:
        """Verify dependency injection by type annotation."""
        # Arrange
        test_logger = logging.getLogger("test.logger")

        # Register by both type and common parameter name
        ConfigFactory.register_type(logging.Logger, test_logger)
        ConfigFactory.register_dependency("logger", test_logger)

        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "TypedService",
        }

        # Act
        service = ConfigFactory.create(config)

        # Assert
        assert service.logger is test_logger

    def test_inject_by_protocol_type(self) -> None:
        """Verify injection works with Protocol types."""
        # Arrange
        mock_db = MockDatabase("protocol://localhost/db")
        mock_cache = MemoryCache()

        # Register by protocol type and parameter names
        ConfigFactory.register_type(DatabaseProtocol, mock_db)
        ConfigFactory.register_type(CacheProtocol, mock_cache)
        ConfigFactory.register_dependency("database", mock_db)
        ConfigFactory.register_dependency("cache", mock_cache)

        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "ProtocolService",
        }

        # Act
        service = ConfigFactory.create(config)

        # Assert
        assert service.database is mock_db
        assert service.cache is mock_cache

    def test_type_injection_with_subclass(self) -> None:
        """Verify type injection works with subclasses."""

        # Arrange
        class ExtendedCache(MemoryCache):
            def __init__(self):
                super().__init__(max_size=200)
                self.extended = True

        extended_cache = ExtendedCache()
        ConfigFactory.register_type(MemoryCache, extended_cache)
        ConfigFactory.register_dependency("cache", extended_cache)

        # Create a service that specifically wants MemoryCache type

        config = {
            "_target_": "tests.integration.conftest.CacheUser",
        }

        # Act
        user = ConfigFactory.create(config)

        # Assert
        assert isinstance(user.cache, ExtendedCache)
        assert user.cache.extended is True

    def test_mixed_name_and_type_injection(self) -> None:
        """Verify mixing injection by name and by type."""
        # Arrange
        named_db = MockDatabase("named://localhost/db")
        typed_logger = logging.getLogger("typed.logger")
        named_api_key = "named-api-key"

        ConfigFactory.register_dependency("database", named_db)
        ConfigFactory.register_type(logging.Logger, typed_logger)
        ConfigFactory.register_dependency("logger", typed_logger)  # Also register by name
        ConfigFactory.register_dependency("api_key", named_api_key)

        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "MixedInjectionService",
        }

        # Act
        service = ConfigFactory.create(config)

        # Assert
        assert service.database is named_db  # By name
        assert service.logger is typed_logger  # By type
        assert service.api_key == named_api_key  # By name


class TestDependencyRegistry:
    """Test suite for DependencyRegistry functionality."""

    def test_registry_singleton_behavior(self) -> None:
        """Verify DependencyRegistry maintains singleton behavior."""
        # Arrange
        registry1 = ConfigFactory._registry
        registry2 = ConfigFactory._registry

        # Act
        test_value = {"test": "value"}
        registry1.register("test_dep", test_value)

        # Assert
        assert registry1 is registry2
        assert registry2.get("test_dep") is test_value

    def test_clear_dependencies(self) -> None:
        """Verify clearing all dependencies works correctly."""
        # Arrange
        ConfigFactory.register_dependency("dep1", "value1")
        ConfigFactory.register_dependency("dep2", "value2")
        ConfigFactory.register_type(str, "typed_value")

        # Act
        ConfigFactory._registry.clear()

        # Assert
        assert ConfigFactory._registry.get("dep1") is None
        assert ConfigFactory._registry.get("dep2") is None
        assert ConfigFactory._registry.get_by_type(str) is None

    def test_dependency_lifecycle(self) -> None:
        """Verify dependency lifecycle through registration and usage."""
        # Arrange
        original_cache = MemoryCache(max_size=10)
        ConfigFactory.register_dependency("cache", original_cache)

        # Create service with original cache
        config1 = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "Service1",
        }
        service1 = ConfigFactory.create(config1)

        # Update dependency
        new_cache = MemoryCache(max_size=20)
        ConfigFactory.register_dependency("cache", new_cache)

        # Create new service
        config2 = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "Service2",
        }
        service2 = ConfigFactory.create(config2)

        # Assert
        assert service1.cache is original_cache
        assert service2.cache is new_cache
        assert service1.cache is not service2.cache


class TestFactoryProvider:
    """Test suite for FactoryProvider lazy instantiation."""

    def test_factory_provider_lazy_creation(self) -> None:
        """Verify FactoryProvider creates instances lazily."""
        # Arrange
        creation_count = 0

        def create_database() -> MockDatabase:
            nonlocal creation_count
            creation_count += 1
            return MockDatabase(f"lazy://localhost/db{creation_count}")

        # Register factory provider
        factory_provider = FactoryProvider(create_database)
        ConfigFactory.register_dependency("database", factory_provider)

        # Act - Create multiple services
        services = []
        for i in range(3):
            config = {
                "_target_": "tests.integration.conftest.ServiceWithDependencies",
                "service_name": f"Service{i}",
            }
            services.append(ConfigFactory.create(config))

        # Assert - Each service gets a new database instance
        assert creation_count == 3
        assert all(s.database is not None for s in services)
        assert services[0].database is not services[1].database
        assert services[0].database.connection_string == "lazy://localhost/db1"
        assert services[2].database.connection_string == "lazy://localhost/db3"

    def test_factory_provider_with_args(self) -> None:
        """Verify FactoryProvider with parameterized factory."""

        # Arrange
        def create_cache(size: int = 100) -> MemoryCache:
            return MemoryCache(max_size=size)

        # Register factory that creates caches with custom size
        factory_provider = FactoryProvider(lambda: create_cache(500))
        ConfigFactory.register_dependency("cache", factory_provider)

        # Act
        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "CacheService",
        }
        service = ConfigFactory.create(config)

        # Assert
        assert isinstance(service.cache, MemoryCache)
        assert service.cache.max_size == 500

    def test_factory_provider_error_handling(self) -> None:
        """Verify error handling in factory providers."""

        # Arrange
        def failing_factory():
            raise RuntimeError("Factory failure")

        factory_provider = FactoryProvider(failing_factory)
        ConfigFactory.register_dependency("failing_dep", factory_provider)

        # Act & Assert
        with pytest.raises(RuntimeError) as exc_info:
            config = {
                "_target_": "tests.integration.conftest.ServiceWithDependencies",
                "service_name": "FailingService",
                # Don't provide failing_dep, let injection attempt it
            }
            # The factory will fail when trying to inject
            ConfigFactory.create(config)

        assert "Factory failure" in str(exc_info.value)


class TestComplexDependencyScenarios:
    """Test complex real-world dependency injection scenarios."""

    def test_nested_dependency_injection(self) -> None:
        """Verify dependency injection in nested configurations."""
        # Arrange
        main_db = MockDatabase("main://localhost/db")
        cache_db = MockDatabase("cache://localhost/db")
        api_key = "master-api-key"

        ConfigFactory.register_dependency("main_db", main_db)
        ConfigFactory.register_dependency("cache_db", cache_db)
        ConfigFactory.register_dependency("api_key", api_key)

        # Note: This test demonstrates the concept of nested dependency injection
        # but the actual implementation would need to handle the special "_injected" target

    def test_circular_dependency_prevention(self) -> None:
        """Verify circular dependencies are handled gracefully."""

        # Arrange
        # This would create a circular dependency if not handled properly
        config_a = {
            "_target_": "tests.integration.conftest.ServiceA",
        }
        config_b = {
            "_target_": "tests.integration.conftest.ServiceB",
        }

        # Act - Should not cause infinite recursion
        service_a = ConfigFactory.create(config_a)
        service_b = ConfigFactory.create(config_b)

        # Assert
        assert service_a.service_b is None
        assert service_b.service_a is None

    def test_dependency_injection_with_dynamic_config(self) -> None:
        """Verify dependency injection works with DynamicConfig objects."""
        # Arrange
        test_logger = logging.getLogger("dynamic.logger")
        ConfigFactory.register_type(logging.Logger, test_logger)
        ConfigFactory.register_dependency("logger", test_logger)

        class ServiceConfig(DynamicConfig[ServiceWithDependencies]):
            service_name: str
            max_retries: int = 3

        # Act
        config = ServiceConfig(
            target_="tests.integration.conftest.ServiceWithDependencies",
            service_name="DynamicService",
            max_retries=5,
        )
        service = config.instantiate()

        # Assert
        assert service.__class__.__name__ == "ServiceWithDependencies"
        assert service.logger is test_logger
        assert service.service_name == "DynamicService"
        assert service.max_retries == 5

    def test_environment_based_dependency_selection(self, env_vars: dict[str, str]) -> None:
        """Verify dependencies can be selected based on environment.

        Parameters
        ----------
        env_vars : dict[str, str]
            Environment variables fixture.
        """
        # Arrange
        dev_db = MockDatabase("dev://localhost/db")
        prod_db = MockDatabase("prod://localhost/db")

        # Simulate environment-based selection
        env_vars["ENVIRONMENT"] = "production"

        if os.environ.get("ENVIRONMENT") == "production":
            ConfigFactory.register_dependency("database", prod_db)
        else:
            ConfigFactory.register_dependency("database", dev_db)

        # Act
        config = {
            "_target_": "tests.integration.conftest.ServiceWithDependencies",
            "service_name": "EnvBasedService",
        }
        service = ConfigFactory.create(config)

        # Assert
        assert service.database is prod_db
        assert service.database.connection_string == "prod://localhost/db"
