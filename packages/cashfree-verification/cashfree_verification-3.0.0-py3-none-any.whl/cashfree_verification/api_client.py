# coding: utf-8

"""
    Cashfree Verification API's.

    Cashfree's Verification APIs provide different types of verification to our merchants.

    The version of the OpenAPI document: 2023-12-18
    Contact: developers@cashfree.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from cashfree_verification.configuration import Configuration
from cashfree_verification.api_response import ApiResponse
from cashfree_verification.exceptions import (  # noqa: F401
    ApiException,
    ApiTypeError,
    ApiValueError
)

import atexit
import datetime as dt
from dateutil.parser import parse
import json
import mimetypes
from multiprocessing.pool import ThreadPool
import os
import re
import tempfile
import warnings
import base64
import hashlib
import hmac
from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated
from typing import overload, Optional, Union, Awaitable
from pydantic import Field, StrictStr
from enum import Enum

from cashfree_verification.configuration import Configuration
from cashfree_verification.api_response import ApiResponse
from cashfree_verification.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)

from urllib.parse import quote

from cashfree_verification.configuration import Configuration
from cashfree_verification.api_response import ApiResponse
import cashfree_verification.models
from cashfree_verification import rest

from cashfree_verification.models.aadhaar_masking_response_schema import *
from cashfree_verification.models.aadhaar_ocr_request_schema import *
from cashfree_verification.models.aadhaar_ocr_response_schema import *
from cashfree_verification.models.aadhaarmaskingrequestschema import *
from cashfree_verification.models.address_details import *
from cashfree_verification.models.address_details_split_address import *
from cashfree_verification.models.advance_employment_request_schema import *
from cashfree_verification.models.advance_employment_response import *
from cashfree_verification.models.advance_employment_response_input import *
from cashfree_verification.models.advance_employment_response_recent_employment_details import *
from cashfree_verification.models.advance_employment_response_recent_employment_details_employee_details import *
from cashfree_verification.models.advance_employment_response_recent_employment_details_employee_details_epfo import *
from cashfree_verification.models.advance_employment_response_recent_employment_details_employer_details import *
from cashfree_verification.models.advance_employment_response_recent_employment_details_employer_details_pf_filing_details_inner import *
from cashfree_verification.models.advance_employment_response_uan_details_inner import *
from cashfree_verification.models.advance_employment_response_uan_details_inner_additional_details import *
from cashfree_verification.models.advance_employment_response_uan_details_inner_basic_details import *
from cashfree_verification.models.advance_employment_response_uan_details_inner_employment_details import *
from cashfree_verification.models.badge_details import *
from cashfree_verification.models.bulk_pan_request_schema import *
from cashfree_verification.models.bulk_pan_request_schema_entries_inner import *
from cashfree_verification.models.cin_request_schema import *
from cashfree_verification.models.cin_response_schema import *
from cashfree_verification.models.cin_response_schema_director_details_inner import *
from cashfree_verification.models.create_request_request_schema import *
from cashfree_verification.models.create_request_response_schema import *
from cashfree_verification.models.digi_locker_verification_create_url_request_schema import *
from cashfree_verification.models.digi_locker_verification_create_url_response_schema import *
from cashfree_verification.models.digi_locker_verification_get_document_response_schema import *
from cashfree_verification.models.digi_locker_verification_get_document_response_schema_split_address import *
from cashfree_verification.models.digi_locker_verification_get_status_response_schema import *
from cashfree_verification.models.digi_locker_verification_get_status_response_schema_user_details import *
from cashfree_verification.models.driving_licence_details import *
from cashfree_verification.models.driving_licence_details_split_address import *
from cashfree_verification.models.driving_license_request_schema import *
from cashfree_verification.models.driving_license_response_schema import *
from cashfree_verification.models.driving_license_response_schema_dl_validity import *
from cashfree_verification.models.duplicate_verification_id import *
from cashfree_verification.models.e_sign_verification_create_signature_request_schema import *
from cashfree_verification.models.e_sign_verification_create_signature_request_schema_signers_inner import *
from cashfree_verification.models.e_sign_verification_create_signature_request_schema_signers_inner_sign_positions_inner import *
from cashfree_verification.models.e_sign_verification_create_signature_response_schema import *
from cashfree_verification.models.e_sign_verification_get_status_response_schema import *
from cashfree_verification.models.e_sign_verification_get_status_response_schema_signers_inner import *
from cashfree_verification.models.e_sign_verification_upload_document_request_schema import *
from cashfree_verification.models.e_sign_verification_upload_document_response_schema import *
from cashfree_verification.models.error_response_schema import *
from cashfree_verification.models.face_liveness200_response_schema import *
from cashfree_verification.models.face_liveness200_response_schema_age_range import *
from cashfree_verification.models.face_liveness200_response_schema_eye_wear import *
from cashfree_verification.models.face_liveness200_response_schema_eyes_open import *
from cashfree_verification.models.face_liveness200_response_schema_face_occluded import *
from cashfree_verification.models.face_liveness200_response_schema_gender import *
from cashfree_verification.models.face_liveness200_response_schema_pose import *
from cashfree_verification.models.face_liveness200_response_schema_quality import *
from cashfree_verification.models.face_match_request_schema import *
from cashfree_verification.models.face_match_response_schema import *
from cashfree_verification.models.get_pan_bulk_response_schema import *
from cashfree_verification.models.get_status_rpd_response_schema import *
from cashfree_verification.models.get_verify_pan_response_schema import *
from cashfree_verification.models.gstin_request_schema import *
from cashfree_verification.models.gstin_response_schema import *
from cashfree_verification.models.gstin_response_schema_additional_address_array_inner import *
from cashfree_verification.models.invalid_ip_address import *
from cashfree_verification.models.invaliddoctypeschema import *
from cashfree_verification.models.ip_verification_request_schema import *
from cashfree_verification.models.ip_verification_response_schema import *
from cashfree_verification.models.liveliness_request_schema import *
from cashfree_verification.models.name_match_request_schema import *
from cashfree_verification.models.name_match_response_schema import *
from cashfree_verification.models.offline_aadhaar_send_otp_request_schema import *
from cashfree_verification.models.offline_aadhaar_send_otp_response_schema import *
from cashfree_verification.models.offline_aadhaar_verify_otp_request_schema import *
from cashfree_verification.models.offline_aadhaar_verify_otp_response_schema import *
from cashfree_verification.models.offline_aadhaar_verify_otp_response_schema_split_address import *
from cashfree_verification.models.pan_advance_request_schema import *
from cashfree_verification.models.pan_advance_response_schema import *
from cashfree_verification.models.pan_advance_response_schema_address import *
from cashfree_verification.models.pan_ocr_request_schema import *
from cashfree_verification.models.pan_ocr_response_schema import *
from cashfree_verification.models.pan_request_schema import *
from cashfree_verification.models.pan_to_gstin_request_schema import *
from cashfree_verification.models.pan_to_gstin_response_schema import *
from cashfree_verification.models.pan_to_gstin_response_schema_gstin_list_inner import *
from cashfree_verification.models.passport_verification_request_schema import *
from cashfree_verification.models.passport_verification_response_schema import *
from cashfree_verification.models.post_pan_bulk_response_schema import *
from cashfree_verification.models.reverse_geocoding_request_schema import *
from cashfree_verification.models.reverse_geocoding_response_schema import *
from cashfree_verification.models.split_address import *
from cashfree_verification.models.split_address_schema import *
from cashfree_verification.models.v2_error_response404_schema_ip_verification import *
from cashfree_verification.models.validity_details import *
from cashfree_verification.models.vehicle_rc_request_schema import *
from cashfree_verification.models.vehicle_rc_response_schema import *
from cashfree_verification.models.voter_id_request_schema import *
from cashfree_verification.models.voter_id_response_schema import *
from cashfree_verification.models.x_client_id_missing import *

class CFEnvironment(Enum):
    SANDBOX = 1
    PRODUCTION = 2

class Cashfree:

    XClientId = None
    XClientSecret = None
    XEnvironment = CFEnvironment.SANDBOX

    XProduction = CFEnvironment.PRODUCTION
    XSandbox = CFEnvironment.SANDBOX

    PRODUCTION = CFEnvironment.PRODUCTION
    SANDBOX = CFEnvironment.SANDBOX

    XApiVersion = "2023-12-18";

    @validate_arguments
    def vrs_aadhaar_ocr_verification(self, verification_id : Annotated[StrictStr, Field(..., description="It is the unique ID you create to identify the request. The maximum character limit is 50. Only alphanumeric, hyphen (-), period (.), and underscore ( _ ) are allowed.")] = None, front_image : Annotated[Union[StrictBytes, StrictStr], Field(..., description="It is the scanned image of the front of the aadhaar card. Allowed file type - JPEG/JPG/PNG. The max file size of both the files is 10MB.")] = None, x_api_version : Annotated[Optional[StrictStr], Field(description="It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, back_image : Annotated[Optional[Union[StrictBytes, StrictStr]], Field(description="It is the scanned image of the back of the aadhaar card. Allowed file type - JPEG/JPG/PNG. The max file size of both the files is 10MB.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Aadhaar OCR Verification  # noqa: E501

        Use this API to extract the details of a customer from the respective aadhaar card image and return it to the business for verification or for KYC requirements. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|    | 200      | SUCCESS | Aadhaar card is valid                                                   | -                                                                             |   | 200      | SUCCESS | Aadhaar card is invalid                                                         | Upload a valid aadhaar copy.                                                  |   | 400      | ERROR   | file size exceeded                                                      | The max file size of both the files is 10MB.                                  |   | 400      | ERROR   | please upload the file of valid format(jpeg/jpg/png)                    | Allowed file type - JPEG/JPG/PNG.                                             |   | 400      | ERROR   | verification_id is missing in the request.                              | Enter a unique verification ID in the request.                                |   | 400      | ERROR   | Front Image File is missing                                             | Upload the scanned image of the front of the aadhaar card.                    |   | 400      | ERROR   | verification_id can include a maximum of 50 characters.                 | Enter a unique verification ID within 50 characters.                          |   | 400      | ERROR   | verification_id can include only alphanum, dot, hyphen and underscores. | Only alphanumeric, hyphen (-), period (.), and underscore (   ) are allowed. |   | 400      | ERROR   | x-client-id is missing in the request                                   | Enter all the header information in the API request.                          |   | 401      | ERROR   | Invalid clientId and clientSecret combination                           | Enter valid client ID and secret key in the request.                          |   | 403      | ERROR   | IP not whitelisted                                                      | Whitelist the IP address.                                                     |   | 422      | ERROR   | Insufficient balance to process this request.                           | Ensure you have sufficient balance and then process the request.              |   | 500      | ERROR   | something went wrong                                                    | Try after some time.                                                          |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_aadhaar_ocr_verification_with_http_info(verification_id, front_image, x_api_version, x_cf_signature, back_image, async_req=True)
        >>> result = thread.get()

        :param verification_id: It is the unique ID you create to identify the request. The maximum character limit is 50. Only alphanumeric, hyphen (-), period (.), and underscore ( _ ) are allowed. (required)
        :type verification_id: str
        :param front_image: It is the scanned image of the front of the aadhaar card. Allowed file type - JPEG/JPG/PNG. The max file size of both the files is 10MB. (required)
        :type front_image: bytearray
        :param x_api_version: It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12
        :type x_api_version: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param back_image: It is the scanned image of the back of the aadhaar card. Allowed file type - JPEG/JPG/PNG. The max file size of both the files is 10MB.
        :type back_image: bytearray
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AadhaarOcrResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'verification_id',
            'front_image',
            'x_api_version',
            'x_cf_signature',
            'back_image'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_aadhaar_ocr_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        if _params['verification_id']:
            _form_params.append(('verification_id', _params['verification_id']))

        if _params['back_image']:
            _files['back_image'] = _params['back_image']

        if _params['front_image']:
            _files['front_image'] = _params['front_image']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "AadhaarOcrResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/document/aadhaar', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_mask_aadhaar(self, image : Annotated[Union[StrictBytes, StrictStr], Field(..., description="It is the image file of the aadhaar card that needs masking. Accepted formats - short, long, and PVC. Allowed file type - JPEG/JPG/PNG. The maximum file size should be 10 MB.")] = None, verification_id : Annotated[StrictStr, Field(..., description="It is the unique ID you create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Aadhaar Masking  # noqa: E501

        Use this API to mask the first 8 digits of your customer's aadhaar number and block the QR code (if it exists). Masking aadhaar card of your customers ensures privacy and makes it storable in your database. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#aadhaar-masking) and use the information to trigger the validations. The test data are usable only in test environments such as gamma and sandbox.  ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|    | 200      | SUCCESS | VALID                                                      | -                                                                |   | 200      | SUCCESS | INVALID_DOCUMENT                                           | Upload a valid copy of the aadhaar.                              |   | 400      | ERROR   | x-client-id is missing in the request                      | Enter all the header information in the API request.             |   | 400      | ERROR   | image is missing in the request                      | Upload the image file of the aadhaar card that needs masking.             |   | 400      | ERROR   |verification_id can include only alphanum, dot, hyphen and underscores                      | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.             |   | 401      | ERROR   | Invalid clientId and clientSecret combination              | Enter valid client ID and secret key in the request.             |   | 403      | ERROR   | IP not whitelisted                                         | Whitelist the IP address.                                        |   | 409      | ERROR   | verification id already exists                             | Enter a unique verification ID.                                  |   | 413      | ERROR   | file size exceeded                                         | The maximum file size should be 10 MB.                           |   | 422      | ERROR   | Insufficient balance to process this request.              | Ensure you have sufficient balance and then process the request. |   | 500      | ERROR   | something went wrong                                       | Try after some time.     # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_mask_aadhaar_with_http_info(image, verification_id, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param image: It is the image file of the aadhaar card that needs masking. Accepted formats - short, long, and PVC. Allowed file type - JPEG/JPG/PNG. The maximum file size should be 10 MB. (required)
        :type image: bytearray
        :param verification_id: It is the unique ID you create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed. (required)
        :type verification_id: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AadhaarMaskingResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'image',
            'verification_id',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_mask_aadhaar" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        if _params['image']:
            _files['image'] = _params['image']

        if _params['verification_id']:
            _form_params.append(('verification_id', _params['verification_id']))

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "AadhaarMaskingResponseSchema",
            '400': "XClientIdMissing",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '413': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/aadhaar-masking', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_offline_aadhaar_send_otp(self, offline_aadhaar_send_otp_request_schema : Annotated[OfflineAadhaarSendOtpRequestSchema, Field(..., description="Find the request parameters to generate OTP for a given aadhar number")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Generate OTP to Verify Aadhaar  # noqa: E501

        Use this API to generate OTP for a given aadhar number. The mobile number linked with the aadhaar information will receive the generated OTP. Use the generated OTP for offline aadhaar verification. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | OTP sent successfully                                      | Enter the OTP in the Submit OTP to Verify Aadhaar API.                      |   | 200      | SUCCESS | Aadhaar not linked to mobile number                        | Enter a valid aadhaar number linked to a mobile number to generate the OTP. |   | 200      | SUCCESS | Invalid Aadhaar Card                                       | Enter a valid aadhaar number.                                               |   | 400      | ERROR   | aadhaar Number should contain 12 characters.               | Enter a valid aadhaar number that has only 12 numeric digits.               |   | 400      | ERROR   | Please enter aadhaar number in numeric format              | Enter a valid aadhaar number that has only 12 numeric digits.               |   | 400      | ERROR   | Please enter aadhaar number in the request                 | Enter a valid aadhaar number.                                               |   | 400      | ERROR   | x-client-id is missing in the request                      | Enter all the header information in the API request.                        |   | 401      | ERROR   | Invalid clientId and clientSecret combination              | Enter valid client ID and secret key in the request.                        |   | 403      | ERROR   | IP not whitelisted                                         | Whitelist the IP address.                                                   |   | 409      | ERROR   | Otp generated for this aadhaar, please try after some time | Try again after some time.                                                  |   | 422      | ERROR   | Insufficient balance to process this request.              | Ensure you have sufficient balance and then process the request.            |   | 500      | ERROR   | something went wrong                                       | Try again after some time.                                                  |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_offline_aadhaar_send_otp_with_http_info(offline_aadhaar_send_otp_request_schema, async_req=True)
        >>> result = thread.get()

        :param offline_aadhaar_send_otp_request_schema: Find the request parameters to generate OTP for a given aadhar number (required)
        :type offline_aadhaar_send_otp_request_schema: OfflineAadhaarSendOtpRequestSchema
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OfflineAadhaarSendOtpResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'offline_aadhaar_send_otp_request_schema'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_offline_aadhaar_send_otp" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['offline_aadhaar_send_otp_request_schema'] is not None:
            _body_params = _params['offline_aadhaar_send_otp_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "OfflineAadhaarSendOtpResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/offline-aadhaar/otp', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_offline_aadhaar_verify_otp(self, offline_aadhaar_verify_otp_request_schema : Annotated[OfflineAadhaarVerifyOtpRequestSchema, Field(..., description="Find the request parameters to submit the generated OTP")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Submit OTP to Verify Aadhaar  # noqa: E501

        Use this API to verify aadhaar by submitting the OTP received on the mobile number linked to the aadhaar information. You also need to enter the reference ID received in the response of Generate OTP to Verify Aadhaar API. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | Aadhaar Card Exists                           | -                                                                                             |   | 400      | ERROR   | Session expired, please generate a new OTP    | Generate a new OTP using Generate OTP to Verify Aadhaar API.                                  |   | 400      | ERROR   | Invalid Aadhaar Card                          | -                                                                                             |   | 400      | ERROR   | Aadhaar not linked to mobile number           | Enter a valid aadhaar number linked to a mobile number in the Generate OTP to Verify Aadhaar. |   | 400      | ERROR   | Otp expired                                   | Generate a new OTP using Generate OTP to Verify Aadhaar API.                                  |   | 400      | ERROR   | Please enter a valid otp.                     | Enter the generated OTP.                                                                      |   | 400      | ERROR   | Please enter the otp in the request           | Enter the generated OTP.                                                                      |   | 400      | ERROR   | OTP entered is invalid                        | Enter the generated OTP.                                                                      |   | 400      | ERROR   | x-client-id is missing in the request         | Enter all the header information in the API request.                                          |   | 401      | ERROR   | Invalid clientId and clientSecret combination | Enter valid client ID and secret key in the request.                                          |   | 403      | ERROR   | IP not whitelisted                            | Whitelist the IP address.                                                                     |   | 422      | ERROR   | Insufficient balance to process this request. | Ensure you have sufficient balance and then process the request.                              |   | 500      | ERROR   | Unable to validate, please retry later                          | Try again after some time.                                                                    |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_offline_aadhaar_verify_otp_with_http_info(offline_aadhaar_verify_otp_request_schema, async_req=True)
        >>> result = thread.get()

        :param offline_aadhaar_verify_otp_request_schema: Find the request parameters to submit the generated OTP (required)
        :type offline_aadhaar_verify_otp_request_schema: OfflineAadhaarVerifyOtpRequestSchema
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OfflineAadhaarVerifyOtpResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'offline_aadhaar_verify_otp_request_schema'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_offline_aadhaar_verify_otp" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['offline_aadhaar_verify_otp_request_schema'] is not None:
            _body_params = _params['offline_aadhaar_verify_otp_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "OfflineAadhaarVerifyOtpResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/offline-aadhaar/verify', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_advance_employment_verification(self, advance_employment_request_schema : Annotated[AdvanceEmploymentRequestSchema, Field(..., description="Find the request parameters to retrieve employment details")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Employment Details  # noqa: E501

        Use this API to to retrieve an individual's recent employment details such as member ID, joining date, and exit date of the company. Verifying the employment information of the individual mitigates risk and prevents fraud. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#employment-information) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | SUCCESS                                      | -   | 200              | SUCCESS       | EMPLOYMENT_DETAILS_NOT_FOUND                                      | Enter the correct information in the request.    | 400              | ERROR         | provided input combination is not valid                  | Enter a combination of values that help fetch the employment details.   | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen and underscores.                  | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.     | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_advance_employment_verification_with_http_info(advance_employment_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param advance_employment_request_schema: Find the request parameters to retrieve employment details (required)
        :type advance_employment_request_schema: AdvanceEmploymentRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AdvanceEmploymentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'advance_employment_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_advance_employment_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['advance_employment_request_schema'] is not None:
            _body_params = _params['advance_employment_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "AdvanceEmploymentResponse",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/advance-employment', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_cin_verification(self, cin_request_schema : Annotated[CinRequestSchema, Field(..., description="Find the request parameters to retrieve your customer's CIN information")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify CIN  # noqa: E501

        Use this API to retrieve information from CIN such as business incorporation date, director(s) details, CIN status, and more. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#cin) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | VALID                                      | -    | 200              | SUCCESS         | INVALID                  | Enter the correct information in the request. | 400              | ERROR         | verification_id is missing in the request.                  | Enter a valid verification_id in the request.  | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen, and underscores.               | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.   | 400              | ERROR         | cin is missing in the request.                  | Enter the unique alphanumeric identifier (CIN) assigned to companies in the request.   | 400              | ERROR         | cin should be of 21 character alphanumeric string of format (X00000XX0000XXX000000).                  | Enter the correct format of the CIN information in the request.     | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_cin_verification_with_http_info(cin_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param cin_request_schema: Find the request parameters to retrieve your customer's CIN information (required)
        :type cin_request_schema: CinRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CinResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'cin_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_cin_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['cin_request_schema'] is not None:
            _body_params = _params['cin_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "CinResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/cin', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_digilocker_verification_create_url(self, digi_locker_verification_create_url_request_schema : Annotated[DigiLockerVerificationCreateUrlRequestSchema, Field(..., description="Find the request parameters to create a DigiLocker URL to retrieve and verify aadhaar information")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create DigiLocker URL  # noqa: E501

        Use this API to create a DigiLocker URL to retrieve and verify aadhaar information of your customer.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | PENDING                                      | -    | 400              | ERROR         | verification_id is missing in the request.                  | Enter a valid verification_id in the request.  | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen, and underscores.               | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.   | 400              | ERROR         |document_requested is missing in the request.                  | Enter the document required for verification in the request.    | 400              | ERROR         | Requested Document Type can't be empty                  | Enter the type of document required for verification in the respective parameter and hit the API.    | 400              | ERROR         | Invalid Document Type Submitted                  | Enter a valid value for the parameter.    | 400              | ERROR         | Duplicate Document Type Submitted                  |     | 400              | ERROR         | redirect_url should start with https.                 |  Enter a valid redirect URL.   | 400              | ERROR         |redirect_url should be valid url.                  | Enter a valid redirect URL.      | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification_id already exits, please provide new verification_id                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | Unable to process your request. Try again after some time                      | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_digilocker_verification_create_url_with_http_info(digi_locker_verification_create_url_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param digi_locker_verification_create_url_request_schema: Find the request parameters to create a DigiLocker URL to retrieve and verify aadhaar information (required)
        :type digi_locker_verification_create_url_request_schema: DigiLockerVerificationCreateUrlRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DigiLockerVerificationCreateUrlResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'digi_locker_verification_create_url_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_digilocker_verification_create_url" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['digi_locker_verification_create_url_request_schema'] is not None:
            _body_params = _params['digi_locker_verification_create_url_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "DigiLockerVerificationCreateUrlResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/digilocker', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_digilocker_verification_fetch_document(self, document_type : Annotated[StrictStr, Field(..., description="It is the type of document to be verified.")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, reference_id : Annotated[Optional[StrictInt], Field(description="It is the unique ID created by Cashfree Payments that you receive in the response of Create DigiLocker URL API")] = None, verification_id : Annotated[Optional[StrictStr], Field(description="It is the unique ID you created to identify the Create DigiLocker URL API request.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Document from DigiLocker  # noqa: E501

        Use this API to get your customer's document details from DigiLocker.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              |SUCCESS       | -                                      | -   | 202            |SUCCESS       | Validation in process check after some time                                     | Try again after some time.    | 400              | ERROR         | Please provide verification_id or reference_id                  | Enter a valid verification_id or reference_id in the request.  | 400              | ERROR         | document_type should be AADHAAR.               | Enter the value for document_type as AADHAAR.     | 400              | ERROR         | Digilocker request URL is expired                  | Create a new DigiLocker URL.    | 400              | ERROR         | Digilocker consent session expired                  | Create a new DigiLocker consent session.      | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 404              | ERROR         | Please enter a valid verification_id                                           | Enter a valid verification ID.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | Unable to process your request. Try again after some time                      | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_digilocker_verification_fetch_document_with_http_info(document_type, x_cf_signature, reference_id, verification_id, async_req=True)
        >>> result = thread.get()

        :param document_type: It is the type of document to be verified. (required)
        :type document_type: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param reference_id: It is the unique ID created by Cashfree Payments that you receive in the response of Create DigiLocker URL API
        :type reference_id: int
        :param verification_id: It is the unique ID you created to identify the Create DigiLocker URL API request.
        :type verification_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DigiLockerVerificationGetDocumentResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'document_type',
            'x_cf_signature',
            'reference_id',
            'verification_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_digilocker_verification_fetch_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['document_type']:
            _path_params['document_type'] = _params['document_type']


        # process the query parameters
        _query_params = []
        if _params.get('reference_id') is not None:  # noqa: E501
            _query_params.append(('reference_id', _params['reference_id']))

        if _params.get('verification_id') is not None:  # noqa: E501
            _query_params.append(('verification_id', _params['verification_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "DigiLockerVerificationGetDocumentResponseSchema",
            '202': "ErrorResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '404': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/digilocker/document/{document_type}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_digilocker_verification_fetch_status(self, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, reference_id : Annotated[Optional[StrictInt], Field(description="It is the unique ID created by Cashfree Payments that you received in the Create DigiLocker URL API response.")] = None, verification_id : Annotated[Optional[StrictStr], Field(description="It is the unique ID you created to identify the Create DigiLocker URL API request.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get DigiLocker Verification Status  # noqa: E501

        Use this API to get the status of the DigiLocker verification. You need to enter either the verification ID or reference ID.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | PENDING                                                            | -                                                                  |   | 200      | SUCCESS | AUTHENTICATED                                                            | -                                                                  |   | 200      | SUCCESS | EXPIRED                                                           | -                                                                  |   | 400      | ERROR   | Please provide verification_id or reference_id                       | You need to enter either the verification ID or reference ID.        |   | 400      | ERROR   | x-client-id is missing in the request.                       | Enter all the header information in the API request.               |   | 401      | ERROR   | Invalid clientId and clientSecret combination                | Enter valid client ID and secret key in the request.               |   | 403      | ERROR   | IP not whitelisted                                           | Whitelist the IP address.                                          |   | 404      | ERROR   | Please enter a valid verification_id                                           | Enter a valid verification ID that you created to identify the API request.                                          |   | 404      | ERROR   | Please enter a valid reference_id                                           | Enter a valid reference ID that you received in the API response.                                          |    | 422      | ERROR   | Insufficient balance to process this request.                | Ensure you have sufficient balance and then process the request.   |   | 500      | ERROR   | Unable to process your request. Try again after some time                                         | Try again after some time.                                         |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_digilocker_verification_fetch_status_with_http_info(x_cf_signature, reference_id, verification_id, async_req=True)
        >>> result = thread.get()

        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param reference_id: It is the unique ID created by Cashfree Payments that you received in the Create DigiLocker URL API response.
        :type reference_id: int
        :param verification_id: It is the unique ID you created to identify the Create DigiLocker URL API request.
        :type verification_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DigiLockerVerificationGetStatusResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'x_cf_signature',
            'reference_id',
            'verification_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_digilocker_verification_fetch_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('reference_id') is not None:  # noqa: E501
            _query_params.append(('reference_id', _params['reference_id']))

        if _params.get('verification_id') is not None:  # noqa: E501
            _query_params.append(('verification_id', _params['verification_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "DigiLockerVerificationGetStatusResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '404': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/digilocker', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_driving_license_verification(self, driving_license_request_schema : Annotated[DrivingLicenseRequestSchema, Field(..., description="Find the request paramenters to retrieve your customer's driving license information")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify Driving Licence Details  # noqa: E501

        Use this API to verify the driving license of your customer. We retrieve details of the driving licence that includes the type of licence, issue date, expiry date, and more. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#driving-licence) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | VALID                                      | -   | 200              | SUCCESS       | INVALID                                      | Enter the correct information in the request.    | 400              | ERROR         | driving license is invalid                  | Ensure a valid driving licence information in the request.   | 400              | ERROR         | dob should be of type YYYY-MM-DD.                  | The accepted format is YYYY-MM-DD.   | 400              | ERROR         | dob is missing in the request.                  | Enter the date of birth of the driving licence holder in the request.  | 400              | ERROR         | verification_id is missing in the request.                  | Enter a valid verification ID to identify the verification request.   | 400              | ERROR         | verification_id can include a maximum of 50 characters.                  | Create a valid verification ID within 50 characters.   | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen and underscores.                  | Only alphanumeric, period (.), hyphen (-) and underscore ( _ ) are allowed.     | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_driving_license_verification_with_http_info(driving_license_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param driving_license_request_schema: Find the request paramenters to retrieve your customer's driving license information (required)
        :type driving_license_request_schema: DrivingLicenseRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DrivingLicenseResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'driving_license_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_driving_license_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['driving_license_request_schema'] is not None:
            _body_params = _params['driving_license_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "DrivingLicenseResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/driving-license', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_e_sign_create_signature(self, e_sign_verification_create_signature_request_schema : Annotated[ESignVerificationCreateSignatureRequestSchema, Field(..., description="Find the request parameters to add the details of the document and signer")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create E-Sign Request  # noqa: E501

        Use this API to add the details of the document and signer(s) to initiate e-sign verification. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | SUCCESS                                      | -   | 400              | ERROR       | verification_id is missing in the request.                                      | Create a valid verification ID to identify the request.     | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen, and underscores.                  | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.  | 400              | ERROR         | x-client-id is missing in the request.                  | Enter all the header information in the API request.  | 400              | ERROR         |  document_id is missing in the request.                  | Enter the unique ID received in the Upload Document for E-Sign API response.     | 400              | ERROR         |     Document id provided is invalid.                  |  Enter a valid document ID.   | 400              | ERROR         |     Document id provided is expired.                  |     | 400              | ERROR         |     notification_modes is missing in the request.                  |  Enter how you want to notify the signee about the e-sign details in the request.   | 400              | ERROR         |     notification_modes is missing in the request.                  |  Enter how you want to notify the signee about the e-sign details in the request.   | 400              | ERROR         |     Notification mode provided is invalid.                  |     | 400              | ERROR         |     Maximum number limit of Signer exceeded.                  |     | 400              | ERROR         |     auth_type is missing in the request                  | Enter the type of authentication to be used for e-signature.    | 400              | ERROR         |     expiry_in_days is missing in the request.                  | Enter the expiry of the signing link for each signer in days. The maximum allowed time is 15 days.     | 400              | ERROR         |     signers is missing in the request.                  | Enter the details of the signer(s) in the request.      | 400              | ERROR         |     Duplicate sequence passed for signers                  |      | 400              | ERROR         |     Sequence passed for signers is Invalid                  |      | 400              | ERROR         |     Multiple signer is not allowed without email notification mode                  |       | 401              | ERROR         | Invalid clientId and clientSecret combination               |   | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | This Verification ID already exists. Provide a different ID.                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong, please try after some time                      | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_e_sign_create_signature_with_http_info(e_sign_verification_create_signature_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param e_sign_verification_create_signature_request_schema: Find the request parameters to add the details of the document and signer (required)
        :type e_sign_verification_create_signature_request_schema: ESignVerificationCreateSignatureRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ESignVerificationCreateSignatureResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'e_sign_verification_create_signature_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_e_sign_create_signature" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['e_sign_verification_create_signature_request_schema'] is not None:
            _body_params = _params['e_sign_verification_create_signature_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "ESignVerificationCreateSignatureResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/esignature', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_e_sign_upload_document(self, document : Annotated[Union[StrictBytes, StrictStr], Field(..., description="Upload the document that requires an e-sign. Allowed file type - PDF. Max file size allowed - 10MB.")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Upload Document For E-Sign  # noqa: E501

        Use this API to upload the document before creating the request for signing the document.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | SUCCESS                                      | -   | 400              | ERROR       | Please upload the file of valid format(pdf)                                      | Upload the document that requires an e-sign. Allowed file type - PDF. Max file size allowed - 10MB.  | 400              | ERROR      |                           document is missing in the request.            |Upload the document that requires an e-sign. Allowed file type - PDF. Max file size allowed - 10MB.   | 400              | ERROR       | x-client-id is missing in the request.                                      | Enter all the header information in the API.    | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.   | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong, please try after some time                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_e_sign_upload_document_with_http_info(document, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param document: Upload the document that requires an e-sign. Allowed file type - PDF. Max file size allowed - 10MB. (required)
        :type document: bytearray
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ESignVerificationUploadDocumentResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'document',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_e_sign_upload_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        if _params['document']:
            _files['document'] = _params['document']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "ESignVerificationUploadDocumentResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/esignature/document', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_e_sign_verification_fetch_status(self, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, reference_id : Annotated[Optional[StrictInt], Field(description="It is the unique ID created by Cashfree Payments that you receive in the response of Create E-Sign Request API.")] = None, verification_id : Annotated[Optional[StrictStr], Field(description="It is the unique ID you create to identify the Create E-Sign Request API.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get E-Sign Status  # noqa: E501

        Use this API to get the status of the initiated e-sign verification. You need to enter either the verification ID or reference ID.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | IN_PROGRESS                                      | Wait for the signature.   | 200              | SUCCESS       | SUCCESS                                      | -  | 200              | SUCCESS       | EXPIRED                                      |   | 200              | SUCCESS       | FAILURE                                      |    | 400              | ERROR       | Please provide verification_id or reference_id                                      | Enter a valid verification ID or reference ID in the.    | 401              | ERROR         | Invalid clientId and clientSecret combination               |   | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.   | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong, please try after some time                      | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_e_sign_verification_fetch_status_with_http_info(x_cf_signature, reference_id, verification_id, async_req=True)
        >>> result = thread.get()

        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param reference_id: It is the unique ID created by Cashfree Payments that you receive in the response of Create E-Sign Request API.
        :type reference_id: int
        :param verification_id: It is the unique ID you create to identify the Create E-Sign Request API.
        :type verification_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ESignVerificationGetStatusResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'x_cf_signature',
            'reference_id',
            'verification_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_e_sign_verification_fetch_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('reference_id') is not None:  # noqa: E501
            _query_params.append(('reference_id', _params['reference_id']))

        if _params.get('verification_id') is not None:  # noqa: E501
            _query_params.append(('verification_id', _params['verification_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "ESignVerificationGetStatusResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/esignature', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_face_liveness_check(self, x_api_version : Annotated[StrictStr, Field(..., description="API version to be used. Format is in YYYY-MM-DD.")] = None, verification_id : Annotated[StrictStr, Field(..., description="It is the unique ID you create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-) and underscore ( _ ) are allowed.")] = None, image : Annotated[Union[StrictBytes, StrictStr], Field(..., description="Upload the image of the individual to verify the liveness of the image. Supported types are jpeg, jpg and png.")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Face Liveness Check  # noqa: E501

        Use this API to detect live human presence and authenticate facial biometrics. The API analyzes facial characteristics and liveness signals to prevent spoofing attempts and validate genuine user presence.  Returns comprehensive facial analysis including liveness confidence score and quality metrics. View the [test data](https://www.cashfree.com/docs/api-reference/vrs/data-to-test-integration#face-liveness) and use the information to trigger the validations. The test data are usable only in the test environment sandbox.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_face_liveness_check_with_http_info(x_api_version, verification_id, image, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param x_api_version: API version to be used. Format is in YYYY-MM-DD. (required)
        :type x_api_version: str
        :param verification_id: It is the unique ID you create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-) and underscore ( _ ) are allowed. (required)
        :type verification_id: str
        :param image: Upload the image of the individual to verify the liveness of the image. Supported types are jpeg, jpg and png. (required)
        :type image: bytearray
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FaceLiveness200ResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'x_api_version',
            'verification_id',
            'image',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_face_liveness_check" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        if _params['verification_id']:
            _form_params.append(('verification_id', _params['verification_id']))

        if _params['image']:
            _files['image'] = _params['image']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "FaceLiveness200ResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/face-liveness', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_face_match_verification(self, verification_id : Annotated[StrictStr, Field(..., description="It is the unique ID you need to create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-) and underscore ( _ ) are allowed.")] = None, first_image : Annotated[Union[StrictBytes, StrictStr], Field(..., description="It is the scanned copy of the image 1. Allowed file type - JPEG/JPG/PNG. Maximum file size allowed for both the files is 10 MB.")] = None, second_image : Annotated[Union[StrictBytes, StrictStr], Field(..., description="It is the scanned copy of the image 2. Allowed file type - JPEG/JPG/PNG. Maximum file size allowed for both the files is 10 MB.")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, threshold : Annotated[Optional[StrictStr], Field(description="It is the value to distinguish and match the facial features of the two images. The range is between 0 and 1. The default value is set as 0.7. We conclude that the images match when the analysis is or greater than the value set for threshold.")] = None, detect_mask_first_image : Annotated[Optional[StrictBool], Field(description="It is a boolean value to identify whether the person in the first image is wearing a mask.")] = None, detect_mask_second_image : Annotated[Optional[StrictBool], Field(description="It is a boolean value to identify whether the person in the first image is wearing a mask.")] = None, align_horizontally : Annotated[Optional[StrictBool], Field(description="It is a boolean value to align the images horizontally before analysing the facial features.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Face Match  # noqa: E501

        Use this API to verify the facial features of your customer in one image with another. You can compare an image with another image or with an image in an ID. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#face-match) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | SUCCESS                                      | -   | 400              | ERROR         | File size exceeded. Please check API Documentation                  | Maximum file size allowed for both the files is 10 MB. | 400              | ERROR         | please upload the file of valid format(jpeg/jpg/png)                  | Allowed file type - JPEG/JPG/PNG.    | 400              | ERROR         | First image is missing in the request                  | Upload the scanned copy of the image 1.   | 400              | ERROR         | Second image is missing in the request                 | Upload the scanned copy of the image 2.    | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen and underscores.                  | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.     | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_face_match_verification_with_http_info(verification_id, first_image, second_image, x_cf_signature, threshold, detect_mask_first_image, detect_mask_second_image, align_horizontally, async_req=True)
        >>> result = thread.get()

        :param verification_id: It is the unique ID you need to create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-) and underscore ( _ ) are allowed. (required)
        :type verification_id: str
        :param first_image: It is the scanned copy of the image 1. Allowed file type - JPEG/JPG/PNG. Maximum file size allowed for both the files is 10 MB. (required)
        :type first_image: bytearray
        :param second_image: It is the scanned copy of the image 2. Allowed file type - JPEG/JPG/PNG. Maximum file size allowed for both the files is 10 MB. (required)
        :type second_image: bytearray
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param threshold: It is the value to distinguish and match the facial features of the two images. The range is between 0 and 1. The default value is set as 0.7. We conclude that the images match when the analysis is or greater than the value set for threshold.
        :type threshold: str
        :param detect_mask_first_image: It is a boolean value to identify whether the person in the first image is wearing a mask.
        :type detect_mask_first_image: bool
        :param detect_mask_second_image: It is a boolean value to identify whether the person in the first image is wearing a mask.
        :type detect_mask_second_image: bool
        :param align_horizontally: It is a boolean value to align the images horizontally before analysing the facial features.
        :type align_horizontally: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FaceMatchResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'verification_id',
            'first_image',
            'second_image',
            'x_cf_signature',
            'threshold',
            'detect_mask_first_image',
            'detect_mask_second_image',
            'align_horizontally'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_face_match_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        if _params['verification_id']:
            _form_params.append(('verification_id', _params['verification_id']))

        if _params['first_image']:
            _files['first_image'] = _params['first_image']

        if _params['second_image']:
            _files['second_image'] = _params['second_image']

        if _params['threshold']:
            _form_params.append(('threshold', _params['threshold']))

        if _params['detect_mask_first_image']:
            _form_params.append(('detect_mask_first_image', _params['detect_mask_first_image']))

        if _params['detect_mask_second_image']:
            _form_params.append(('detect_mask_second_image', _params['detect_mask_second_image']))

        if _params['align_horizontally']:
            _form_params.append(('align_horizontally', _params['align_horizontally']))

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "FaceMatchResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/face-match', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_gstin_verification(self, gstin_request_schema : Annotated[GstinRequestSchema, Field(..., description="Find the request parameters to retrieve GSTIN information")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify GSTIN  # noqa: E501

        Use this API to verify if a given GSTIN information exists or not. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | GSTIN Exists                                      | -   | 200              | SUCCESS       | GSTIN Doesn’t Exist                                      | Enter the correct information in the request.     | 400              | ERROR         | GSTIN first 2 digits should be numeric and length should not exceed 15 and should be alphanumeric.                  | Enter a valid GSTIN in the request. The correct identifier has the first 2 digits in numerics and does not exceed 15 charaters.  | 400              | ERROR         | GSTIN is missing in the request.                  | Enter the GSTIN information in the request.  | 400              | ERROR         |  businessName can include a maximum of 200 characters.                  | The maximum character limit for businessName is 200.   | 400              | ERROR         |  businessName should be alphanumeric.                  | Enter only alphabets and/or numerical values in the parameter.    | 400              | ERROR         |  GstIn Verification is not enabled for this account                  | Contact your account manager.     | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.   | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         |Unable to validate, please retry later                     | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_gstin_verification_with_http_info(gstin_request_schema, async_req=True)
        >>> result = thread.get()

        :param gstin_request_schema: Find the request parameters to retrieve GSTIN information (required)
        :type gstin_request_schema: GstinRequestSchema
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GstinResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'gstin_request_schema'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_gstin_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['gstin_request_schema'] is not None:
            _body_params = _params['gstin_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "GstinResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/gstin', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_ip_verification(self, ip_verification_request_schema : Annotated[IpVerificationRequestSchema, Field(..., description="Find the request parameters to retrieve location information of an IP address")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify IP  # noqa: E501

        Use this API to verify location, proxy details, city risk score, and proxy type risk score of an IP address. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#ip-address) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.    ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | VALID                                      | -    | 400             | ERROR         | x-client-id is missing in the request.                  | Enter all the header information in the request. | 400              | ERROR         | verification_id already exists.                  | Enter a unique verification ID to identify the request.  | 400              | ERROR         | please enter a valid IP address               | Enter a valid IP address in the request.    | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 404              | ERROR         | unable to find IP details                                           | Enter a valid IP address in the request.    | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong, please try after some time                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_ip_verification_with_http_info(ip_verification_request_schema, async_req=True)
        >>> result = thread.get()

        :param ip_verification_request_schema: Find the request parameters to retrieve location information of an IP address (required)
        :type ip_verification_request_schema: IpVerificationRequestSchema
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IpVerificationResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'ip_verification_request_schema'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_ip_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ip_verification_request_schema'] is not None:
            _body_params = _params['ip_verification_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "IpVerificationResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '404': "V2ErrorResponse404SchemaIpVerification",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/ip', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_name_match_verification(self, name_match_request_schema : Annotated[NameMatchRequestSchema, Field(..., description="Find the request parameters to verify names with variations")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Name Match  # noqa: E501

        Use this API to verify names that have enormous variations. Provide us the names you want to verify, and we will tell you whether they match and provide the reason. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#name-match) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | The given names are identical                                      | -   | 200              | SUCCESS       | Word missing                                      | -   | 200              | SUCCESS       | Initials penalty, Word missing                                      | -   | 200              | SUCCESS       | Word missing                                     | -   | 200              | SUCCESS       |The given names are different                                      | -    | 400              | ERROR         | verification_id is missing in the request.                  | Enter a verification ID in the request. | 400              | ERROR         | name_1 is missing in the request.                  | Enter name #1 in the request.   | 400              | ERROR         | name_2 is missing in the request.                  | Enter name #2 in the request.   | 400              | ERROR         | name_1 is not allowed to be empty.                  | Enter a name in the name_1 parameter.   | 400              | ERROR         | name_2 is not allowed to be empty.                  | Enter a name in the name_2 parameter.  | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen and underscores.                  | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.     | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_name_match_verification_with_http_info(name_match_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param name_match_request_schema: Find the request parameters to verify names with variations (required)
        :type name_match_request_schema: NameMatchRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NameMatchResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'name_match_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_name_match_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['name_match_request_schema'] is not None:
            _body_params = _params['name_match_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "NameMatchResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/name-match', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_bulk_pan_verification(self, bulk_pan_request_schema : Annotated[BulkPanRequestSchema, Field(..., description="Find the request parameters to verify a large number of PAN information")] = None, x_api_version : Annotated[Optional[StrictStr], Field(description="It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify PAN in Bulk  # noqa: E501

        Use this API to verify your customers' PAN information individually or in batches at a time. This API comes in handy when you have to verify a large number of PAN information. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#pan) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | Request accepted. You can check the status after some time.                      | -     | 400      | ERROR   | Please provide atleast one entry for verification                                | You need to have a minimum of one entry in the request.        | 400      | ERROR   | bulk_verification_id is missing in the request.                                  | You need to create a unique ID to identify the API request.        | 400      | ERROR   | bulk_verification_id should contain only alphanumeric and underscore characters. | Only alphanumeric and underscore ( _ ) are allowed.               | 400      | ERROR   | x-client-id is missing in the request.                                           | Enter all the header information in the API request.               | 401      | ERROR   | Invalid clientId and clientSecret combination                                    | Enter valid client ID and secret key in the request.               | 403      | ERROR   | IP not whitelisted                                                               | Whitelist the IP address.                                          | 422      | ERROR   | Insufficient balance to process this request.                                    | Ensure you have sufficient balance and then process the request.   | 500      | ERROR   | Unable to validate, please retry later                                           | Try again after some time.                                    | 500      | ERROR   | something went wrong, please try after some time                                 | Try again after some time.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_bulk_pan_verification_with_http_info(bulk_pan_request_schema, x_api_version, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param bulk_pan_request_schema: Find the request parameters to verify a large number of PAN information (required)
        :type bulk_pan_request_schema: BulkPanRequestSchema
        :param x_api_version: It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12
        :type x_api_version: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostPanBulkResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'bulk_pan_request_schema',
            'x_api_version',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_bulk_pan_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['bulk_pan_request_schema'] is not None:
            _body_params = _params['bulk_pan_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "PostPanBulkResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/pan/bulk', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_fetch_bulk_pan_details(self, reference_id : Annotated[StrictStr, Field(..., description="It is the unique ID created by Cashfree Payments that you receive in the response of Verify PAN in Bulk API.")] = None, bulk_verification_id : Annotated[StrictStr, Field(..., description="It is the unique ID you created to identify the Verify PAN in Bulk API request.")] = None, x_api_version : Annotated[Optional[StrictStr], Field(description="It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Status for Verify PAN in Bulk  # noqa: E501

        Use this API to get the status of the Verify PAN in Bulk API request. You need to enter either the reference ID or bulk verification ID.    ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | -                                                            | -                                                                  |   | 400      | ERROR   | Either of reference_id or BulkVerificationId can't be empty. | You need to enter either the reference ID or bulk verification ID. |   | 400      | ERROR   | x-client-id is missing in the request.                       | Enter all the header information in the API request.               |   | 401      | ERROR   | Invalid clientId and clientSecret combination                | Enter valid client ID and secret key in the request.               |   | 403      | ERROR   | IP not whitelisted                                           | Whitelist the IP address.                                          |   | 422      | ERROR   | Insufficient balance to process this request.                | Ensure you have sufficient balance and then process the request.   |   | 500      | ERROR   | something went wrong                                         | Try again after some time.                                         |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_fetch_bulk_pan_details_with_http_info(reference_id, bulk_verification_id, x_api_version, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param reference_id: It is the unique ID created by Cashfree Payments that you receive in the response of Verify PAN in Bulk API. (required)
        :type reference_id: str
        :param bulk_verification_id: It is the unique ID you created to identify the Verify PAN in Bulk API request. (required)
        :type bulk_verification_id: str
        :param x_api_version: It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12
        :type x_api_version: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetPanBulkResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'reference_id',
            'bulk_verification_id',
            'x_api_version',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_fetch_bulk_pan_details" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('reference_id') is not None:  # noqa: E501
            _query_params.append(('reference_id', _params['reference_id']))

        if _params.get('bulk_verification_id') is not None:  # noqa: E501
            _query_params.append(('bulk_verification_id', _params['bulk_verification_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "GetPanBulkResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/pan/bulk', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_fetch_pan_details(self, reference_id : Annotated[StrictStr, Field(..., description="It is the unique ID created by Cashfree Payments that you receive in the response of Verify PAN Sync API.")] = None, x_api_version : Annotated[Optional[StrictStr], Field(description="It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Status of Verify PAN Sync  # noqa: E501

        Use this API to get the verification status of the Verify PAN Sync API. You need to enter the reference ID to get the verification status. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | VALID             | -   | 200      | SUCCESS | Invalid PAN  | Enter a valid 10-character alphanumeric PAN identifier.       |  | 400      | ERROR   | x-client-id is missing in the request.                       | Enter all the header information in the API request.   | 401      | ERROR   | Invalid clientId and clientSecret combination                                    | Enter valid client ID and secret key in the request.               | 403      | ERROR   | IP not whitelisted                                                               | Whitelist the IP address.                                          | 404      | ERROR   | Incorrect referenceId                                           | Enter a valid reference ID in the request.                                    | 422      | ERROR   | Insufficient balance to process this request.                                    | Ensure you have sufficient balance and then process the request.   | 500      | ERROR   | something went wrong, please try after some time                                 | Try again after some time.        # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_fetch_pan_details_with_http_info(reference_id, x_api_version, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param reference_id: It is the unique ID created by Cashfree Payments that you receive in the response of Verify PAN Sync API. (required)
        :type reference_id: str
        :param x_api_version: It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12
        :type x_api_version: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetVerifyPanResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'reference_id',
            'x_api_version',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_fetch_pan_details" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['reference_id']:
            _path_params['reference_id'] = _params['reference_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "GetVerifyPanResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '404': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/pan/{reference_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_pan_advance_verification(self, pan_advance_request_schema : Annotated[PanAdvanceRequestSchema, Field(..., description="Find the request parameters to retrieve the PAN information")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PAN 360  # noqa: E501

        Use this API to verify the PAN information of your customers. You can retrieve more information such as masked aadhaar number, contact information. etc, than just verifying if a given PAN exists. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#pan) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|    | 200      | SUCCESS | VALID                                                        | -                                                                               | 200      | SUCCESS | Invalid PAN                                                  | Enter a valid 10-character alphanumeric PAN identifier.                         | 400      | ERROR   | Enter valid PAN.                                             | Enter a valid 10-character alphanumeric PAN identifier in the correct format.   | 400      | ERROR   | pan is missing in the request.                               | Enter a valid 10-character alphanumeric PAN identifier in the request.          | 400      | ERROR   | x-client-id is missing in the request.                       | Enter all the header information in the API request.                            | 401      | ERROR   | Invalid clientId and clientSecret combination                | Enter valid client ID and secret key in the request.                            | 403      | ERROR   | IP not whitelisted                                           | Whitelist the IP address.                                                       | 409      | ERROR   | This Verification ID already exists. Provide a different ID. | Enter a unique verification ID to identify the API request.                     | 422      | ERROR   | Insufficient balance to process this request.                | Ensure you have sufficient balance and then process the request.                | 500      | ERROR   | Unable to process your request. Try again after some time.    | Try again after some time.                                                      | 502      | ERROR   | Unable to process your request. Try again after some time.   | Try again after some time.                                                     |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_pan_advance_verification_with_http_info(pan_advance_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param pan_advance_request_schema: Find the request parameters to retrieve the PAN information (required)
        :type pan_advance_request_schema: PanAdvanceRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PanAdvanceResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'pan_advance_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_pan_advance_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['pan_advance_request_schema'] is not None:
            _body_params = _params['pan_advance_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "PanAdvanceResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/pan/advance', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_pan_ocr_verification(self, verification_id : Annotated[StrictStr, Field(..., description="It is the unique ID you create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.")] = None, front_image : Annotated[Union[StrictBytes, StrictStr], Field(..., description="It is the scanned copy of the PAN card. Allowed file type - JPEG/JPG/PNG.")] = None, x_api_version : Annotated[Optional[StrictStr], Field(description="It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PAN Verification via OCR  # noqa: E501

        Use this PAN Verification via OCR API to verify and validate the PAN information quickly. Provide the front image of PAN and a verification ID. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | PAN card is valid                                                       | -                                                                             |   | 200      | SUCCESS | PAN card is Invalid                                                     | Upload a valid PAN card copy.                                                 |   | 400      | ERROR   | File size exceeded 10MB limit                                           | The max file size of the file is 10MB.                                        |   | 400      | ERROR   | please upload the file of valid format(jpeg/jpg/png)                    | Allowed file type - JPEG/JPG/PNG.                                             |   | 400      | ERROR   | verification_id is missing in the request.                              | Enter a unique verification ID in the request.                                |   | 400      | ERROR   | Front Image File is missing                                             | Upload the copy of the PAN card in the front_image parameter.                 |   | 400      | ERROR   | verification_id can include a maximum of 50 characters.                 | The maximum character limit is 50.                                            |   | 400      | ERROR   | verification_id can include only alphanum, dot, hyphen and underscores. | Only alphanumeric, period (.), hyphen (-), and underscore (   ) are allowed. |   | 400      | ERROR   | x-client-id is missing in the request                                   | Enter all the header information in the API request.                          |   | 401      | ERROR   | Invalid clientId and clientSecret combination                           | Enter valid client ID and secret key in the request.                          |   | 403      | ERROR   | IP not whitelisted                                                      | Whitelist the IP address.                                                     |   | 422      | ERROR   | Insufficient balance to process this request.                           | Ensure you have sufficient balance and then process the request.              |   | 500      | ERROR   | Unable to validate, please retry later                                                    | Try again after some time.                                                    |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_pan_ocr_verification_with_http_info(verification_id, front_image, x_api_version, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param verification_id: It is the unique ID you create to identify the verification request. The maximum character limit is 50. Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed. (required)
        :type verification_id: str
        :param front_image: It is the scanned copy of the PAN card. Allowed file type - JPEG/JPG/PNG. (required)
        :type front_image: bytearray
        :param x_api_version: It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12
        :type x_api_version: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PanOcrResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'verification_id',
            'front_image',
            'x_api_version',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_pan_ocr_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        if _params['verification_id']:
            _form_params.append(('verification_id', _params['verification_id']))

        if _params['front_image']:
            _files['front_image'] = _params['front_image']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "PanOcrResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/document/pan', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_pan_verification(self, pan_request_schema : Annotated[PanRequestSchema, Field(..., description="Find the request parameters to verify whether the PAN information is valid")] = None, x_api_version : Annotated[Optional[StrictStr], Field(description="It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify PAN Sync  # noqa: E501

        Use this API to verify if a given PAN exists. You will receive the name registered with the PAN and the PAN type (Individual or Business) in the response for a valid PAN. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#pan) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200      | SUCCESS | VALID                                            | -                                                                             |   | 200      | SUCCESS | Invalid PAN                                            | Enter a valid 10-character alphanumeric PAN identifier.                       |   | 400      | ERROR   | Enter valid PAN.                                 | Enter a valid 10-character alphanumeric PAN identifier in the correct format. |   | 400      | ERROR   | pan is missing in the request.                   | Enter a valid 10-character alphanumeric PAN identifier in the request.        |   | 400      | ERROR   | x-client-id is missing in the request.           | Enter all the header information in the API request.                          |   | 401      | ERROR   | Invalid clientId and clientSecret combination    | Enter valid client ID and secret key in the request.                          |   | 403      | ERROR   | IP not whitelisted                               | Whitelist the IP address.                                                     |   | 422      | ERROR   | Insufficient balance to process this request.    | Ensure you have sufficient balance and then process the request.              |   | 500      | ERROR   | something went wrong, please try after some time | Try again after some time.                                                    |   | 500      | ERROR   | Unable to validate, please retry later           | Try again after some time.                                                    |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_pan_verification_with_http_info(pan_request_schema, x_api_version, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param pan_request_schema: Find the request parameters to verify whether the PAN information is valid (required)
        :type pan_request_schema: PanRequestSchema
        :param x_api_version: It is the API version. To receive the aadhaar seeding status in the response, use any date after 2022-09-12
        :type x_api_version: str
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetVerifyPanResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'pan_request_schema',
            'x_api_version',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_pan_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['pan_request_schema'] is not None:
            _body_params = _params['pan_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "GetVerifyPanResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/pan', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_pan_to_gstin_verification(self, pan_to_gstin_request_schema : Annotated[PanToGstinRequestSchema, Field(..., description="Find the request parameters to retrieve the list of GSTIN associated with a PAN")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Fetch GSTIN with PAN  # noqa: E501

        Use this API to fetch the list of GSTIN associated with the PAN information. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#fetch-gstin-with-pan) and use the information to trigger the validations. The test data are usable only in test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | Gstins List found                                      | -    | 200              | SUCCESS         | Gstin not found                  | No results found for the entered information. Enter the correct information in the request. | 400              | ERROR         | Enter valid PAN.                  | Enter the unique 10-character alphanumeric identifier issued by the Income Tax Department.  | 400              | ERROR         | pan is missing in the request.               | Enter the PAN information in the request to fetch the list of associated GSTIN.    | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_pan_to_gstin_verification_with_http_info(pan_to_gstin_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param pan_to_gstin_request_schema: Find the request parameters to retrieve the list of GSTIN associated with a PAN (required)
        :type pan_to_gstin_request_schema: PanToGstinRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PanToGstinResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'pan_to_gstin_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_pan_to_gstin_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['pan_to_gstin_request_schema'] is not None:
            _body_params = _params['pan_to_gstin_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "PanToGstinResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/pan-gstin', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_passport_verification(self, passport_verification_request_schema : Annotated[PassportVerificationRequestSchema, Field(..., description="Find the request parameter to retrieve your customer's passport information")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify Passport  # noqa: E501

        Use this API to verify passport information and ensure the identity of your customer. Provide the passport file number in the request and we help you fetch the details. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#passport) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | VALID                                      | -    | 200              | SUCCESS         | INVALID                  | Enter the correct information in the request. | 400              | ERROR         | verification_id is missing in the request.                  | Enter a valid verification_id in the request.  | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen, and underscores.               | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.   | 400              | ERROR         | file_number is missing in the request.                  | Enter the file number in the request.   | 400              | ERROR         | dob is missing in the request.                  | Enter the date of birth of the passport holder in the request.   | 400              | ERROR         | dob should be of type YYYY-MM-DD.                  | Enter the DOB in the YYYY-MM-DD format    | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_passport_verification_with_http_info(passport_verification_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param passport_verification_request_schema: Find the request parameter to retrieve your customer's passport information (required)
        :type passport_verification_request_schema: PassportVerificationRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PassportVerificationResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'passport_verification_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_passport_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['passport_verification_request_schema'] is not None:
            _body_params = _params['passport_verification_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "PassportVerificationResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/passport', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_reverse_geocoding_verification(self, reverse_geocoding_request_schema : Annotated[ReverseGeocodingRequestSchema, Field(..., description="Find the request parameters to retrieve the physical address of a location")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Reverse Geocoding  # noqa: E501

        Use this API to convert geohraphic coordinates (latitude and longitude) into readable location information for verification purposes. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#reverse-geocoding-coordinates) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | VALID                                      | -    | 400              | ERROR         | latitude value should range from -90 to 90.                  | Enter a value for the latitude that ranges between -90 and 90. | 400              | ERROR         | verification_id is missing in the request.                  | Enter a valid verification_id in the request.  | 400              | ERROR         | verification_id can include a maximum of 50 characters.               | Enter a verification ID within 50 characters. Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.   | 400              | ERROR         | longitude value should range from -180 to 180.                  | Enter a value for the longitude that ranges between -180 and 180.   | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen and underscores.                  | Only alphanumeric, period (.), hyphen (-), and underscore ( _ ) are allowed.     | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists                                           | Enter a unique verification ID to identify the request.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed                      | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_reverse_geocoding_verification_with_http_info(reverse_geocoding_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param reverse_geocoding_request_schema: Find the request parameters to retrieve the physical address of a location (required)
        :type reverse_geocoding_request_schema: ReverseGeocodingRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReverseGeocodingResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'reverse_geocoding_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_reverse_geocoding_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reverse_geocoding_request_schema'] is not None:
            _body_params = _params['reverse_geocoding_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "ReverseGeocodingResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/reverse-geocoding', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_reverse_penny_drop_create_request(self, create_request_request_schema : Annotated[CreateRequestRequestSchema, Field(..., description="Find the request parameters to create a reverse penny drop request")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create Reverse Penny Drop Request  # noqa: E501

        Use this API to create a reverse penny drop request. Reverse penny drop is a verification method for validating bank account information. Your customers/users deposit 1 rupee through a UPI based transaction and get the 1 rupee back once the verification is complete. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | -                                      | -    | 400              | ERROR         | verification_id is missing in the request.                  | Enter a valid verification_id in the request.   | 400              | ERROR         | verification_id already exists                  | Enter a unique verification_id.    | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | Unable to validate, please retry later                      | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_reverse_penny_drop_create_request_with_http_info(create_request_request_schema, async_req=True)
        >>> result = thread.get()

        :param create_request_request_schema: Find the request parameters to create a reverse penny drop request (required)
        :type create_request_request_schema: CreateRequestRequestSchema
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateRequestResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'create_request_request_schema'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_reverse_penny_drop_create_request" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_request_request_schema'] is not None:
            _body_params = _params['create_request_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "CreateRequestResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/reverse-penny-drop', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
    @validate_arguments
    def vrs_reverse_penny_drop_fetch_status(self, ref_id : Annotated[Optional[StrictStr], Field(description="It is the unique ID created by Cashfree Payments that you receive in the response of Create Reverse Penny Drop Request API.")] = None, verification_id : Annotated[Optional[StrictStr], Field(description="It is the unique ID created by you to identify the reverse penny drop verification request.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Reverse Penny Drop Request Details  # noqa: E501

        Use this API to get the details of the created reverse penny drop request. You need to enter either the reference ID or verification ID. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | SUCCESS                                       | -   | 200              | SUCCESS       | EXPIRED                                        | Create a new reverse penny drop order request if the link expired before the transaction.   | 200              | SUCCESS       | FAILURE                                        | Create a new reverse penny drop order request.   | 400              | ERROR         | Please provide verification_id or ref_id               | You need to enter either the reference ID or verification ID.   | 400              | ERROR         | Please enter a valid verification_id                  | Enter a valid verification_id in the request.  | 400              | ERROR         | Please enter a valid ref_id                      | Enter a valid reference ID in the request.  | 400              | ERROR         | x-client-id is missing in the request                     | Enter all the header information in the API request.  | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 500              | ERROR         | something went wrong, please try after some time                      | Try again after some time.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_reverse_penny_drop_fetch_status_with_http_info(ref_id, verification_id, async_req=True)
        >>> result = thread.get()

        :param ref_id: It is the unique ID created by Cashfree Payments that you receive in the response of Create Reverse Penny Drop Request API.
        :type ref_id: str
        :param verification_id: It is the unique ID created by you to identify the reverse penny drop verification request.
        :type verification_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetStatusRpdResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'ref_id',
            'verification_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_reverse_penny_drop_fetch_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ref_id') is not None:  # noqa: E501
            _query_params.append(('ref_id', _params['ref_id']))

        if _params.get('verification_id') is not None:  # noqa: E501
            _query_params.append(('verification_id', _params['verification_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "GetStatusRpdResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/remitter/status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_vehicle_rc_verification(self, vehicle_rc_request_schema : Annotated[VehicleRcRequestSchema, Field(..., description="Find the request parameters to retrieve the information of a vehicle's registration certificate")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Vehicle RC Details  # noqa: E501

        Use this API to verify the authenticity of vehicle details. We help you find out the complete information of the vehicle including the owner, chassis number, registration date, registration number, and more.  View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#registration-certificate-vehicle) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | Valid                                      | -   | 200              | SUCCESS       | Invalid                                        | Enter a valid registration number of the vehicle   | 400              | ERROR         | vehicle-rc is invalid               | Enter a valid registration number of the vehicle.   | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen, and underscores.                  | Enter a valid verification_id that includes only alphanumeric, period (.), hyphen (-), and underscore ( _ ).  | 400              | ERROR         | verification_id is missing in the request.               | Enter a valid verification ID in the request.   | 400              | ERROR         | verification_id can include a maximum of 50 characters.                  | Enter a valid verification_id that is withing 50 characters.    | 400              | ERROR         | x-client-id is missing in the request.                      | Enter all the header information in the API request.   | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists  | Enter a unique verification_id that includes only alphanumeric, period (.), hyphen (-), and underscore ( _ ).  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 502              | ERROR         | verification attempt failed            | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_vehicle_rc_verification_with_http_info(vehicle_rc_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param vehicle_rc_request_schema: Find the request parameters to retrieve the information of a vehicle's registration certificate (required)
        :type vehicle_rc_request_schema: VehicleRcRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VehicleRcResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'vehicle_rc_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_vehicle_rc_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['vehicle_rc_request_schema'] is not None:
            _body_params = _params['vehicle_rc_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "VehicleRcResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/vehicle-rc', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vrs_voter_id_verification(self, voter_id_request_schema : Annotated[VoterIdRequestSchema, Field(..., description="Find the request parameters to fetch voter ID details")] = None, x_cf_signature : Annotated[Optional[StrictStr], Field(description="Send the signature if IP is not whitelisted")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Verify Voter ID  # noqa: E501

        Use this API to verify the authenticity of your customer's voter ID. You need to enter the Electoral Photo Identity Card (EPIC) number and we retrieve complete details including assembly and parliamentary constituency details. View the [test data](https://docs.cashfree.com/docs/data-to-testintegration#voter-id) and use the information to trigger the validations. The test data are usable only in the test environments such as gamma and sandbox.   ### Response Codes   | Sub Code         |     Status    |    Message                                                  | Next Action   | ---------------- |---------------|-------------------------------------------------------------|-------------------------|   | 200              | SUCCESS       | Valid voter ID                                       | -   | 200              | SUCCESS       | Invalid voter ID                                        | -   | 400              | ERROR         | verification_id is missing in the request               | Enter a valid verification_id in the request.  | 400              | ERROR         | verification_id can include only alphanum, dot, hyphen, and underscores.                  | Enter a valid verification_id that includes only alphanumeric, period (.), hyphen (-), and underscore ( _ ).  | 400              | ERROR         | epic_number is missing in the request.                      | Enter a valid EPIC number which is the unique identification number assigned to each voter ID.  | 401              | ERROR         | Invalid clientId and clientSecret combination               | Ensure you enter valid x-client-id and x-client-secret information in the API request.  | 403              | ERROR         | IP not whitelisted                                           | Whitelist the IP address.  | 409              | ERROR         | verification id already exists  | Enter a unique verification_id that includes only alphanumeric, period (.), hyphen (-), and underscore ( _ ).  | 422              | ERROR         | Insufficient balance to process this request                | Try again with sufficient balance.  | 500              | ERROR         | something went wrong                      | Try again after some time.  | 500              | ERROR         | verification attempt failed            | Try again after some time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vrs_voter_id_verification_with_http_info(voter_id_request_schema, x_cf_signature, async_req=True)
        >>> result = thread.get()

        :param voter_id_request_schema: Find the request parameters to fetch voter ID details (required)
        :type voter_id_request_schema: VoterIdRequestSchema
        :param x_cf_signature: Send the signature if IP is not whitelisted
        :type x_cf_signature: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VoterIdResponseSchema, status_code(int), headers(HTTPHeaderDict))
        """

        api_client = ApiClient.get_default()
        host = "https://api.cashfree.com/verification"
        if Cashfree.XEnvironment == CFEnvironment.SANDBOX:
            host = "https://sandbox.cashfree.com/verification"
        configuration = Configuration(
            host = host
        )
        configuration.api_key['XClientID'] = Cashfree.XClientId
        configuration.api_key['XClientSecret'] = Cashfree.XClientSecret
        api_client.configuration = configuration
        _params = locals()

        _all_params = [
            'voter_id_request_schema',
            'x_cf_signature'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vrs_voter_id_verification" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        _header_params["x-sdk-platform"] = "pythonsdk-3.0.0"

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['voter_id_request_schema'] is not None:
            _body_params = _params['voter_id_request_schema']

        # set the HTTP header `Accept`
        _header_params['Accept'] = api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['XClientSecret', 'XClientID']  # noqa: E501

        _response_types_map = {
            '200': "VoterIdResponseSchema",
            '400': "ErrorResponseSchema",
            '401': "ErrorResponseSchema",
            '403': "ErrorResponseSchema",
            '409': "ErrorResponseSchema",
            '422': "ErrorResponseSchema",
            '500': "ErrorResponseSchema",
            '502': "ErrorResponseSchema",
        }

        return api_client.call_api(
            '/voter-id', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))



class ApiClient(object):
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    :param pool_threads: The number of threads to use for async requests
        to the API. More threads means more concurrent API requests.
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': dt.date,
        'datetime': dt.datetime,
        'object': object,
    }
    _pool = None

    def __init__(self, configuration=None, header_name=None, header_value=None,
                 cookie=None, pool_threads=1):
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration
        self.pool_threads = pool_threads

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/3.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def close(self):
        if self._pool:
            self._pool.close()
            self._pool.join()
            self._pool = None
            if hasattr(atexit, 'unregister'):
                atexit.unregister(self.close)

    @property
    def pool(self):
        """Create thread pool on first request
         avoids instantiating unused threadpool for blocking clients.
        """
        if self._pool is None:
            atexit.register(self.close)
            self._pool = ThreadPool(self.pool_threads)
        return self._pool

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def __call_api(
            self, resource_path, method, path_params=None,
            query_params=None, header_params=None, body=None, post_params=None,
            files=None, response_types_map=None, auth_settings=None,
            _return_http_data_only=None, collection_formats=None,
            _preload_content=True, _request_timeout=None, _host=None,
            _request_auth=None):

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(self.parameters_to_tuples(header_params,
                                                           collection_formats))

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(path_params,
                                                    collection_formats)
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(post_params,
                                                    collection_formats)
            post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params, query_params, auth_settings,
            resource_path, method, body,
            request_auth=_request_auth)

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(query_params,
                                                     collection_formats)
            url += "?" + url_query

        try:
            # perform request and return response
            response_data = self.request(
                method, url,
                query_params=query_params,
                headers=header_params,
                post_params=post_params, body=body,
                _preload_content=_preload_content,
                _request_timeout=_request_timeout)
        except ApiException as e:
            if e.body:
                e.body = e.body.decode('utf-8')
            raise e

        self.last_response = response_data

        return_data = None # assuming derialization is not needed
        # data needs deserialization or returns HTTP data (deserialized) only
        if _preload_content or _return_http_data_only:
          response_type = response_types_map.get(str(response_data.status), None)

          if response_type == "bytearray":
              response_data.data = response_data.data
          else:
              match = None
              content_type = response_data.getheader('content-type')
              if content_type is not None:
                  match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
              encoding = match.group(1) if match else "utf-8"
              response_data.data = response_data.data.decode(encoding)

          # deserialize response data
          if response_type == "bytearray":
              return_data = response_data.data
          elif response_type:
              return_data = self.deserialize(response_data, response_type)
          else:
              return_data = None

        if _return_http_data_only:
            return return_data
        else:
            return ApiResponse(status_code = response_data.status,
                           data = return_data,
                           headers = response_data.getheaders(),
                           raw_data = response_data.data)

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [self.sanitize_for_serialization(sub_obj)
                    for sub_obj in obj]
        elif isinstance(obj, tuple):
            return tuple(self.sanitize_for_serialization(sub_obj)
                         for sub_obj in obj)
        elif isinstance(obj, (dt.datetime, dt.date)):
            return obj.isoformat()

        if isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes `openapi_types`, `attribute_map`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            obj_dict = obj.to_dict()

        return {key: self.sanitize_for_serialization(val)
                for key, val in obj_dict.items()}

    def deserialize(self, response, response_type):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.

        :return: deserialized object.
        """
        # handle file downloading
        # save response body into a tmp file and return the instance
        if response_type == "file":
            return self.__deserialize_file(response)

        # fetch data from response object
        try:
            data = json.loads(response.data)
        except ValueError:
            data = response.data

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if type(klass) == str:
            if klass.startswith('List['):
                sub_kls = re.match(r'List\[(.*)]', klass).group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(cashfree_verification.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == dt.date:
            return self.__deserialize_date(data)
        elif klass == dt.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def call_api(self, resource_path, method,
                 path_params=None, query_params=None, header_params=None,
                 body=None, post_params=None, files=None,
                 response_types_map=None, auth_settings=None,
                 async_req=None, _return_http_data_only=None,
                 collection_formats=None, _preload_content=True,
                 _request_timeout=None, _host=None, _request_auth=None):
        """Makes the HTTP request (synchronous) and returns deserialized data.

        To make an async_req request, set the async_req parameter.

        :param resource_path: Path to method endpoint.
        :param method: Method to call.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for `application/x-www-form-urlencoded`, `multipart/form-data`.
        :param auth_settings list: Auth Settings names for the request.
        :param response: Response data type.
        :param files dict: key -> filename, value -> filepath,
            for `multipart/form-data`.
        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_token: dict, optional
        :return:
            If async_req parameter is True,
            the request will be called asynchronously.
            The method will return the request thread.
            If parameter async_req is False or missing,
            then the method will return the response directly.
        """
        if not async_req:
            return self.__call_api(resource_path, method,
                                   path_params, query_params, header_params,
                                   body, post_params, files,
                                   response_types_map, auth_settings,
                                   _return_http_data_only, collection_formats,
                                   _preload_content, _request_timeout, _host,
                                   _request_auth)

        return self.pool.apply_async(self.__call_api, (resource_path,
                                                       method, path_params,
                                                       query_params,
                                                       header_params, body,
                                                       post_params, files,
                                                       response_types_map,
                                                       auth_settings,
                                                       _return_http_data_only,
                                                       collection_formats,
                                                       _preload_content,
                                                       _request_timeout,
                                                       _host, _request_auth))

    def request(self, method, url, query_params=None, headers=None,
                post_params=None, body=None, _preload_content=True,
                _request_timeout=None):
        """Makes the HTTP request using RESTClient."""
        if method == "GET":
            return self.rest_client.get_request(url,
                                        query_params=query_params,
                                        _preload_content=_preload_content,
                                        _request_timeout=_request_timeout,
                                        headers=headers)
        elif method == "HEAD":
            return self.rest_client.head_request(url,
                                         query_params=query_params,
                                         _preload_content=_preload_content,
                                         _request_timeout=_request_timeout,
                                         headers=headers)
        elif method == "OPTIONS":
            return self.rest_client.options_request(url,
                                            query_params=query_params,
                                            headers=headers,
                                            _preload_content=_preload_content,
                                            _request_timeout=_request_timeout)
        elif method == "POST":
            return self.rest_client.post_request(url,
                                         query_params=query_params,
                                         headers=headers,
                                         post_params=post_params,
                                         _preload_content=_preload_content,
                                         _request_timeout=_request_timeout,
                                         body=body)
        elif method == "PUT":
            return self.rest_client.put_request(url,
                                        query_params=query_params,
                                        headers=headers,
                                        post_params=post_params,
                                        _preload_content=_preload_content,
                                        _request_timeout=_request_timeout,
                                        body=body)
        elif method == "PATCH":
            return self.rest_client.patch_request(url,
                                          query_params=query_params,
                                          headers=headers,
                                          post_params=post_params,
                                          _preload_content=_preload_content,
                                          _request_timeout=_request_timeout,
                                          body=body)
        elif method == "DELETE":
            return self.rest_client.delete_request(url,
                                           query_params=query_params,
                                           headers=headers,
                                           _preload_content=_preload_content,
                                           _request_timeout=_request_timeout,
                                           body=body)
        else:
            raise ApiValueError(
                "http method must be `GET`, `HEAD`, `OPTIONS`,"
                " `POST`, `PATCH`, `PUT` or `DELETE`."
            )

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v)))
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(item) for item in new_params])

    def files_parameters(self, files=None):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    with open(n, 'rb') as f:
                        filename = os.path.basename(f.name)
                        filedata = f.read()
                        mimetype = (mimetypes.guess_type(filename)[0] or
                                    'application/octet-stream')
                        params.append(
                            tuple([k, tuple([filename, filedata, mimetype])]))

        return params

    def select_header_accept(self, accepts):
        """Returns `Accept` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns `Content-Type` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(self, headers, queries, auth_settings,
                               resource_path, method, body,
                               request_auth=None):
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(headers, queries,
                                    resource_path, method, body,
                                    request_auth)
            return

        for auth in auth_settings:
            auth_setting = self.configuration.auth_settings().get(auth)
            if auth_setting:
                self._apply_auth_params(headers, queries,
                                        resource_path, method, body,
                                        auth_setting)

    def _apply_auth_params(self, headers, queries,
                           resource_path, method, body,
                           auth_setting):
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in `query` or `header`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the `Content-Disposition` header if provided.

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
                                 content_disposition).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse `{0}` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse `{0}` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)
