#!/usr/bin/env python3
"""
GoRequests v2.0 - Fully Integrated Optimizations
T√≠ch h·ª£p t·∫•t c·∫£ helper functions v√† optimizations
"""
import ctypes
import json
import os
import sys
from typing import Dict, Any, Optional

__version__ = "2.0.0"

__version__ = "2.0.0"

class GoRequestsError(Exception):
    """Base exception for GoRequests"""
    pass

class Response:
    """Response object t∆∞∆°ng th√≠ch v·ªõi requests.Response"""
    def __init__(self, data: dict):
        self._data = data
        self.status_code = data.get('status_code', 0)
        self.text = data.get('content', '')
        self.url = data.get('url', '')
        self.headers = data.get('headers', {})
        self.ok = 200 <= self.status_code < 300
    
    def json(self):
        """Parse response as JSON"""
        try:
            return json.loads(self.text)
        except:
            return None

class GoRequestsClient:
    """
    GoRequests Client - T√≠ch h·ª£p ho√†n to√†n t·∫•t c·∫£ optimizations
    
    ‚úÖ Kh√¥ng c·∫ßn setup functions n·ªØa - auto setup
    ‚úÖ Kh√¥ng c·∫ßn helper functions n·ªØa - ƒë√£ t√≠ch h·ª£p
    ‚úÖ API ƒë∆°n gi·∫£n nh∆∞ requests library
    
    Usage:
        client = GoRequestsClient()  # Auto-setup everything!
        response = client.get('http://httpbin.org/get')
        print(response.status_code)
    """
    
    def __init__(self, dll_path: Optional[str] = None):
        """Initialize v·ªõi automatic setup - kh√¥ng c·∫ßn config g√¨ th√™m"""
        # Auto-detect DLL path
        if dll_path is None:
            current_dir = os.path.dirname(__file__)
            dll_path = os.path.join(current_dir, 'libgorequests.dll')
        
        if not os.path.exists(dll_path):
            raise GoRequestsError(f"Cannot find library at {dll_path}")
        
        # Load library v√† auto-setup
        self._lib = ctypes.CDLL(dll_path)
        self._setup_library_optimized()  # T√≠ch h·ª£p setup function
        self._session = self._create_session()
    
    def _setup_library_optimized(self):
        """
        üöÄ T√≠ch h·ª£p setup_gorequests_lib function
        
        Thay v√¨ ng∆∞·ªùi d√πng ph·∫£i:
            lib.GetMemoryStats.restype = ctypes.c_char_p
            lib.GetMemoryStats.argtypes = []
            lib.CreateSession.restype = ctypes.c_int
            lib.CreateSession.argtypes = []
            lib.GoSessionRequest.restype = ctypes.c_char_p
            lib.GoSessionRequest.argtypes = [ctypes.c_int, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        
        Gi·ªù ƒë√¢y t·ª± ƒë·ªông ƒë∆∞·ª£c g·ªçi trong __init__
        """
        # Core functions - automatically setup
        self._lib.GetMemoryStats.restype = ctypes.c_char_p
        self._lib.GetMemoryStats.argtypes = []
        
        self._lib.CreateSession.restype = ctypes.c_int
        self._lib.CreateSession.argtypes = []
        
        self._lib.GoSessionRequest.restype = ctypes.c_char_p
        self._lib.GoSessionRequest.argtypes = [
            ctypes.c_int, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p
        ]
        
        # Note: Kh√¥ng setup FreeMemory ƒë·ªÉ tr√°nh hanging
    
    def _create_session(self) -> int:
        """Create session automatically"""
        return self._lib.CreateSession()
    
    def memory_stats(self) -> dict:
        """
        üöÄ T√≠ch h·ª£p get_memory_stats_simple function
        
        Thay v√¨:
            result = lib.GetMemoryStats()
            result_str = ctypes.cast(result, ctypes.c_char_p).value.decode('utf-8')
            stats = json.loads(result_str)
        
        Gi·ªù ƒë√¢y:
            stats = client.memory_stats()
        """
        result = self._lib.GetMemoryStats()
        result_str = ctypes.cast(result, ctypes.c_char_p).value.decode('utf-8')
        return json.loads(result_str)
    
    def _request_optimized(self, method: str, url: str, **kwargs) -> Response:
        """
        üöÄ T√≠ch h·ª£p make_request_simple function
        
        Thay v√¨ ph·ª©c t·∫°p:
            result_ptr = lib.GoSessionRequest(session, b'GET', b'http://example.com', options)
            result_str = ctypes.cast(result_ptr, ctypes.c_char_p).value.decode('utf-8')
            result = json.loads(result_str)
        
        Gi·ªù ƒë√¢y ƒë∆°n gi·∫£n: t·ª± ƒë·ªông x·ª≠ l√Ω trong _request_optimized()
        """
        # Prepare options v·ªõi smart defaults
        options = {
            'timeout': kwargs.get('timeout', 10),
            'headers': kwargs.get('headers', {}),
            'params': kwargs.get('params', {}),
        }
        
        # Handle different data types intelligently
        if 'data' in kwargs:
            if isinstance(kwargs['data'], dict):
                options['data'] = json.dumps(kwargs['data'])
                options['headers'].setdefault('Content-Type', 'application/json')
            else:
                options['data'] = str(kwargs['data'])
        
        if 'json' in kwargs:
            options['data'] = json.dumps(kwargs['json'])
            options['headers']['Content-Type'] = 'application/json'
        
        # Auto-convert to proper formats
        options_json = json.dumps(options).encode('utf-8')
        method_bytes = method.encode()
        url_bytes = url.encode()
        
        # Make request - t·∫•t c·∫£ complexity ƒë∆∞·ª£c ·∫©n ƒëi
        result_ptr = self._lib.GoSessionRequest(
            self._session,
            method_bytes,
            url_bytes,
            options_json
        )
        
        # Auto-parse response - kh√¥ng c·∫ßn manual handling
        result_str = ctypes.cast(result_ptr, ctypes.c_char_p).value.decode('utf-8')
        result = json.loads(result_str)
        
        return Response(result)
    
    # HTTP methods - API ho√†n to√†n t∆∞∆°ng th√≠ch requests library
    def get(self, url: str, **kwargs) -> Response:
        """HTTP GET request - t∆∞∆°ng th√≠ch requests.get()"""
        return self._request_optimized('GET', url, **kwargs)
    
    def post(self, url: str, **kwargs) -> Response:
        """HTTP POST request - t∆∞∆°ng th√≠ch requests.post()"""
        return self._request_optimized('POST', url, **kwargs)
    
    def put(self, url: str, **kwargs) -> Response:
        """HTTP PUT request - t∆∞∆°ng th√≠ch requests.put()"""
        return self._request_optimized('PUT', url, **kwargs)
    
    def delete(self, url: str, **kwargs) -> Response:
        """HTTP DELETE request - t∆∞∆°ng th√≠ch requests.delete()"""
        return self._request_optimized('DELETE', url, **kwargs)
    
    def patch(self, url: str, **kwargs) -> Response:
        """HTTP PATCH request - t∆∞∆°ng th√≠ch requests.patch()"""
        return self._request_optimized('PATCH', url, **kwargs)
    
    def head(self, url: str, **kwargs) -> Response:
        """HTTP HEAD request - t∆∞∆°ng th√≠ch requests.head()"""
        return self._request_optimized('HEAD', url, **kwargs)
    
    def options(self, url: str, **kwargs) -> Response:
        """HTTP OPTIONS request - t∆∞∆°ng th√≠ch requests.options()"""
        return self._request_optimized('OPTIONS', url, **kwargs)

# Global client cho convenience - nh∆∞ requests library
_default_client = None

def _get_client():
    """Get ho·∫∑c create default client instance"""
    global _default_client
    if _default_client is None:
        _default_client = GoRequestsClient()
    return _default_client

# Global functions - API ho√†n to√†n t∆∞∆°ng th√≠ch requests library
def get(url: str, **kwargs) -> Response:
    """HTTP GET - drop-in replacement cho requests.get()"""
    return _get_client().get(url, **kwargs)

def post(url: str, **kwargs) -> Response:
    """HTTP POST - drop-in replacement cho requests.post()"""
    return _get_client().post(url, **kwargs)

def put(url: str, **kwargs) -> Response:
    """HTTP PUT - drop-in replacement cho requests.put()"""
    return _get_client().put(url, **kwargs)

def delete(url: str, **kwargs) -> Response:
    """HTTP DELETE - drop-in replacement cho requests.delete()"""
    return _get_client().delete(url, **kwargs)

def patch(url: str, **kwargs) -> Response:
    """HTTP PATCH - drop-in replacement cho requests.patch()"""
    return _get_client().patch(url, **kwargs)

def head(url: str, **kwargs) -> Response:
    """HTTP HEAD - drop-in replacement cho requests.head()"""
    return _get_client().head(url, **kwargs)

def options(url: str, **kwargs) -> Response:
    """HTTP OPTIONS - drop-in replacement cho requests.options()"""
    return _get_client().options(url, **kwargs)

def get_memory_stats() -> dict:
    """
    üöÄ T√≠ch h·ª£p memory stats function - global access
    
    Thay v√¨ setup library v√† call functions manually,
    gi·ªù ƒë√¢y ch·ªâ c·∫ßn: stats = get_memory_stats()
    """
    try:
        return _get_client().memory_stats()
    except Exception as e:
        return {'error': str(e)}

# Compatibility aliases
Session = GoRequestsClient  # Alias for compatibility

# Demo v√† validation
if __name__ == "__main__":
    print("üöÄ GoRequests v2.0 - Fully Integrated & Optimized")
    print("=" * 60)
    
    try:
        print("\nüì¶ Demo 1: Zero-config usage")
        print("   Code: import gorequests; response = gorequests.get('...')")
        
        # S·ª≠ d·ª•ng nh∆∞ requests library - zero configuration!
        response = get('http://httpbin.org/get', 
                      params={'integrated': 'true'},
                      headers={'User-Agent': 'GoRequests v2.0'})
        print(f"   ‚úÖ Status: {response.status_code}")
        print(f"   ‚úÖ URL: {response.url}")
        
        print("\nüì¶ Demo 2: Client-based usage")
        print("   Code: client = GoRequestsClient(); response = client.post(...)")
        
        # Client usage v·ªõi auto-setup
        client = GoRequestsClient()
        post_response = client.post('http://httpbin.org/post',
                                   json={'message': 'Fully integrated!'},
                                   timeout=5)
        print(f"   ‚úÖ POST Status: {post_response.status_code}")
        
        print("\nüì¶ Demo 3: Memory stats integrated")
        print("   Code: stats = get_memory_stats()")
        
        # Memory stats - no manual setup needed
        stats = get_memory_stats()
        print(f"   ‚úÖ Memory: {stats['alloc']:,} bytes")
        print(f"   ‚úÖ Sessions: {stats['sessions']}")
        
        print("\nüì¶ Demo 4: Multiple requests")
        import time
        start_time = time.time()
        for i in range(3):
            resp = get('http://httpbin.org/get', timeout=3)
            print(f"   Request {i+1}: Status {resp.status_code}")
        elapsed = time.time() - start_time
        print(f"   ‚úÖ 3 requests: {elapsed:.2f}s")
        
        print("\n" + "=" * 60)
        print("üéâ FULL INTEGRATION SUCCESS!")
        print("‚úÖ Zero configuration needed")
        print("‚úÖ Drop-in replacement for requests")
        print("‚úÖ All optimizations integrated")
        print("‚úÖ No helper functions needed")
        print("‚úÖ Auto-setup everything")
        print("‚úÖ High performance with Go/FastHTTP backend")
        
        print("\nüí° MIGRATION FROM REQUESTS:")
        print("OLD:")
        print("   import requests")
        print("   response = requests.get('https://api.example.com')")
        print()
        print("NEW:")
        print("   import gorequests as requests  # Drop-in replacement!")
        print("   response = requests.get('https://api.example.com')")
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
