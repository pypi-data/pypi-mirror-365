# Generated via: macrotype macrotype -o stubs
# Do not edit by hand
from typing import Any, Callable
from dataclasses import _DataclassParams, dataclass
from enum import EnumType
from functools import partialmethod
from inspect import Signature
from macrotype.meta_types import get_overloads

ModuleType = module

_INDENT: str

_MODULE_ALIASES: dict[str, str]

_get_overloads = get_overloads

class PyiElement:
    def render(self, indent: int) -> list[str]: ...
    @staticmethod
    def _space(indent: int) -> str: ...

@dataclass
class PyiNamedElement(PyiElement):
    name: str
    used_types: set[type]

@dataclass
class TypeRenderInfo:
    text: str
    used: set[type]

def format_type(type_obj: Any) -> TypeRenderInfo: ...

def format_type_param(tp: Any) -> TypeRenderInfo: ...

def find_typevars(type_obj: Any) -> set[str]: ...

_DATACLASS_DEFAULTS: dict[str, Any]

def _dataclass_auto_methods(params: _DataclassParams | None) -> set[str]: ...

_ATTR_DECORATORS: dict[type, tuple[str, str]]

_ALIAS_TYPES: tuple[type, ...]

def _unwrap_decorated_function(obj: Any) -> Callable | None: ...

def _unwrap_descriptor(obj: Any) -> Any | None: ...

def _extract_partialmethod(pm: partialmethod, klass: type, name: str, *, globalns: dict[str, Any]) -> Callable: ...

def _get_class_function(attr: Any, name: str, klass: type, *, globalns: dict[str, Any]) -> Callable | None: ...

def _dataclass_decorator(klass: type) -> tuple[str, set[type]] | None: ...

@dataclass
class PyiVariable(PyiNamedElement):
    type_str: str
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_assignment(cls, name: str, value: Any) -> PyiVariable: ...

@dataclass
class PyiAlias(PyiNamedElement):
    value: str
    keyword: str
    type_params: list[str]
    def render(self, indent: int) -> list[str]: ...

def _collect_args(sig: Signature, hints: dict[str, Any]) -> tuple[list[tuple[str, str | None]], set[type]]: ...

def _collect_type_params(fn: Callable, hints: dict[str, Any], exclude_params: set[str] | None) -> tuple[list[str], set[type]]: ...

def _collect_decorators(decorators: list[str] | None, fn: Callable) -> tuple[list[str], set[type]]: ...

def _typeddict_info(klass: type) -> tuple[list[type], bool | None]: ...

def _class_decorators(klass: type) -> tuple[list[str], set[type], bool]: ...

def _namedtuple_members(klass: type) -> tuple[list[PyiElement], set[type]]: ...

def _namedtuple_bases(klass: type, type_params: list[str]) -> tuple[list[str], set[type]]: ...

def _typeddict_bases(klass: type, bases: list[type]) -> tuple[list[str], set[type]]: ...

def _normal_class_bases(klass: type, type_params: list[str]) -> tuple[list[str], set[type]]: ...

def _class_variables(klass: type, *, globalns: dict[str, Any], is_typeddict: bool, td_bases: list[type], is_dataclass_obj: bool) -> tuple[list[PyiElement], set[type]]: ...

def _enum_members(klass: EnumType) -> list[PyiElement]: ...

def _auto_methods(klass: type, *, is_dataclass_obj: bool, is_enum: bool) -> set[str]: ...

def _protocol_skip_methods(klass: type) -> set[str]: ...

def _function_members(fn: Callable, *, class_params: set[str], globalns: dict[str, Any], localns: dict[str, Any]) -> tuple[list[PyiFunction], set[type]]: ...

def _descriptor_members(attr_name: str, attr: Any, *, class_params: set[str], globalns: dict[str, Any], localns: dict[str, Any]) -> tuple[list[PyiElement], set[type]]: ...

def _class_methods(klass: type, *, globalns: dict[str, Any], class_params: set[str], is_enum: bool, is_dataclass_obj: bool) -> tuple[list[PyiElement], set[type]]: ...

@dataclass
class PyiFunction(PyiNamedElement):
    args: list[tuple[str, str | None]]
    return_type: str
    decorators: list[str]
    type_params: list[str]
    is_async: bool
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_function(cls, fn: Callable, decorators: list[str] | None, exclude_params: set[str] | None, *, globalns: dict[str, Any] | None, localns: dict[str, Any] | None) -> PyiFunction: ...

@dataclass
class PyiClass(PyiNamedElement):
    bases: list[str]
    type_params: list[str]
    body: list[PyiElement]
    typeddict_total: bool | None
    decorators: list[str]
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_class(cls, klass: type) -> PyiClass: ...

class _ModuleBuilder:
    def __init__(self, mod: module) -> None: ...
    def _add(self, item: PyiElement) -> None: ...
    def _handle_alias(self, name: str, obj: Any) -> bool: ...
    def _handle_foreign_variable(self, name: str, obj: Any) -> bool: ...
    def _handle_function(self, name: str, obj: Any) -> bool: ...
    def _handle_class(self, name: str, obj: Any) -> bool: ...
    def _handle_newtype(self, name: str, obj: Any) -> bool: ...
    def _handle_alias_types(self, name: str, obj: Any) -> bool: ...
    def _handle_constant(self, name: str, obj: Any) -> bool: ...
    def _process_object(self, name: str, obj: Any) -> None: ...
    def _remaining_annotations(self) -> None: ...
    def _imports(self) -> list[str]: ...
    def build(self) -> PyiModule: ...

@dataclass
class PyiModule:
    imports: list[str]
    body: list[PyiElement]
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_module(cls, mod: module) -> PyiModule: ...
